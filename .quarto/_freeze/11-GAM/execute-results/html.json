{
  "hash": "63ef30f8c9fec5e51097c8b4c21f4ed8",
  "result": {
    "markdown": "# Modèles généralisés additifs  {#sec-chap11}\n\nDans les précédents chapitres, nous avons eu l'occasion d'explorer toute une panoplie de modèles : régressions linéaires, modèles généralisés, modèles généralisés à effets mixtes et modèles multiniveaux. Dans ce chapitre, nous abordons une nouvelle extension dans le monde des régressions : les modèles généralisés additifs (*Generalized additive model* en anglais — GAM). Cette extension a pour but de permettre de modéliser des relations non linéaires entre les variables indépendantes et la variable dépendante.\n\n::: bloc_package\n::: bloc_package-header\n::: bloc_package-icon\n:::\n**Liste des *packages* utilisés dans ce chapitre**\n:::\n::: bloc_package-body\n\n* Pour créer des graphiques :\n  - `ggplot2` le seul, l'unique!\n  - `ggpubr` pour combiner des graphiques et réaliser des diagrammes.\n  - `metR` pour placer des étiquettes sur des isolignes.\n  \n* Pour jouer avec des *splines* :\n  - `splines2` pour construire les fonctions de base de nombreuses *splines*.\n  - `segmented` pour ajuster des modèles avec des coefficients variant par segment.\n  \n* Pour ajuster des modèles GAM :\n  - `mgcv`, le *package* de référence pour ajuster des GAM dans R!\n  - `gamlss`, un second *package* très flexible pour ajuster des GAM.\n  - `gamlss.add`, une extension de `gamlss` ajoutant des distributions supplémentaires.\n\n* Pour analyser des modèles GAM :\n  - `itsadug` pour notamment extraire certains résultats d'un GAM.\n  - `mixedup` pour notamment extraire les effets aléatoires d'un GAM.\n  - `DHARMa` pour le diagnostic des résidus simulés.\n:::\n:::\n\n\n## Introduction {#sec-111}\n\nPuisque les modèles GAM sont une extension des modèles GLM, ils peuvent s'appliquer à des modèles pour des variables indépendantes qualitatives, de comptage ou continues. Nous l'appliquons ici, à titre d'illustration, à une variable indépendante continue. Pour rappel, la formule décrivant un modèle linéaire généralisé (GLM) utilisant une distribution normale et une fonction de lien identitaire est la suivante : \n\n$$\n\\begin{aligned}\n&Y \\sim Normal(\\mu,\\sigma)\\\\\n&g(\\mu) = \\beta_0 + \\beta X\\\\\n&g(x) = x\n\\end{aligned}\n$$ {#eq-glm1B}\n\nLes coefficients $\\beta$ permettent de quantifier l'effet des variables indépendantes (*X*) sur la moyenne (l'espérance) ($\\mu$) de la variable dépendante (*Y*). Un coefficient $\\beta_k$ négatif indique que, si la variable $X_k$ augmente, alors la variable *Y* tend à diminuer et inversement, si le coefficient est positif. L'inconvénient de cette formulation est que le modèle est capable de capter uniquement des relations linéaires entre ces variables. Or, il existe de nombreuses situations dans lesquelles une variable indépendante a un lien non linéaire avec une variable dépendante; voici quelques exemples : \n\n* Si nous mesurons le niveau de bruit émis par une source sonore (variable dépendante) à plusieurs endroits et que nous tentons de prédire l'intensité sonore en fonction de la distance à la source (variable indépendante), nous pouvons nous attendre à observer une relation non linéaire entre les deux. En effet, le son étant une énergie se dispersant selon une sphère dans l'espace, son intensité est inversement proportionnelle au carré de la distance avec la source sonore.\n\n* La concentration de la pollution atmosphérique en ville suit généralement des patrons temporels et spatiaux influencés directement par la météorologie et les activités humaines. Autrement dit, il serait absurde d'introduire l'espace de façon linéaire (avec un gradient nord-sud ou est-ouest), ou le moment de la journée de façon linéaire (comme si la pollution augmentait du matin au soir ou inversement). En guise d'exemple, la @fig-gam1, tirée de @2020_3, illustre bien ces variations temporelles pour deux polluants (le dioxyde d'azote et l'ozone).\n\n\n![Patron journalier du dioxyde d'azote et de l'ozone à Paris](images/Chap11/no2_03_patterns.png){#fig-gam1 width=\"75%\" fig-align=\"center\"}\n\n### Non-linéarité fonctionnelle {#sec-1111}\n\nIl existe de nombreuses façons d'introduire des relations non linéaires dans un modèle. La première et la plus simple à mettre en œuvre est de transformer la variable indépendante à l'aide d'une fonction inverse, exponentielle, logarithmique ou autre.\n\nPrenons un premier exemple avec une variable *Y* que nous tentons de prédire avec une variable *X*, présenté à la @fig-gam2. Si nous ajustons une droite de régression à ces données (en bleu), nous constatons que l'augmentation de *X* est associée à une augmentation de *Y*. Cependant, la droite de régression est très éloignée des données et ne capte qu'une petite partie de la relation. Une lecture attentive permet de constater que l'effet de *X* sur *Y* augmente de plus en plus rapidement à mesure que *X* augmente. Cette forme est caractéristique d'une relation exponentielle. Nous pouvons donc transformer la variable *X* avec la fonction exponentielle afin d'obtenir un meilleur ajustement (en rouge).\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Relation non linéaire exponentielle](11-GAM_files/figure-html/fig-gam2-1.png){#fig-gam2 fig-align='center' width=50%}\n:::\n:::\n\n\n\nLa @fig-gam3 illustre trois autres situations avec les fonctions logarithmique, logistique inverse et racine carrée. Cette approche peut donner des résultats intéressants si vous disposez d'une bonne justification théorique sur la forme attendue de la relation entre *X* et *Y*. \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Autres relations non linéaires](11-GAM_files/figure-html/fig-gam3-1.png){#fig-gam3 fig-align='center' width=75%}\n:::\n:::\n\n\nIl existe également des cas de figure dans lesquels aucune fonction ne donne de résultats pertinents, comme illustré à la @fig-gam4. Nous constatons facilement qu'aucune des fonctions proposées n'est capable de bien capter la relation entre les deux variables. Puisque cette relation est complexe, il convient alors d'utiliser une autre stratégie pour la modéliser. \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Relation non linéaire plus complexe](11-GAM_files/figure-html/fig-gam4-1.png){#fig-gam4 fig-align='center' width=75%}\n:::\n:::\n\n\n\n### Non-linéarité avec des polynomiales {#sec-1112}\n\nNous avons vu, dans le chapitre sur la régression simple ([section @sec-07511]), qu'il est possible d'utiliser des polynomiales pour ajuster des relations non linéaires. Pour rappel, il s'agit simplement d'ajouter à un modèle la variable *X* à différents exposants ($X+X^2+\\dots+X^k$). Chaque exposant supplémentaire (chaque ordre supplémentaire) permet au modèle d'ajuster une relation plus complexe. Rien de tel qu'un graphique pour illustrer le tout (@fig-gam5).\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Visualisation de plusieurs polynomiales](11-GAM_files/figure-html/fig-gam5-1.png){#fig-gam5 fig-align='center' width=70%}\n:::\n:::\n\n\nL'enjeu est de sélectionner le bon nombre de degrés de la polynomiale pour le modèle. Chaque degré supplémentaire constitue une nouvelle variable dans le modèle, et donc un paramètre supplémentaire. Un trop faible nombre de degrés produit des courbes trop simplistes, alors qu'un nombre trop élevé conduit à un surajustement (*overfitting* en anglais) du modèle. La @fig-gam6 illustre ces deux situations.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Sur et sous-ajustement d'une polynomiale](11-GAM_files/figure-html/fig-gam6-1.png){#fig-gam6 fig-align='center' width=70%}\n:::\n:::\n\n\nUn des problèmes inhérents à l'approche des polynomiales est la difficulté d'interprétation. En effet, les coefficients ne sont pas directement interprétables et seule une figure représentant les prédictions du modèle permet d'avoir une idée de l'effet de la variable *X* sur la variable *Y*.\n\n### Non-linéarité par segments {#sec-1113}\n\nUn compromis intéressant offrant une interprétation simple et une relation potentiellement complexe consiste à découper la variable *X* en segments, puis d'ajuster un coefficient pour chacun de ces segments. Nous obtenons ainsi une ligne brisée et des coefficients faciles à interpréter (@fig-gam7). Nous ne présentons pas d'exemple d'application dans R, mais sachez que le *package* `segmented` permet d'ajuster ce type de modèle. \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Régression par segment](11-GAM_files/figure-html/fig-gam7-1.png){#fig-gam7 fig-align='center' width=70%}\n:::\n:::\n\n\nL'enjeu est alors de déterminer le nombre de points et la localisation de points de rupture. L'inconvénient majeur de cette approche est qu'en réalité, peu de phénomènes sont marqués par des ruptures très nettes.\n\nÀ la @fig-gam7, nous avons divisé la variable *X* en trois segments ($k_1$, $k_2$ et $k_3$), définis respectivement avec les intervalles suivants : [0,00-0,22], [0,22-0,41] et [0,41-1,00]. Concrètement, cela revient à diviser la variable *X* en trois nouvelles variables $X_{k1}$, $X_{k2}$, et $X_{k3}$. La valeur de $X_{ik}$ est égale à $x_i$ si $x_i$ se trouve dans l'intervalle propre à *k*, et à 0 autrement. Ici, nous obtenons trois coefficients : \n\n* le premier est positif, une augmentation de *X* sur le premier segment est associée à une augmentation de *Y*;\n\n* le second est négatif, une augmentation de *X* sur le second segment est associée à une diminution de *Y*;\n\n* le troisième est aussi négatif, une augmentation de *X* sur le troisième segment est associée à une diminution de *Y*, mais moins forte que pour le second segment.\n\n\n### Non-linéarité avec des *splines* {#sec-1114}\n\nLa dernière approche, et certainement la plus flexible, est d'utiliser ce que l'on appelle une *spline* pour capter des relations non linéaires. Une *spline* est une fonction créant des variables supplémentaires à partir d'une variable *X* et d'une fonction de base. Ces variables supplémentaires, appelées bases (*basis* en anglais), sont ajoutées au modèle; la sommation de leurs valeurs multipliées par leurs coefficients permet de capter les relations non linéaires entre une variable dépendante et une variable indépendante. Le nombre de bases et leur localisation (plus souvent appelé nœuds) permettent de contrôler la complexité de la fonction non linéaire.\n\nPrenons un premier exemple simple avec une fonction de base triangulaire (*tent basis* en anglais). Nous créons ici une *spline* avec sept nœuds répartis équitablement sur l'intervalle de valeurs de la variable *X*. Les sept bases qui en résultent sont présentées à la @fig-gam8. Dans cette figure, chaque sommet d'un triangle correspond à un nœud et chaque triangle correspond à une base.\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Bases de la spline triangulaire](11-GAM_files/figure-html/fig-gam8-1.png){#fig-gam8 fig-align='center' width=70%}\n:::\n:::\n\n\n\nEn ajoutant ces bases dans notre modèle de régression, nous pouvons ajuster un coefficient pour chacune et le représenter en multipliant ces bases par les coefficients obtenus avec une simple régression linéaire (@fig-gam9).\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Spline triangulaire multipliée par ces coefficients](11-GAM_files/figure-html/fig-gam9-1.png){#fig-gam9 fig-align='center' width=70%}\n:::\n:::\n\n\nNous remarquons ainsi que les bases correspondant à des valeurs plus fortes de *Y* ont reçu des coefficients plus élevés. Pour reconstituer la fonction non linéaire, il suffit d'additionner ces bases multipliées par leurs coefficients, soit la ligne bleue à la @fig-gam10.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Spline triangulaire](11-GAM_files/figure-html/fig-gam10-1.png){#fig-gam10 fig-align='center' width=70%}\n:::\n:::\n\n\nLa fonction de base triangulaire est intéressante pour présenter la logique qui sous-tend les *splines*, mais elle est rarement utilisée en pratique. On lui préfère généralement d'autres formes donnant des résultats plus lisses comme les *B-spline* quadratiques, *B-spline* cubiques, *M-spline*, *Duchon spline*, etc.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Comparaison de différentes bases](11-GAM_files/figure-html/fig-gam11-1.png){#fig-gam11 fig-align='center' width=75%}\n:::\n:::\n\n\nLes approches que nous venons de décrire sont regroupées sous l'appellation de modèles additifs. Dans les prochaines sous-sections, nous nous concentrons davantage sur les *splines* du fait de leur plus grande flexibilité.\n\n## *Spline* de régression et *spline* de lissage {#sec-112}\n\nDans les exemples précédents, nous avons vu que la construction d'une *spline* nécessite d'effectuer deux choix importants : le nombre de nœuds et leur localisation. Un trop grand nombre de nœuds conduit à un surajustement du modèle alors qu'un trop faible nombre de nœuds conduit à un sous-ajustement. Lorsque ces choix sont effectués par l'utilisateur et que les bases sont ajoutées manuellement dans le modèle tel que décrit précédemment, nous parlons alors de **_splines_ de régression** (*Regression Spline* en anglais).\n\nUne approche a été proposée pour faciliter le choix du nombre de nœuds, il s'agit de **_splines_ de lissage**  (*smoothing spline* en anglais). L'idée derrière cette approche est d'introduire dans le modèle une pénalisation associée avec le nombre de nœuds (ou degré de liberté) de la *spline*, dans un souci de parcimonie : chaque nœud supplémentaire doit suffisamment contribuer au modèle pour être conservé. Il n'est pas nécessaire ici de rentrer dans le détail mathématique de cette pénalisation qui est un peu complexe. Retenez simplement qu'elle dépend d'un paramètre appelé $\\lambda$ :\n\n* plus $\\lambda$ tend vers 0, plus la pénalisation est faible et plus la *spline* de lissage devient une simple *spline* de régression; \n\n* à l'inverse, plus elle est forte, plus la pénalité est importante, au point que la *spline* peut se résumer à une simple ligne droite. \n\nCela est illustré à la @fig-gam12 comprenant trois *splines* avec 20 nœuds et des valeurs $\\lambda$ différentes contrôlant la force de la pénalité. \n\nBien évidemment, nous constatons qu'avec la *spline* de régression (non pénalisée), 20 nœuds conduisent à un fort surajustement du modèle. En revanche, les *splines* de lissage (pénalisées) permettent de corriger ce problème de surajustement. Toutefois, une valeur trop importante de $\\lambda$ conduit à un sous-ajustement du modèle (ici $\\lambda = 3$ et $\\lambda = 100$, lignes verte et bleue).\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Pénalisation des splines](11-GAM_files/figure-html/fig-gam12-1.png){#fig-gam12 fig-align='center' width=70%}\n:::\n:::\n\n\n\nAvec les *splines* de lissage, l'enjeu est de sélectionner une valeur optimale de $\\lambda$. Le plus souvent, les *packages* R **estiment eux-mêmes** ce paramètre à partir des données utilisées dans le modèle. Toutefois, gardez en mémoire que vous pouvez modifier ce paramètre. Mentionnons également que les *splines* de lissage peuvent être reparamétrées dans un modèle pour être intégrées comme des effets aléatoires. Dans ce cas-ci, $\\lambda$ est remplacé par un simple paramètre de variance directement estimé dans le modèle [@wood2004stable].\n\n\n## Interprétation d'une *spline* {#sec-113}\n\nL'interprétation d'une *spline* se fait à l'aide de graphiques. En effet, puisqu'elle est composée d'un ensemble de coefficients appliqués à des bases, il est difficile d'interpréter directement ces derniers. Nous préférons alors représenter la fonction obtenue à l'aide d'un graphique, illustrant son **effet marginal**. Ce graphique est construit en trois étapes : \n\n1. Créer un jeu de données fictif dans lequel l'ensemble des variables indépendantes sont fixées à leurs moyennes respectives, sauf la variable pour laquelle nous souhaitons représenter la *spline*. Pour cette dernière, un ensemble de valeurs allant de son minimum à son maximum est utilisé;\n\n2. Utiliser le modèle pour prédire les valeurs attendues de la variable dépendante pour chacune des observations fictives ainsi créées;\n\n3. Afficher les prédictions obtenues dans un graphique.\n\nNotez ici qu'un graphique des effets marginaux se base sur les prédictions du modèle. Si un modèle est mal ajusté, les prédictions ne seront pas fiables et il sera inutile d'interpréter la *spline* obtenue.\n\nIl est aussi possible, dans le cas des *splines* de lissage, d'interpréter les *estimated degrees of freedom* (EDF) qui constituent une approximation du nombre de nœuds de la *spline*. S'ils ne nous renseignent pas sur la forme de la *spline*, ils nous indiquent son niveau de complexité. Une *spline* avec un EDF de 1 est en réalité un simple terme linéaire. Plus l'EDF augmente, plus la *spline* est complexe. \n\n\n## Multicolinéarité non linéaire {#sec-114}\n\nLorsque des *splines* sont ajoutées dans un modèle, il est nécessaire de vérifier si ces dernières ne posent pas un problème de multicolinéarité. Cependant, le VIF ne peut plus être utilisé du fait de la non-linéarité des relations modélisées. Il est alors nécessaire d'utiliser une autre mesure : la concurvité (*concurvity*) permettant de mesurer sur une échelle allant de 0 à 1 à quel point deux *splines* ont en réalité capturé le même effet et se substituent l'une à l'autre. Une valeur de 0 indique une absence totale de concurvité alors qu'une valeur de 1 indique que deux *splines* sont rigoureusement identiques (modèle non identifiable). \n\n## *Splines* avancées {#sec-115}\n\nJusqu'ici, nous avons seulement présenté le cas le plus simple pour lequel une *spline* est construite à partir d'une seule variable dépendante continue, mais les **splines** peuvent être utilisées dans de nombreux autres contextes et ont une incroyable flexibilité. Nous détaillons ici trois exemples fréquents : les *splines* cycliques, les *splines* variant par groupe et les *splines* multivariées. Pour une description complète des effets non linéaires possibles avec `mgcv`, n'hésitez pas à consulter sa [documentation](https://stat.ethz.ch/R-manual/R-patched/library/mgcv/html/smooth.terms.html).\n\n\n::: {#tbl-exemplesplines .cell tbl-cap='Exemples de splines avancées'}\n::: {.cell-output-display}\n|Type                           |Code                        |Description                                                                                                                                                                                                                               |\n|:------------------------------|:---------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n|spline cyclique                |`s(x, bs = 'cc')`           |Une spline cyclique doit être utilisée si le 0 de la variable X correspond également à sa valeur maximum. Un bon exemple est le temps dans une journée, car 24 h est équivalent à 0 h                                                     |\n|spline variant par groupe      |`s(x, by = x2)`             |Une spline variant par groupe permet d'ajuster une spline à une variable X1 différente pour chaque groupe identifié par une variable qualitative X2                                                                                       |\n|spline bivariée                |`s(x1,x2)`                  |Une spline bivariée est utilisée pour modéliser l'interaction non linéaire de deux variables X1 et X2 s'exprimant dans la même unité (typiquement des coordonnées géographiques cartésiennes)                                             |\n|spline d'interaction complète  |`te(x1,x2)`                 |Une spline d'interaction permet de modéliser l'interaction non linéaire de deux variables continues pouvant s'exprimer dans des unités différentes, elle combine les effets spécifiques de chacune des deux variables et leur interaction |\n|spline d'interaction partielle |`s(x1) + s(x2) + ti(x1,x2)` |Une spline d'interaction partielle permet de distinguer les effets non linéaires individuels de deux variables de leur interaction non linéaire                                                                                           |\n:::\n:::\n\n\n\n### *Splines* cycliques {#sec-1151}\n\nUne *spline* cyclique est une extension d'une *spline* classique dont les bases aux extrémités sont spécifiées de telle sorte que la valeur au départ de la *spline* soit la même que celle à la fin de la *spline*. Cela permet à la *spline* de former une boucle, ce qui est particulièrement intéressant pour des variables dont le 0 et la valeur maximale correspondent en réalité à la même valeur. L'exemple le plus parlant est certainement le cas d'une variable représentant la mesure d'un angle en degrés. Les valeurs de 0 et 360 sont identiques et les valeurs 350 et 10 sont toutes les deux à une distance de 10 degrés de 0. Un autre exemple possible serait de considérer l'heure comme une variable continue; dans ce cas, 24 h et 0 h signifient la même chose.\n\nPrenons un exemple concret. Nous souhaitons modéliser la concentration de dioxyde d'azote (NO~2~) à Paris, mesurée par un ensemble de stations fixes. Nous pourrions nous attendre à ce que le NO~2~ suive chaque jour un certain patron. Concrètement, à proximité d'axes routiers majeurs, nous nous attendons à observer des pics suivant les flux pendulaires. À la @fig-gam13, nous retrouvons bien les deux pics attendus correspondant aux heures de pointe du matin et du soir. Aussi, comme indiqué par la ligne rouge, la valeur prédite par la *spline* est la même à 24 h et à 0 h.\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Spline cyclique pour modéliser la concentration de dioxyde d'azote](11-GAM_files/figure-html/fig-gam13-1.png){#fig-gam13 fig-align='center' width=70%}\n:::\n:::\n\n\n\n\n### Splines par groupe {#sec-1152}\n\nTel qu'abordé dans les chapitres précédents, il arrive régulièrement que les observations appartiennent à  différents groupes. Dans ce cas de figure, nous pouvons être amenés à vérifier si la relation décrite par une *spline* est identique pour chacun des groupes d'observations. Il s'agit alors d'ajuster une *spline* différente par groupe. Dans l'exemple précédent, chaque valeur de NO~2~ a été mesurée par une station fixe de mesure spécifique. Compte tenu du fait que l'environnement autour de chaque station est particulier, nous pourrions s'attendre à ce que les valeurs de NO~2~ ne présentent pas exactement les mêmes patrons journaliers pour chaque station.\n\nÀ la @fig-gam14, il est possible de constater que le NO~2~ suit globalement le même patron temporel pour l'ensemble des stations à l'exception de trois d'entres-elles. Il s'agit en réalité de stations situées dans des secteurs ruraux de la région parisienne, et donc moins impactées par le trafic routier.\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Spline cyclique variant par groupe](11-GAM_files/figure-html/fig-gam14-1.png){#fig-gam14 fig-align='center' width=70%}\n:::\n:::\n\n\n\n### *Splines* multivariées et *splines* d'interaction {#sec-1153}\n\nJusqu'ici, nous n'avons considéré que des *splines* ne s'appliquant qu'à une seule variable indépendante; cependant, il est possible de construire des *splines* multivariées s'ajustant simultanément sur plusieurs variables indépendantes. L'objectif est alors de modéliser les potentielles interactions non linéaires entre les variables indépendantes combinées dans une même *spline*. Prenons un exemple concret, dans la section sur les modèles GLM, nous avons modélisé la couverture des aires de diffusion (AD) à Montréal par des îlots de chaleur. Parmi les variables indépendantes, nous avons notamment utilisé la distance au centre-ville ainsi que la part de la surface végétalisée des AD. Nous pourrions formuler l'hypothèse que ces deux variables influencent conjointement et de façon non linéaire la proportion de la surface d'îlot de chaleur dans chaque AD. Pour représenter une *spline* sur plusieurs dimensions, nous utilisons alors une carte de chaleur dont la couleur représente la valeur de la variable dépendante prédite en fonction des deux variables indépendantes.\n\nIl est important de distinguer la *spline* d'**interaction** et la *spline* **multivariée**. La première est utilisée lorsque les variables indépendantes introduites dans la *spline* ne sont pas exprimées sur la même échelle et n'évoluent pas conjointement. L'exemple donné ci-dessus avec les variables de végétation et de distance au centre-ville est un exemple de *spline* d'interaction, la première variable étant exprimée en pourcentage et l'autre en mètres. De plus, ces deux variables ne sont pas conjointes, mais bien distinctes l'une de l'autre. Un cas typique où une *spline* multivariée serait à privilégier est le cas de l'ajout des coordonnées spatiales dans le modèle. L'emplacement des AD est mesuré par deux variables (coordonnées spatiales *x* et *y*) toutes les deux exprimées en mètres évoluant conjointement, au sens où les coordonnées *x* n'interagissent pas avec les coordonnées *y*, mais forment à elles deux un espace propre. Au-delà de la problématique de l'échelle des données, il est important de retenir que les *splines* d'interaction tendent à être davantage pénalisées que les splines *multivariées*.\n\nLa *spline* d'interaction représentée à la @fig-gam15 indique que les AD avec la plus grande proportion de leur surface couverte par des îlots de chaleur sont situées à moins de 25 kilomètres du centre-ville, au-delà de cette distance, cette proportion chute en bas de 0,1, soit 10 % de la surface de l'AD. En revanche, à proximité du centre-ville (moins d'un kilomètre), même les AD disposant d'un fort pourcentage de surface végétalisée sont tout de même marquées par un fort pourcentage de surface couverte par des îlots de chaleur.\n\nLes *splines* bivariées sont fréquemment utilisées pour capturer un potentiel patron spatial dans les données. En effet, si nous disposons des coordonnées spatiales de chaque observation (*x, y*), il est possible d'ajuster une *spline* bivariée sur ces coordonnées, contrôlant ainsi l'effet de l'espace. \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Spline d'interaction bivariée](11-GAM_files/figure-html/fig-gam15-1.png){#fig-gam15 fig-align='center' width=70%}\n:::\n:::\n\n\nIl n'y a pas de limite théorique au nombre de variables qui peuvent être ajoutées dans une *spline* d'interaction ou multivariée. Notez cependant que plus le nombre de dimensions augmente, plus la fonction à estimer est complexe et plus le volume de données nécessaire est grand et doit couvrir densément l'ensemble de l'espace d'échantillonnage multidimensionnel.\n\n## Mise en œuvre dans R {#sec-116}\n\nIl est possible d'ajuster des *splines* de régression dans n'importe quel *package* permettant d'ajuster des coefficients pour un modèle de régression. Il suffit de construire les bases des *splines* en amont à l'aide du *package* `splines2` et de les ajouter directement dans l'équation de régression. \nEn revanche, il est nécessaire d'utiliser des *packages* spécialisés pour ajuster des *splines* de lissage. Parmi ceux-ci, `mgcv` est probablement le plus populaire du fait de sa (très) grande flexibilité, suivi des *packages* `gamlss`, `gam` et `VGAM.` Nous comparons ici les deux approches, puis nous tentons d'améliorer le modèle que nous avons ajusté pour prédire le pourcentage de surface couverte par des îlots de chaleur dans les aires de diffusion de Montréal, dans une perspective d'équité environnementale. Pour rappel, la variable dépendante est exprimée en pourcentage et nous utilisons une distribution bêta pour la modéliser.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mgcv)\n# Chargement des données\ndataset <- read.csv(\"data/gam/data_chaleur.csv\", fileEncoding = \"utf8\")\n# Ajustement du modèle de base\nrefmodel <- gam(hot ~\n          A65Pct + A014Pct + PopFRPct + PopMVPct +\n          poly(prt_veg, degree = 2)  + Arrond,\n        data = dataset, family = betar(link = \"logit\"))\n```\n:::\n\n\nDans notre première analyse de ces données, nous avons ajusté une polynomiale d'ordre 2 pour représenter un potentiel effet non linéaire de la végétation sur les îlots de chaleur. Nous remplaçons à présent ce terme par une *spline* de régression en sélectionnant quatre nœuds.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(splines2)\n# Création des bases de la spline\nbasis <- bSpline(x = dataset$prt_veg, df =4, intercept = FALSE)\n# Ajouter les bases au DataFrame\nbasisdf <- as.data.frame(basis)\nnames(basisdf) <- paste('spline',1:ncol(basisdf), sep='')\ndataset <- cbind(dataset, basisdf)\n# Ajuster le modèle\nmodel0 <- gam(hot ~\n          A65Pct + A014Pct + PopFRPct + PopMVPct +\n          spline1 + spline2 + spline3 + spline4 + Arrond,\n        data = dataset, family = betar(link = \"logit\"))\n```\n:::\n\n\nNous pouvons à présent ajuster une *spline* de lissage et laisser `mgcv` déterminer son niveau de complexité.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ajustement du modèle avec une spline simple\nmodel1 <- gam(hot ~\n          A65Pct + A014Pct + PopFRPct + PopMVPct +\n          s(prt_veg)  + Arrond,\n        data = dataset, family = betar(link = \"logit\"))\n```\n:::\n\n\nNotez ici que la syntaxe à employer est très simple, il suffit de spécifier `s(prt_veg)` pour indiquer à la fonction `gam` que vous souhaitez ajuster une *spline* pour la variable `prt_veg`. Nous pouvons à présent comparer l'ajustement des deux modèles en utilisant la mesure de l'AIC.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Comparaison des AIC\nAIC(refmodel, model0, model1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n               df       AIC\nrefmodel 40.00000 -6399.784\nmodel0   42.00000 -6419.630\nmodel1   44.61065 -6417.562\n```\n:::\n:::\n\n\nNous constatons que la valeur de l'AIC du second modèle est plus réduite, indiquant un meilleur ajustement du modèle avec une *spline* de régression. Notons cependant que la différence avec la *spline* de lissage est anecdotique (deux points de l'AIC) et que nous connaissions a priori le bon nombre de nœuds à utiliser. Pour des relations plus complexes, les *splines* de lissage ont tendance à nettement mieux performer. Voyons à présent comment représenter ces trois termes non linéaires.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Création d'un DataFrame de prédiction dans lequel seule\n# la variable prt_veg varie.\ndfpred <- data.frame(\n  prt_veg = seq(min(dataset$prt_veg), max(dataset$prt_veg), 0.5),\n  A65Pct = mean(dataset$A65Pct),\n  A014Pct = mean(dataset$A014Pct),\n  PopFRPct = mean(dataset$PopFRPct),\n  PopMVPct = mean(dataset$PopMVPct),\n  Arrond = \"Verdun\"\n)\n\n# Recréation des bases de la spline de régression\n# pour les nouvelles observations\nnvl_bases <- data.frame(predict(basis, newx = dfpred$prt_veg))\nnames(nvl_bases) <- paste('spline',1:ncol(basisdf), sep='')\ndfpred <- cbind(dfpred, nvl_bases)\n\n# Définition de la fonction inv.logit, soit l'inverse de la fonction \n# de lien du modèle pour retrouver les prédictions dans l'échelle \n# originales des données\ninv.logit <- function(x){exp(x)/(1+exp(x))}\n\n# Utilisation des deux modèles pour effectuer les prédictions\npredref <- predict(refmodel, newdata = dfpred, type = 'link', se.fit = TRUE)\npredmod0 <- predict(model0, newdata = dfpred, type = 'link', se.fit = TRUE)\npredmod1 <- predict(model1, newdata = dfpred, type = 'link', se.fit = TRUE)\n\n# Calcul de la valeur prédite et construction des intervalles de confiance\ndfpred$polypred <- inv.logit(predref$fit)\ndfpred$poly025 <- inv.logit(predref$fit - 1.96 * predref$se.fit)\ndfpred$poly975 <- inv.logit(predref$fit + 1.96 * predref$se.fit)\n\ndfpred$regsplinepred <- inv.logit(predmod0$fit)\ndfpred$regspline025 <- inv.logit(predmod0$fit - 1.96 * predmod0$se.fit)\ndfpred$regspline975 <- inv.logit(predmod0$fit + 1.96 * predmod0$se.fit)\n\ndfpred$splinepred <- inv.logit(predmod1$fit)\ndfpred$spline025 <- inv.logit(predmod1$fit - 1.96 * predmod1$se.fit)\ndfpred$spline975 <- inv.logit(predmod1$fit + 1.96 * predmod1$se.fit)\n\n# Créer un graphique pour afficher les résultats\nggplot(dfpred) + \n  geom_ribbon(aes(x = prt_veg, ymin = poly025, ymax = poly975),\n              alpha = 0.4, color = \"grey\") +\n  geom_ribbon(aes(x = prt_veg, ymin = spline025, ymax = spline975),\n              alpha = 0.4, color = \"grey\") +\n  geom_ribbon(aes(x = prt_veg, ymin = regspline025, ymax = regspline975),\n              alpha = 0.4, color = \"grey\") +\n  geom_line(aes(y = polypred, x = prt_veg, color = \"polynomiale\"),\n            linewidth = 1) + \n  geom_line(aes(y = regsplinepred, x = prt_veg, color = \"spline de régression\"),\n            linewidth = 1)+\n  geom_line(aes(y = splinepred, x = prt_veg, color = \"spline de lissage\"),\n            linewidth = 1)\n```\n\n::: {.cell-output-display}\n![Comparaison d'une spline et d'une polynomiale](11-GAM_files/figure-html/fig-gam16-1.png){#fig-gam16 fig-align='center' width=75%}\n:::\n:::\n\n\nNous constatons que les trois termes renvoient des prédictions très similaires et qu'une légère différence n'est observable que pour les secteurs avec les plus hauts niveaux de végétation (supérieurs à 75 %).\n\nJusqu'ici, nous utilisons l'arrondissement dans lequel est comprise chaque aire de diffusion comme une variable nominale afin de capturer la dimension spatiale du jeu de données. Puisque nous avons abordé la notion de *splines* bivariées, il serait certainement plus efficace d'en construire une à partir des coordonnées géographiques (*x*,*y*) des centroïdes des aires de diffusion. En effet, il est plus probable que la distribution des îlots de chaleur suive un patron spatial continu sur le territoire plutôt que les délimitations arbitraires des arrondissements.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ajustement du modèle avec une spline bivariée pour l'espace\nmodel2 <- gam(hot ~\n          A65Pct + A014Pct + PopFRPct + PopMVPct +\n          s(prt_veg)  + s(X,Y),\n        data = dataset, family = betar(link = \"logit\"))\n```\n:::\n\n\nNotez ici que l'expression `s(X,Y)` permet de créer une *spline* bivariée à partir des coordonnées (*x, y*), soit deux colonnes présentes dans le jeu de données. Ces coordonnées sont exprimées toutes deux en mètres et n'interagissent pas ensemble au sens strict, nous devons donc ajuster une *spline* bivariée. Si vous avez besoin d'ajuster une *spline* d'interaction (notamment quand les variables sont dans des unités différentes), il est nécessaire d'utiliser une autre syntaxe `te(X,Y)` ou `t2(X,Y)` faisant appel à une structure mathématique légèrement différente, soit des *tensor product smooths*.\n\nPuisque notre modèle intègre deux *splines*, nous devons nous assurer que nous n'avons pas de problème de concurvité, ce que nous pouvons faire avec la fonction `concurvity` du *package* `mgcv`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalues <- concurvity(model2, full = FALSE)\n\n# Worst, estimation pessimiste de la concurvité\nround(values$worst,3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           para s(prt_veg) s(X,Y)\npara          1      0.000  0.000\ns(prt_veg)    0      1.000  0.458\ns(X,Y)        0      0.458  1.000\n```\n:::\n\n```{.r .cell-code}\n# Observed, estimation optimiste de la concurvité\nround(values$observed,3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           para s(prt_veg) s(X,Y)\npara          1      0.000  0.000\ns(prt_veg)    0      1.000  0.154\ns(X,Y)        0      0.403  1.000\n```\n:::\n\n```{.r .cell-code}\n# Estimate, estimation entre deux de la concurvité\nround(values$estimate,3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           para s(prt_veg) s(X,Y)\npara          1      0.000  0.000\ns(prt_veg)    0      1.000  0.142\ns(X,Y)        0      0.358  1.000\n```\n:::\n:::\n\n\nNous pouvons ainsi constater des niveaux de concurvité tout à fait acceptables dans notre modèle. Des valeurs supérieures à 0,8 devraient être considérées comme alarmantes, surtout si elles sont reportées pour `observed` et `estimate`.\n\nVoyons désormais, le résumé d'un modèle GAM tel que présenté dans R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(model2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nFamily: Beta regression(15.469) \nLink function: logit \n\nFormula:\nhot ~ A65Pct + A014Pct + PopFRPct + PopMVPct + s(prt_veg) + s(X, \n    Y)\n\nParametric coefficients:\n              Estimate Std. Error z value Pr(>|z|)    \n(Intercept) -0.6050031  0.0645191  -9.377  < 2e-16 ***\nA65Pct       0.0027671  0.0014072   1.966   0.0493 *  \nA014Pct     -0.0019040  0.0027674  -0.688   0.4914    \nPopFRPct     0.0095992  0.0014323   6.702 2.06e-11 ***\nPopMVPct     0.0010113  0.0008159   1.239   0.2152    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nApproximate significance of smooth terms:\n             edf Ref.df Chi.sq p-value    \ns(prt_veg)  6.38  7.565   6731  <2e-16 ***\ns(X,Y)     27.10 28.764   1349  <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nR-sq.(adj) =  0.891   Deviance explained = 90.8%\n-REML = -3234.3  Scale est. = 1         n = 3157\n```\n:::\n:::\n\n\nLa première partie du résumé comprend les résultats pour les effets fixes et linéaires du modèle. Ils s'interprètent comme pour ceux d'un GLM classique. La seconde partie présente les résultats pour les termes non linéaires. La valeur de *p* permet de déterminer si la *spline* a ou non un effet différent de 0. Une valeur non significative indique que la *spline* ne contribue pas au modèle. Les colonnes *edf* et *Ref.df* indiquent la complexité de la *spline* et peuvent être considérées comme une approximation du nombre de nœuds. Dans notre cas, la *spline* spatiale (`s(X,Y)`) est environ 5 fois plus complexe que la *spline* ajustée pour la végétation (`s(prt_veg)`). Cela n'est pas surprenant puisque la dimension spatiale (*spline* bivariée) du phénomène est certainement plus complexe que l’effet de la végétation. Notez ici que des valeurs *edf* et *Ref.df* proches de 1 signaleraient que l'effet d’un prédicteur est essentiellement linéaire et qu'il n'est pas nécessaire de recourir à une *spline* pour cette variable.\n\nLa dernière partie du résumé comprend deux indicateurs de qualité d'ajustement, soit le R^2^ ajusté et la part de la déviance expliquée.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nAIC(refmodel, model1, model2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n               df       AIC\nrefmodel 40.00000 -6399.784\nmodel1   44.61065 -6417.562\nmodel2   40.06053 -6596.884\n```\n:::\n:::\n\n\nNous pouvons constater que le fait d'introduire la *spline* spatiale dans le modèle contribue à réduire encore la valeur de l'AIC, et donc à améliorer le modèle. À ce stade, nous pourrions tenter de forcer la *spline* à être plus complexe en augmentant le nombre de nœuds.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Augmentation de la complexité de la spline spatiale\nmodel3 <- gam(hot ~\n          A65Pct + A014Pct + PopFRPct + PopMVPct +\n          s(prt_veg)  + s(X,Y,k = 40),\n        data = dataset, family = betar(link = \"logit\"))\n\nAIC(refmodel, model1, model2, model3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n               df       AIC\nrefmodel 40.00000 -6399.784\nmodel1   44.61065 -6417.562\nmodel2   40.06053 -6596.884\nmodel3   48.28633 -6639.955\n```\n:::\n:::\n\n\nCela a pour effet d'améliorer de nouveau le modèle. Pour vérifier si l'augmentation du nombre nœuds est judicieuse, il est possible de représenter le résultat des deux *splines* précédentes. Pour ce faire, nous proposons de calculer les valeurs prédites de la *spline* pour chaque localisation dans notre terrain d'étude, en le découpant préalablement en pixels de 100 de côté. Pour cette prédiction, nous maintenons toutes les autres variables à leur moyenne respective afin d'évaluer uniquement l'effet de la *spline* spatiale.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(viridis)\nlibrary(metR) # pour placer des étiquettes sur les isolignes\n\n# Création d'un DataFrame fictif pour les prédictions\ndfpred <- expand.grid(\n  prt_veg =mean(dataset$prt_veg),\n  A65Pct = mean(dataset$A65Pct),\n  A014Pct = mean(dataset$A014Pct),\n  PopFRPct = mean(dataset$PopFRPct),\n  PopMVPct = mean(dataset$PopMVPct),\n  X = seq(min(dataset$X), max(dataset$X),100),\n  Y = seq(min(dataset$Y), max(dataset$Y),100)\n)\n\ndfpred$predicted1 <- predict(model2, newdata = dfpred, type = 'response')\ndfpred$predicted2 <- predict(model3, newdata = dfpred, type = 'response')\n\n# Centrage des prédictions\ndfpred$predicted1 <- dfpred$predicted1 - mean(dfpred$predicted1)\ndfpred$predicted2 <- dfpred$predicted2 - mean(dfpred$predicted2)\n\n# Représentation des splines\nplot1 <- ggplot(dfpred) + \n  geom_raster(aes(x = X, y = Y, fill = predicted1)) + \n  geom_point(aes(x = X, y = Y),\n             size = 0.2, alpha = 0.4,\n             color = \"black\", data = dataset)+\n  geom_contour(aes(x = X, y = Y, z = predicted1), binwidth = 0.1, \n               color = \"white\", linetype = 'dashed') + \n  geom_text_contour(aes(x = X, y = Y, z = predicted1), \n                    color = \"white\", binwidth = 0.1)+\n  scale_fill_viridis() +\n  coord_cartesian() + \n  theme(axis.title= element_blank(),\n        axis.text = element_blank(),\n        axis.ticks =  element_blank()\n        ) + \n  labs(subtitle = \"spline de base\", fill = \"prédictions\")\n\nplot2 <- ggplot(dfpred) + \n  geom_raster(aes(x = X, y = Y, fill = predicted2)) + \n  geom_point(aes(x = X, y = Y),\n             size = 0.2, alpha = 0.4,\n             color = \"black\", data = dataset)+\n  geom_contour(aes(x = X, y = Y, z = predicted2),\n               binwidth = 0.1, color = \"white\", linetype = 'dashed') + \n  geom_text_contour(aes(x = X, y = Y, z = predicted2), color = \"white\", binwidth = 0.1)+\n  scale_fill_viridis() +\n  coord_cartesian()+ \n  theme(axis.title= element_blank(),\n        axis.text = element_blank(),\n        axis.ticks =  element_blank()\n        ) + \n  labs(subtitle = \"spline plus complexe\", fill = \"prédictions\")\n\nggarrange(plot1, plot2, nrow = 1, ncol = 2, common.legend = TRUE, legend = 'bottom')\n```\n\n::: {.cell-output-display}\n![Comparaison de deux splines spatiales](11-GAM_files/figure-html/fig-gam17-1.png){#fig-gam17 fig-align='center' width=100%}\n:::\n:::\n\n\nOr, il s'avère que les deux *splines* spatiales sont très similaires (@fig-gam17). Par conséquent, il est vraisemblablement plus pertinent de conserver la plus simple des deux. Notez que le Mont-Royal, compris dans le cercle central avec une isoligne à 0, est caractérisé par des valeurs plus faibles d'îlots de chaleur, alors que les quartiers centraux situés un peu plus au nord sont au contraire marqués par des pourcentages d'îlots de chaleur supérieurs de 20 points de pourcentage en moyenne.\n\n## GAMM {#sec-117}\n\nBien entendu, il est possible de combiner les modèles généralisés additifs (GAM) avec les modèles à effet mixtes (GLMM) abordés dans les sections précédentes. Ces modèles généralisés additifs à effets mixtes (GAMM) peuvent facilement être mis en œuvre avec `mgcv`.\n\n#### GAMM et interceptes aléatoires {#sec-1171}\n\nPour définir des constantes aléatoires, il suffit d'utiliser la notation `s(var, bs = 're')` avec `var` une variable nominale. Reprenons l'exemple précédent, mais avec cette fois-ci les arrondissements comme un intercepte aléatoire.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndataset$Arrond <- as.factor(dataset$Arrond)\nmodel4 <- gam(hot ~\n          A65Pct + A014Pct + PopFRPct + PopMVPct +\n          s(prt_veg)  + s(Arrond, bs = \"re\"),\n        data = dataset, family = betar(link = \"logit\"))\n```\n:::\n\n\nL'enjeu est ensuite d'extraire la variance propre à cet effet aléatoire ainsi que les valeurs des interceptes pour chaque arrondissement.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngam.vcomp(model4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nStandard deviations and 0.95 confidence intervals:\n\n               std.dev       lower      upper\ns(prt_veg) 0.007047166 0.003785275 0.01311993\ns(Arrond)  0.393539474 0.302707198 0.51162747\n\nRank: 2/2\n```\n:::\n:::\n\n\nNous constatons donc que l'écart-type de l'effet aléatoire des arrondissements est de 0,39, ce qui signifie que les effets de chaque arrondissement seront compris à 95 % entre -1,17 et 1,17 (`1.17 = 3*0.39`) sur l'échelle du prédicteur linéaire. En effet, rappelons que les effets aléatoires sont modélisés comme des distributions normales et que 95 % de la densité d'une distribution normale se situe entre -3 et +3 écarts-types. Pour extraire les interceptes spécifiques de chaque arrondissement, nous pouvons utiliser la fonction `get_random` du *package* `itsadug.`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(itsadug)\nvalues <- get_random(model4)[[1]]\ndf <- data.frame(\n  ri = as.numeric(values),\n  arrond = names(values)\n)\n\nggplot(df) + \n  geom_point(aes(x = ri, y = reorder(arrond, ri))) + \n  geom_vline(xintercept = 0, color = \"red\") + \n  labs(y = \"Arrondissement\", x = \"intercepte aléatoire\")\n```\n\n::: {.cell-output-display}\n![Constantes aléatoires pour les arrondissements](11-GAM_files/figure-html/fig-randomconstGAM-1.png){#fig-randomconstGAM width=672}\n:::\n:::\n\n\nNous constatons ainsi, à la @fig-randomconstGAM, que pour une partie des arrondissements, la densité d'îlot de chaleur est systématiquement supérieure à la moyenne régionale représentée ici par la ligne rouge (0 = effet moyen pour tous les arrondissements). Il convient alors d’améliorer ce graphique en ajoutant le niveau d'incertitude associé à chaque intercepte. Pour ce faire, nous utilisons la fonction `extract_random_effects` du *package* `mixedup.` Notez que ce *package* n'est actuellement pas disponible sur CRAN et doit être téléchargé sur **github** avec la commande suivante :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nremotes::install_github('m-clark/mixedup')\n```\n:::\n\n\nAvec la version 4.0.1 de R, nous avons rencontré des difficultés pour installer `mixedup`. Nous avons donc  simplement récupéré le code source de la fonction et l'avons enregistré dans un fichier de code séparé que nous appelons ici.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(\"code_complementaire/gam_functions.R\")\n```\n:::\n\n\nNous pouvons ensuite procéder à l'extraction des effets aléatoires et les représenter à nouveau (@fig-randomconstGAM2).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_re <- extract_random_effects.gam(model4, re = \"Arrond\")\n\nggplot(df_re) + \n  geom_errorbarh(aes(xmin = lower_2.5, xmax = upper_97.5, y = reorder(group, value))) +\n  geom_point(aes(x = value, y = reorder(group, value))) + \n  geom_vline(xintercept = 0, color = \"red\") + \n  labs(y = \"Arrondissement\", x = \"Intercepte aléatoire\")\n```\n\n::: {.cell-output-display}\n![Constantes aléatoires pour les arrondissements avec intervalle de confiance](11-GAM_files/figure-html/fig-randomconstGAM2-1.png){#fig-randomconstGAM2 width=672}\n:::\n:::\n\n\nCela permet de distinguer quels écarts sont significativement différents de 0 au seuil de 95 %. À titre de rappel, pour être significatif à ce seuil, un intervalle représenté par une ligne noire horizontale ne doit pas intersecter la ligne rouge verticale. Puisque nous utilisons ici la distribution bêta et une fonction de lien logistique, nous devons utiliser des prédictions pour simplifier l'interprétation des coefficients. Nous fixons ici toutes les variables à leur moyenne respective, sauf l'arrondissement, et calculons les prédictions dans l'échelle originale (0 à 1).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndfpred <- data.frame(\n  A65Pct = mean(dataset$A65Pct),\n  A014Pct = mean(dataset$A014Pct),\n  PopFRPct = mean(dataset$PopFRPct),\n  PopMVPct = mean(dataset$PopMVPct),\n  prt_veg = mean(dataset$prt_veg),\n  Arrond = as.character(unique(dataset$Arrond))\n)\n\n# Calculer les prédictions pour le prédicteur linéaire\ndfpred$preds <- predict(model4, newdata = dfpred, type = \"link\")\n\n# Calculer l'intervalle de confiance en utilisant les valeurs\n# extraites avec extract_random_effects\ndfpred <- dfpred[order(dfpred$Arrond),]\ndf_re <- df_re[order(df_re$group),]\n\ndfpred$lower <- dfpred$preds - 1.96*df_re$se\ndfpred$upper <- dfpred$preds + 1.96*df_re$se\n\n# Il nous reste juste à reconvertir le tout dans l'unité d'origine\n# en utilisant l'inverse de la fonction logistique\ninv.logit <- function(x){exp(x)/(1+exp(x))}\n\ndfpred$lower <- inv.logit(dfpred$lower)\ndfpred$upper <- inv.logit(dfpred$upper)\ndfpred$preds <- inv.logit(dfpred$preds)\n\nggplot(dfpred) + \n  geom_errorbarh(aes(xmin = lower, xmax = upper, y = reorder(Arrond, preds))) +\n  geom_point(aes(x = preds, y = reorder(Arrond, preds))) + \n  geom_vline(xintercept = mean(dfpred$preds), color = \"red\") + \n  labs(y = \"Arrondissement\", x = \"intercepte aléatoire\")\n```\n\n::: {.cell-output-display}\n![Prédictions pour les différents arrondissements pour une AD fictive moyenne](11-GAM_files/figure-html/fig-randomconstGAM3-1.png){#fig-randomconstGAM3 width=672}\n:::\n:::\n\n\nNous constatons ainsi, à la @fig-randomconstGAM3, que pour une hypothétique aire de diffusion moyenne, la différence de densité d'îlot de chaleur peut être de 0,32 (32 % de la surface de l'AD) entre les arrondissements Verdun et Dollard-des-Ormeaux.\n\n#### GAMM et coefficients aléatoires {#sec-1172}\n\nEn plus des interceptes aléatoires, il est aussi possible de définir des coefficients aléatoires. Reprenons notre exemple et tentons de faire varier l'effet de la variable `PopFRPct` en fonction de l'arrondissement.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel5 <- gam(hot ~\n          A65Pct + A014Pct + PopFRPct + PopMVPct +\n          s(prt_veg)  + s(Arrond, bs = \"re\") + \n          s(PopFRPct, Arrond, bs = \"re\"),\n        data = dataset, family = betar(link = \"logit\"))\n```\n:::\n\n\nNotez ici une distinction importante! Le modèle n'assume aucune corrélation entre les coefficients aléatoires pour la variable `PopFRPct` et pour les constantes aléatoires. Il est présumé que ces deux effets proviennent de deux distributions normales distinctes. En d'autres termes, le modèle ne dispose pas des paramètres nécessaires pour vérifier si les arrondissements avec les constantes les plus fortes (avec des densités supérieures d'îlot de chaleur) sont aussi des arrondissements dans lesquels l'effet de la variable `PopFRPct` est plus prononcé (et vice-versa). Pour plus d'informations sur cette distinction, référez-vous à la [section @sec-0924].\n\n\n::: {.cell}\n\n```{.r .cell-code}\nAIC(model4, model5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             df       AIC\nmodel4 41.54635 -6421.791\nmodel5 56.84734 -6466.726\n```\n:::\n:::\n\n\nCe dernier modèle présente une valeur de l'AIC plus faible et serait donc ainsi mieux ajusté que notre modèle avec seulement un intercepte aléatoire. Nous pouvons donc extraire les coefficients aléatoires et les représenter à la @fig-randomconstcoefGAM.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_re <- extract_random_effects.gam(model5)\ndf_re <- subset(df_re, df_re$effect == 'PopFRPct')\n\nggplot(df_re) + \n  geom_errorbarh(aes(xmin = lower_2.5, xmax = upper_97.5, y = reorder(group, value))) +\n  geom_point(aes(x = value, y = reorder(group, value))) + \n  geom_vline(xintercept = 0, color = \"red\") + \n  labs(y = \"Arrondissement\", x = \"coefficient aléatoire\")\n```\n\n::: {.cell-output-display}\n![Pentes et constantes aléatoires pour les arrondissements](11-GAM_files/figure-html/fig-randomconstcoefGAM-1.png){#fig-randomconstcoefGAM width=672}\n:::\n:::\n\n\nNous constatons notamment que seuls trois arrondissements ont des coefficients aléatoires significativement différents de 0. Ainsi, pour les arrondissements Anjou et Plateau-Mont-Royal, les coefficients aléatoires sont respectivement de -0,013 et -0,015, et viennent donc se retrancher à la valeur moyenne régionale de 0,0154 qui atteint alors presque 0. Du point de vue de l'interprétation, nous pouvons en conclure que le groupe des personnes à faible revenu ne subit pas de surexposition aux îlots de chaleur à l'échelle des AD dans ces arrondissements.\n\nEn revanche, dans l'arrondissement Mercier-Hochelaga-Maisonneuve, la situation est à l'inverse plus systématiquement en défaveur des populations à faible revenu, avec une taille d'effet près de deux fois supérieure à la moyenne régionale. En effet, l'effet moyen régional (coefficient fixe) est de 0,0154, auquel vient s'ajouter l'effet spécifique (coefficient aléatoire) de Mercier-Hochelaga-Maisonneuve, soit 0,011, pour un effet total de 0,0264\n\n::: bloc_aller_loin\n::: bloc_aller_loin-header\n::: bloc_aller_loin-icon\n:::\n**Des effets aléatoires plus complexes dans les GAMM**\n:::\n::: bloc_aller_loin-body\nIl est possible de spécifier des GAMM avec des effets aléatoires plus complexes autorisant, par exemple, des corrélations entre les différents effets / niveaux. Il faut pour cela utiliser la fonction `gamm` de `mgcv` ou la fonction `gamm4` du *package* `gamm4.` La première offre plus de flexibilité, mais la seconde est plus facile à utiliser et doit être privilégiée quand un modèle comporte un très grand nombre de groupes dans un effet aléatoire, ou lorsque la distribution du modèle n'est pas gaussienne. La fonction `gamm` permet d'ajuster des modèles non gaussiens, mais elle utilise une approche appelée PQL (*Penalized Quasi-Likelihood* en anglais) connue pour être moins stable et moins précise.\n\nCependant, dans l'exemple de cette section, nous utilisons un modèle GAMM avec une distribution bêta, ce qui n'est actuellement pas supporté par les fonctions `gamm` et `gamm4`. Pour un modèle GAMM plus complexe utilisant une distribution bêta, il est nécessaire d'utiliser le *package* `gamlss`, mais ce dernier utilise aussi une approche de type PQL. Nous montrons tout de même ici comment ajouter un modèle qui inclut une corrélation entre les deux effets aléatoires de l'exemple précédent. Notez ici que le terme `re` apparaissant dans la formule permet de spécifier un effet aléatoire en utilisant la syntaxe du *package* `nlme.` Plus spécifiquement, `gamlss` fait un pont avec `nlme` et utilise son algorithme d'ajustement au sein de ces propres routines. De même, le terme `pb` permet de spécifier une *spline* de lissage dans le même esprit que `mgcv.` Il est également possible d'utiliser le terme `ga` faisant le lien avec `mgcv` et de profiter de sa flexibilité dans `gamlss`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gamlss)\nlibrary(gamlss.add)\n\nmodel6 <- gamlss(hot ~\n          pb(prt_veg) + \n          re(fixed = ~ A65Pct + A014Pct + PopFRPct + PopMVPct, \n             random = ~(1 + PopFRPct)|Arrond),\n        data = dataset, family = BE(mu.link = \"logit\"))\n```\n:::\n\n\nNous pouvons ensuite accéder à la partie du modèle qui nous intéresse, soit celle concernant les effets aléatoires.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrandomPart <- model6$mu.coefSmo[[2]]\nprint(randomPart)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLinear mixed-effects model fit by maximum likelihood\n  Data: Data \n  Log-likelihood: -2964.494\n  Fixed: fix.formula \n (Intercept)       A65Pct      A014Pct     PopFRPct     PopMVPct \n-0.060862840 -0.001945204 -0.010139278  0.017259606 -0.002599745 \n\nRandom effects:\n Formula: ~(1 + PopFRPct) | Arrond\n Structure: General positive-definite, Log-Cholesky parametrization\n            StdDev     Corr  \n(Intercept) 0.47298363 (Intr)\nPopFRPct    0.01078909 -0.646\nResidual    0.99888012       \n\nVariance function:\n Structure: fixed weights\n Formula: ~W.var \nNumber of Observations: 3157\nNumber of Groups: 33 \n```\n:::\n:::\n\n\n\nÀ lecture de la partie du résumé consacrée aux résultats pour les effets aléatoires, nous constatons que la corrélation entre les interceptes aléatoires et les coefficients aléatoires est de -0,65. Cela signifie que pour les arrondissements avec des interceptes élevés (plus grande proportion d'îlots de chaleur), l'effet de la variable `PopFRPct` tend à être plus faible. Autrement dit, dans les arrondissements avec beaucoup d'îlots de chaleur, les personnes à faible revenu ont tendance à être moins exposées, tel qu'illustré à la @fig-corrrandom).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndf <- ranef(randomPart)\ndf$arrond <- rownames(df)\nnames(df) <- c('Intercept', 'PopFRPct', 'Arrondissement')\n\nggplot(df) + \n  geom_hline(yintercept = 0, color = \"red\") +\n  geom_vline(xintercept = 0, color = \"red\") +\n  geom_point(aes(x = Intercept, y = PopFRPct))\n```\n\n::: {.cell-output-display}\n![Relation entre les effets aléatoires des arrondissements et la variable population à faible revenu](11-GAM_files/figure-html/fig-corrrandom-1.png){#fig-corrrandom fig-align='center' width=75%}\n:::\n:::\n\n:::\n:::\n\n## Quiz de révision du chapitre {#sec-118}\n\n\n<div id=\"quizz_gam\" class=\"card\">\n<link type=\"text/javascript\" src=\"libs/quizlib.1.0.1.min.js\"/>\n<script>var Quiz=function(a,b){this.Classes=Object.freeze({QUESTION:\"quizlib-question\",QUESTION_TITLE:\"quizlib-question-title\",QUESTION_ANSWERS:\"quizlib-question-answers\",QUESTION_WARNING:\"quizlib-question-warning\",CORRECT:\"quizlib-correct\",INCORRECT:\"quizlib-incorrect\",TEMP:\"quizlib-temp\"}),this.unansweredQuestionText=\"Question sans réponse !\",this.container=document.getElementById(a),this.questions=[],this.result=new QuizResult,this.answers=b;for(var c=0;c<this.container.children.length;c++)this.container.children[c].classList.contains(Quiz.Classes.QUESTION)&&this.questions.push(this.container.children[c]);if(this.answers.length!=this.questions.length)throw new Error(\"Number of answers does not match number of questions!\")};Quiz.Classes=Object.freeze({QUESTION:\"quizlib-question\",QUESTION_TITLE:\"quizlib-question-title\",QUESTION_ANSWERS:\"quizlib-question-answers\",QUESTION_WARNING:\"quizlib-question-warning\",CORRECT:\"quizlib-correct\",INCORRECT:\"quizlib-incorrect\",TEMP:\"quizlib-temp\"}),Quiz.prototype.checkAnswers=function(a){void 0===a&&(a=!0);for(var b=[],c=[],d=0;d<this.questions.length;d++){var e=this.questions[d],f=this.answers[d],g=[];this.clearHighlights(e);for(var h,i=e.getElementsByClassName(Quiz.Classes.QUESTION_ANSWERS)[0].getElementsByTagName(\"input\"),j=0;j<i.length;j++)h=i[j],\"checkbox\"===h.type||\"radio\"===h.type?h.checked&&g.push(h.value):\"\"!==h.value&&g.push(h.value);1!=g.length||Array.isArray(f)?0===g.length&&b.push(e):g=g[0],c.push(Utils.compare(g,f))}if(0===b.length||!a)return this.result.setResults(c),!0;for(d=0;d<b.length;d++){var k=document.createElement(\"span\");k.appendChild(document.createTextNode(this.unansweredQuestionText)),k.className=Quiz.Classes.QUESTION_WARNING,b[d].getElementsByClassName(Quiz.Classes.QUESTION_TITLE)[0].appendChild(k)}return!1},Quiz.prototype.clearHighlights=function(a){for(var b=a.getElementsByClassName(Quiz.Classes.QUESTION_WARNING);b.length>0;)b[0].parentNode.removeChild(b[0]);var c,d=[a.getElementsByClassName(Quiz.Classes.CORRECT),a.getElementsByClassName(this.Classes.INCORRECT)];for(i=0;i<d.length;i++)for(;d[i].length>0;)c=d[i][0],c.classList.remove(Quiz.Classes.CORRECT),c.classList.remove(Quiz.Classes.INCORRECT);for(var e=a.getElementsByClassName(Quiz.Classes.TEMP);e.length>0;)e[0].parentNode.removeChild(e[0])},Quiz.prototype.highlightResults=function(a){for(var b,c=0;c<this.questions.length;c++)b=this.questions[c],b.getElementsByClassName(Quiz.Classes.QUESTION_TITLE)[0].classList.add(this.result.results[c]?Quiz.Classes.CORRECT:Quiz.Classes.INCORRECT),void 0!==a&&a(this,b,c,this.result.results[c])};var QuizResult=function(){this.results=[],this.totalQuestions=0,this.score=0,this.scorePercent=0,this.scorePercentFormatted=0};QuizResult.prototype.setResults=function(a){this.results=a,this.totalQuestions=this.results.length,this.score=0;for(var b=0;b<this.results.length;b++)this.results[b]&&this.score++;this.scorePercent=this.score/this.totalQuestions,this.scorePercentFormatted=Math.floor(100*this.scorePercent)};var Utils=function(){};Utils.compare=function(a,b){if(a.length!=b.length)return!1;if(Array.isArray(a)&&Array.isArray(b)){for(var c=0;c<a.length;c++)if(a[c]!==b[c])return!1;return!0}return a===b};\n\nfunction showResults(quiz) {\n    // Check answers and continue if all questions have been answered\n    if (quiz.checkAnswers()) {\n        var quizScorePercent = quiz.result.scorePercentFormatted; // The unformatted percentage is a decimal in range 0 - 1\n        var quizResultElement = document.getElementById('quiz-result');\n        quizResultElement.style.display = 'block';\n        document.getElementById('quiz-percent').innerHTML = quizScorePercent.toString();\n\n        // Change background colour of results div according to score percent\n        if (quizScorePercent > 75) quizResultElement.style.backgroundColor = '#4caf50';\n        else if (quizScorePercent > 50) quizResultElement.style.backgroundColor = '#ffc107';\n        else if (quizScorePercent > 25) quizResultElement.style.backgroundColor = '#ff9800';\n        else if (quizScorePercent > 0) quizResultElement.style.backgroundColor = '#f44336';\n\n        // Highlight questions according to whether they were correctly answered. The callback allows us to highlight/show the correct answer\n        quiz.highlightResults(handleAnswers);\n    }\n}\n\n/** Callback for Quiz.highlightResults. Highlights the correct answers of incorrectly answered questions\n * Parameters are: the quiz object, the question element, question number, correctly answered flag\n */\nfunction handleAnswers(quiz, question, no, correct) {\n    if (!correct) {\n        var answers = question.getElementsByTagName('input');\n        for (var i = 0; i < answers.length; i++) {\n            if (answers[i].type === 'checkbox' || answers[i].type === 'radio'){\n                // If the current input element is part of the correct answer, highlight it\n                if (quiz.answers[no].indexOf(answers[i].value) > -1) {\n                    answers[i].parentNode.classList.add(Quiz.Classes.CORRECT);\n                }\n            } else {\n                // If the input is anything other than a checkbox or radio button, show the correct answer next to the element\n                var correctAnswer = document.createElement('span');\n                correctAnswer.classList.add(Quiz.Classes.CORRECT);\n                correctAnswer.classList.add(Quiz.Classes.TEMP); // quiz.checkAnswers will automatically remove elements with the temp class\n                correctAnswer.innerHTML = quiz.answers[no];\n                correctAnswer.style.marginLeft = '10px';\n                answers[i].parentNode.insertBefore(correctAnswer, answers[i].nextSibling);\n            }\n        }\n    }\n}\n\n  var quizz_quizz_gam;\n  window.onload = function() {\n    quizz_quizz_gam = new Quiz('quizz_gam', ['2','3','3','1',['1', '2', '3'],'2','1',['1', '3']]);\n  };</script>\n<link rel=\"stylesheet\" type=\"text/css\" src=\"css/quizlib.min.css\"/>\n<div class=\"card quizlib-question\">\n<div class=\"quizlib-question-title\">Que signifie l'acronyme GAM?</div>\n<div>Relisez l'introduction du [chapitre @sec-chap11] au besoin.</div>\n<div class=\"quizlib-question-answers\">\n<table class=\"table table-sm table-striped small\">\n<tr>\n<td>\n<label>Gaussian Asymetric Model</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q1\" value=\"1\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>Generalized Additive Model</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q1\" value=\"2\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>Gaussian Asynchronus Model</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q1\" value=\"3\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>Generalized Asymetric Model</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q1\" value=\"4\"/>\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"card quizlib-question\">\n<div class=\"quizlib-question-title\">Quel est l'intérêt d'un modèle GAM comparativement à un modèle GLM?</div>\n<div>Relisez au besoin la [section @sec-111].</div>\n<div class=\"quizlib-question-answers\">\n<table class=\"table table-sm table-striped small\">\n<tr>\n<td>\n<label>La possibilité d'ajuster n'importe quelle distribution dans le modèle</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q2\" value=\"1\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>La possibilité de tenir compte de structures de corrélation entre les observations</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q2\" value=\"2\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>L'ajout de termes nonlinéaires pour les prédicteurs</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q2\" value=\"3\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>La transformation de la variable Y pour quelle se rapproche d'une distribution normale</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q2\" value=\"4\"/>\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"card quizlib-question\">\n<div class=\"quizlib-question-title\">Une spline ajustée sur une variable X dans un GAM est construite comme : </div>\n<div>Relisez au besoin la [section @sec-1114].</div>\n<div class=\"quizlib-question-answers\">\n<table class=\"table table-sm table-striped small\">\n<tr>\n<td>\n<label>un ensemble de coefficients ajustés à différentes sections de la variable X identifiées par des points de ruptures</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q3\" value=\"1\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>la somme d'un ensemble de polynomiales de X multipliées par des coefficients ajustés par le modèle</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q3\" value=\"2\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>la somme d'un ensemble de fonctions de base appliquées à X et multipliées par des coefficients ajustés par le modèle</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q3\" value=\"3\"/>\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"card quizlib-question\">\n<div class=\"quizlib-question-title\">Le degré de complexité d'une spline est contrôlé par : </div>\n<div>Relisez au besoin la [section @sec-1114].</div>\n<div class=\"quizlib-question-answers\">\n<table class=\"table table-sm table-striped small\">\n<tr>\n<td>\n<label>le nombre de nœuds de la spline</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q4\" value=\"1\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>le nombre de variables X sur lesquelles la spline est ajustée</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q4\" value=\"2\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>le type de fonction de base de la spline</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q4\" value=\"3\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>la distribution du modèle</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q4\" value=\"4\"/>\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"card quizlib-question\">\n<div class=\"quizlib-question-title\">Le nombre de nœuds d'une spline peut être : </div>\n<div>Relisez au besoin la [section @sec-113].</div>\n<div class=\"quizlib-question-answers\">\n<table class=\"table table-sm table-striped small\">\n<tr>\n<td>\n<label>défini manuellement, nous parlons alors de spline de régression</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q5\" value=\"1\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>déterminé par une approche automatique appelée pénalisation de la vraisemblance, nous parlons alors de spline de lissage</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q5\" value=\"2\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>déterminé automatiquement en reparamétrisant la spline comme un effet aléatoire, nous parlons alors de spline de lissage</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q5\" value=\"3\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>déterminé de façon itérative en ajoutant un nœud à chaque fois et en comparant le R2 de Nagelkerke</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q5\" value=\"4\"/>\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"card quizlib-question\">\n<div class=\"quizlib-question-title\">Une spline bivariée est un autre nom pour une spline d'interaction.</div>\n<div>Relisez au besoin la [section @sec-115].</div>\n<div class=\"quizlib-question-answers\">\n<table class=\"table table-sm table-striped small\">\n<tr>\n<td>\n<label>Vrai</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q6\" value=\"1\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>Faux</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q6\" value=\"2\"/>\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"card quizlib-question\">\n<div class=\"quizlib-question-title\">Une spline peut être ajustée sur plus que deux variables X simultanément.</div>\n<div>Relisez au besoin la [section @sec-115].</div>\n<div class=\"quizlib-question-answers\">\n<table class=\"table table-sm table-striped small\">\n<tr>\n<td>\n<label>Vrai</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q7\" value=\"1\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>Faux</label>\n</td>\n<td>\n<input type=\"radio\" name=\"q7\" value=\"2\"/>\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"card quizlib-question\">\n<div class=\"quizlib-question-title\">Pour interpréter les résultats d'une spline, il est possible de : </div>\n<div>Relisez au besoin la [section @sec-114].</div>\n<div class=\"quizlib-question-answers\">\n<table class=\"table table-sm table-striped small\">\n<tr>\n<td>\n<label>observer le nombre de degrés de liberté (estimated degree of freedom) de cette dernière pour se faire une idée de son degré de complexité</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q8\" value=\"1\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>représenter graphiquement les fonctions de base utilisées par la spline</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q8\" value=\"2\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>représenter les prédictions du modèle \"toutes choses égales par ailleurs\" afin d'obtenir les effets marginaux des termes non linéaires</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q8\" value=\"3\"/>\n</td>\n</tr>\n<tr>\n<td>\n<label>extraire les coefficients de la spline et les interpréter de façon classique</label>\n</td>\n<td>\n<input type=\"checkbox\" name=\"q8\" value=\"4\"/>\n</td>\n</tr>\n</table>\n</div>\n</div>\n<button type=\"button\" onclick=\"showResults(quizz_quizz_gam);\" id=\"buttonID\">Vérifier votre résultat</button>\n<div id=\"quiz-result\" class=\"card\">\n<span id=\"quiz-percent\"></span>\n</div>\n</div>\n",
    "supporting": [
      "11-GAM_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}