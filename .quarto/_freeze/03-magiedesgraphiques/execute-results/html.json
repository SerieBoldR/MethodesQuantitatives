{
  "hash": "a01efd9a0d5a071a4916a4cef9a0e2ff",
  "result": {
    "markdown": "# Magie des graphiques {#sec-chap03}\n\nDans ce chapitre, nous découvrons les incroyables capacités graphiques de R. Pour ce faire, nous couvrons en profondeur les fonctionnalités du *package* `ggplot2` du `tidyverse`. Selon nous, il s'agit de loin du meilleur *package* pour réaliser des graphiques.\n\n::: bloc_package\n::: bloc_package-header\n::: bloc_package-icon\n:::\n**Liste des *packages* utilisés dans ce chapitre**\n:::\n::: bloc_package-body\n\n* Pour créer des graphiques :\n  - `ggplot2`, le seul, l'unique!\n  - `ggpubr` pour combiner des graphiques.\n  - `ggthemes` pour utiliser des thèmes complémentaires pour les graphiques. \n* Pour les couleurs : \n  - `RColorBrewer` pour accéder à des palettes de couleurs.\n* Pour les graphiques spéciaux : \n  - `chorddiag` pour construire des graphiques d'accord.\n  - `fmsb` pour construire des graphiques en radar.\n  - `treemap` pour construire une carte proportionnelle.\n  - `wordcloud2` et `textrank` pour construire un nuage de mots.\n* Pour les cartes : \n  - `classInt` pour calculer les intervalles des classes.\n  - `ggspatial` pour afficher une échelle avec `ggplot2`.\n  - `tmap` pour la cartographie.\n* Autres *packages* : \n  - `dplyr` et `reshape2` pour manipuler des données.\n  - `pdftools` pour extraire les textes des fichiers *pdf*.\n  - `udpipe` pour obtenir des dictionnaires linguistiques.\n  - `sf` pour manipuler des *simple feature collections*.\n:::\n:::\n\n::: bloc_notes\n::: bloc_notes-header\n::: bloc_notes-icon\n:::\n**Qu'est-ce que la visualisation de données?**\n:::\n::: bloc_notes-body\nLa représentation visuelle de données consiste à transposer des informations en une représentation graphique facilitant la lecture de ces dernières. Il s'agit autant d'un ensemble de méthodes, d'un art que d'un moyen de communication. Voici deux exemples marquants avant de détailler ce propos.\n\nLa première illustration permet de visualiser le volume de plastique que représente la consommation d'eau en bouteille : 480 milliards de bouteilles vendues en 10 ans! Ce chiffre astronomique est inimaginable. En revanche, une [montagne de plastique](https://graphics.reuters.com/ENVIRONMENT-PLASTIC/0100B275155/index.html){target='_blank'} de 2400 mètres surplombant Manhattan marque davantage les esprits.\n\nLe [second graphique](https://www.maplecroft.com/insights/analysis/84-of-worlds-fastest-growing-cities-face-extreme-climate-change-risks/){target='_blank'} représente quatre informations pour 234 villes à travers le monde : \n\n* la croissance démographique (axe des abscisses),\n\n* la vulnérabilité au changement climatique (axe des ordonnées),\n\n* la taille des villes (taille des cercles),\n\n* le continent sur lequel est localisée chaque ville (couleur des cercles).\n\nLe graphique est à la fois très accrocheur et esthétique. En un coup d'œil, nous constatons que les villes avec une forte croissance démographique sont aussi les plus vénérables (lecture des deux axes) et qu'elles sont surtout localisées en Afrique et secondairement en Asie (en rouge et orange), quelle que soit leur taille (taille du cercle). À l'inverse, les villes européennes et américaines (en bleu) sont beaucoup moins vulnérables aux changements climatiques et une croissance démographique plus faible, qu'elles soient de petites, de moyennes ou de grandes villes.\n\nSouvent négligée, la visualisation de données est perçue comme une tâche triviale : il s'agit simplement de représenter une donnée sous forme d'un graphique, car c'est l'option la plus pratique ou qui prend le moins d'espace. Pourtant, les avantages de la visualisation des données sont nombreux. Par exemple, la visualisation de données intègre aujourd'hui des supports dynamiques comme des animations, des figures interactives ou des applications web. R offre d'ailleurs des possibilités très intéressantes en la matière avec des *packages* comme `shiny`, `plotly` ou `leaflet`. Toutefois, nous ne couvrons pas ici ces méthodes plus récentes en visualisation des données qui devraient faire l'objet d'un autre livre.\n\n**Les principaux avantages de la visualisation des données** : \n\n* **Analyse exploratoire des données** (*exploratory data analysis - EDA* en anglais). Visualiser des données est crucial pour détecter des problèmes en tout genre (données manquantes, valeurs extrêmes ou aberrantes, non-respect de conditions d'application de tests statistiques, etc.), mais aussi pour repérer de nouvelles associations entre les variables.\n\n* **Communication de vos résultats**. La raison d'être d'un graphique est de livrer un message clair relatif à un résultat obtenu suite à une analyse rigoureuse de vos données. Si votre graphique n'apporte aucune information claire, il vaut mieux ne pas le présenter, ni le diffuser. Les représentations ne sont pas neutres. Les couleurs et les formes ont des significations particulières en fonction de la culture et du contexte. Posez-vous donc toujours la question : à quel public est destiné le message? Évitez de surcharger vos visualisations de données, sinon l'essence du message sera perdue.\n\n* **Aide à la décision**. Une illustration (graphique ou carte) peut être un outil facilitant la prise de décisions. \n:::\n:::\n\n## Philosophie du ggplot2 {#sec-031}\n\nLe *package* `ggplot2` fait partie du `tidyverse` et dispose d'une logique de fonctionnement particulière. Cette dernière se nomme *The Grammar of Graphics* (les deux G sont d'ailleurs à l'origine du nom `ggplot2`), proposée par Hadley Wickham (le créateur du `tidyverse`!) dans un article intitulé *A layered grammar of graphics* [@wickham2010layered]. Nous proposons de synthétiser ici les concepts et principes centraux qui sous-tendent la production de graphiques avec `ggplot2`.\n\n### Grammaire {#sec-0311}\n\nHadley Wickham propose une grammaire pour unifier la création de graphiques. L'idée est donc de dépasser les simples dénominations comme un nuage de points, un diagramme en boîte, un graphique en ligne, etc., pour comprendre ce qui relie tous ces graphiques. Ces éléments communs et centraux sont les géométries, les échelles et systèmes de coordonnées, et les annotations (@fig-fig30) : \n\n![Trois composantes d'un graphique, adapté de @wickham2010layered](images/Chap03/composantes.png){#fig-fig30 width=\"70%\" fig-align=\"center\"}\n\n* Les **géométries** sont les formes utilisées pour représenter les données. Il peut s'agir de points, de lignes, de cercles, de rectangles, d'arcs de cercle, etc. \n\n* Les **échelles et systèmes de coordonnées** permettent de contrôler la localisation des éléments dans un graphique en convertissant les données depuis leur échelle originale (dollars, kilomètres, pourcentages, etc.) vers l'échelle du graphique (pixels).\n\n* Les **annotations** recoupent l'ensemble des informations complémentaires ajoutées au graphique comme son titre et sous-titre, la source des données, la mention sur les droits d'auteurs, etc.\n\nEn plus de ces trois éléments, il est bien sûr nécessaire de disposer de **données**. Ces dernières sont assignées à des dimensions du graphique pour être représentées (notamment les axes *X* et *Y* et la couleur). Cette étape est appelée **aesthetics mapping** dans `ggplot2`.\n\nLorsque nous combinons des données, leur assignation a des dimensions, un type de géométries, des échelles et un système de coordonnées, nous obtenons un **calque** (*layer* en anglais). Un graphique peut comprendre plusieurs calques comme nous le verrons dans les prochaines sections.\n\nPrenons un premier exemple très simple et construisons un nuage de points à partir du jeu de données *iris* fourni de base dans R. Nous représentons la relation qui existe entre la longueur et la largeur des sépales de ces fleurs. Pour commencer, nous devons charger le *package* `ggplot2` et instancier un graphique avec la fonction `ggplot`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(ggplot2)\ndata(iris)\nnames(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Sepal.Length\" \"Sepal.Width\"  \"Petal.Length\" \"Petal.Width\"  \"Species\"     \n```\n:::\n\n```{.r .cell-code}\nggplot()\n```\n\n::: {.cell-output-display}\n![Base d'un graphique](03-magiedesgraphiques_files/figure-html/fig-fig31-1.png){#fig-fig31 fig-align='center' width=65%}\n:::\n:::\n\n\nPour le moment, le graphique est vide (@fig-fig31). La seconde étape consiste à lui ajouter des données (au travers du paramètre `data`) et à définir les dimensions à associer aux données (avec le paramètre `mapping` et la fonction `aes()`). Dans notre cas, nous voulons utiliser les coordonnées *X* pour représenter la largeur des sépales, et les coordonnées *Y* pour représenter la longueur des sépales. Enfin, nous souhaitons représenter les observations par des points, nous utiliserons donc la géométrie `geom_point`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![Ajout des dimensions au graphique](03-magiedesgraphiques_files/figure-html/fig-fig32-1.png){#fig-fig32 fig-align='center' width=65%}\n:::\n:::\n\n\nCe graphique ne comprend qu'un seul calque avec une géométrie de type point (@fig-fig32). Chaque calque est ajouté avec l'opérateur `+` qui permet de superposer des calques, le dernier apparaissant au-dessus des autres. Les arguments `mapping` et `data` sont définis ici dans la fonction `ggplot` et sont donc appliqués à tous les calques qui composent le graphique. Il est aussi possible de définir `mapping` et `data` au sein des fonctions des géométries : \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() +\n  geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris)\n```\n\n::: {.cell-output-display}\n![Autre spécification des arguments mapping et data](03-magiedesgraphiques_files/figure-html/fig-fig33-1.png){#fig-fig33 fig-align='center' width=65%}\n:::\n:::\n\n\nLa troisième étape consiste à ajouter au graphique des annotations. Pour notre cas, il faudrait ajouter un titre, un sous-titre et des intitulés plus clairs pour les axes *X* et *Y*, ce qu'il est possible de faire avec la fonction `labs` (@fig-fig34).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() +\n  geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris) +\n  labs(title = \"Morphologie des sépales des iris\", subtitle = \"n = 150\",\n       x = \"Longueur des sépales\", \n       y = \"Largeur des sépales\")\n```\n\n::: {.cell-output-display}\n![Ajout de titres](03-magiedesgraphiques_files/figure-html/fig-fig34-1.png){#fig-fig34 fig-align='center' width=65%}\n:::\n:::\n\n\n### Types de géométries {#sec-0312}\n\nLe *package* `ggplot2` permet d'utiliser un très grand nombre de géométries différentes. Dans le @tbl-geometries, nous avons reporté les principales géométries disponibles afin que vous puissiez vous faire une idée du « bestiaire » existant. Il ne s'agit que d'un extrait des principales fonctions. Sachez qu'il existe aussi des *packages* proposant des géométries supplémentaires pour compléter `ggplot2`.\n\n\n::: {#tbl-geometries .cell tbl-cap='Principales géométries proposées par `ggplot2`'}\n::: {.cell-output-display}\n|Géométrie          |Fonction         |\n|:------------------|:----------------|\n|Point              |`geom_point`     |\n|Ligne              |`geom_line`      |\n|Chemin             |`geom_path`      |\n|Boîte à moustaches |`geom_boxplot`   |\n|Diagramme violon   |`geom_violin`    |\n|Histogramme        |`geom_histogram` |\n|Barre              |`geom_bar`       |\n|Densité            |`geom_density`   |\n|Texte              |`geom_label`     |\n|Barre d'erreur     |`geom_errorbar`  |\n|Surface            |`geom_ribbon`    |\n:::\n:::\n\n\n\n### Habillage {#sec-0313}\n\nDans le premier exemple, nous avons montré comment ajouter le titre, le sous-titre et les titres des axes sur un graphique. Il est aussi possible d'ajouter du texte sous le graphique (généralement la source des données avec l'argument `caption`) et des annotations textuelles (`annotate`). Pour ces dernières, il convient de spécifier leur localisation (coordonnées `x` et `y`) et le texte à intégrer (`label`); elles sont ensuite ajoutées au graphique avec l'opérateur `+`. Ajoutons deux annotations pour identifier deux fleurs spécifiques.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() +\n  geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris) +\n  labs(title = \"Morphologie des sépales des iris\", subtitle = \"n = 150\",\n       x = \"Longueur des sépales\", \n       y = \"Largeur des sépales\",\n       caption = \"Source : jeu de données iris\") +\n  annotate(\"text\", x = 6.7, y = 2.5, # position de la note\n           label = \"une virginica\",  # texte de la note\n           hjust = \"left\", vjust = \"top\", # ajustement\n           size = 3, fontface = \"italic\") + \n  annotate(\"text\", x = 5.7, y = 4.4, # position de la note\n           label = \"une setosa\",  # texte de la note\n           hjust = \"left\", vjust = \"top\", # ajustement\n           size = 3, fontface = \"italic\") \n```\n\n::: {.cell-output-display}\n![Ajout d'annotations textuelles](03-magiedesgraphiques_files/figure-html/fig-fig35-1.png){#fig-fig35 fig-align='center' width=65%}\n:::\n:::\n\n\nComme vous pouvez le constater, de nombreux paramètres permettent de contrôler le style des annotations. Pour avoir la liste des arguments disponibles, n'hésitez pas à afficher l'aide de la fonction : `help(annotate)`.\n\nEn plus des annotations de type texte, il est possible d'ajouter des annotations de type géométrique. Nous pourrions ainsi délimiter une boîte encadrant les fleurs de l'espère setosa.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetosas <- subset(iris, iris$Species == \"setosa\")\nsepal.length_extent <- c(min(setosas$Sepal.Length), max(setosas$Sepal.Length))\nsepal.width_extent <- c(min(setosas$Sepal.Width), max(setosas$Sepal.Width))\n\nggplot() +\n  geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris) +\n  labs(title = \"Morphologie des sépales des iris\", subtitle = \"n = 150\",\n       x = \"Longueur des sépales\", \n       y = \"Largeur des sépales\",\n       caption = \"Source : jeu de données iris\") +\n  annotate(\"text\", x = 6.7, y = 2.5, # position de la note\n           label = \"une virginica\",  # texte de la note\n           hjust = \"left\", vjust = \"top\", # ajustement\n           size = 3, fontface = \"italic\") + \n  annotate(\"text\", x = 5.7, y = 4.4, # position de la note\n           label = \"une setosa\",  # texte de la note\n           hjust = \"left\", vjust = \"top\", # ajustement\n           size = 3, fontface = \"italic\") +\n  annotate(\"rect\", \n           ymin = sepal.width_extent[[1]],\n           ymax = sepal.width_extent[[2]],\n           xmin = sepal.length_extent[[1]],\n           xmax = sepal.length_extent[[2]],\n           fill = rgb(0.7,0.7,0.7,.5), # remplissage transparent à 50%\n           color = \"black\") # contour de couleur verte\n```\n\n::: {.cell-output-display}\n![Ajout d'annotations géométriques](03-magiedesgraphiques_files/figure-html/fig-fig36-1.png){#fig-fig36 fig-align='center' width=65%}\n:::\n:::\n\n\nComme le dernier calque ajouté au graphique est le rectangle, vous noterez qu'il recouvre tous les calques existant, y compris les précédentes annotations. Pour corriger cela, il suffit de changer l'ordre des calques.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() +\n  annotate(\"rect\", \n           ymin = sepal.width_extent[[1]],\n           ymax = sepal.width_extent[[2]],\n           xmin = sepal.length_extent[[1]],\n           xmax = sepal.length_extent[[2]],\n           fill = rgb(0.7,0.7,0.7,.5), # remplissage transparent à 50%\n           color = \"green\") + # contour de couleur verte\n  geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris) +\n  labs(title = \"Morphologie des sépales des iris\", subtitle = \"n = 150\",\n       x = \"Longueur des sépales\", \n       y = \"Largeur des sépales\",\n       caption = \"Source : jeu de données iris\") +\n\n  annotate(\"text\", x = 6.7, y = 2.5, # position de la note\n           label = \"une virginica\",  # texte de la note\n           hjust = \"left\", vjust = \"top\", # ajustement\n           size = 3, fontface = \"italic\") + \n  annotate(\"text\", x = 5.7, y = 4.4, # position de la note\n           label = \"une setosa\",  # texte de la note\n           hjust = \"left\", vjust = \"top\", # ajustement\n           size = 3, fontface = \"italic\")\n```\n\n::: {.cell-output-display}\n![Gestion de l'ordre des annotations](03-magiedesgraphiques_files/figure-html/fig-fig37-1.png){#fig-fig37 fig-align='center' width=65%}\n:::\n:::\n\n\n### Utilisation des thèmes\n\nDe nombreux autres éléments peuvent être modifiés dans un graphique comme les paramètres des polices, l'arrière-plan, la grille de repères, etc. Il peut être fastidieux de paramétrer tous ces éléments. Une option intéressante est d'utiliser des thèmes déjà préconstruits. Le *package* `ggplot2` propose une dizaine de thèmes : constatons leur impact sur le graphique précédent.\n\n* Le thème classique (`theme_classic`) (@fig-fig38)\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() +\n  geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris) +\n  labs(title = \"Morphologie des sépales des iris\", subtitle = \"n = 150\",\n       x = \"Longueur des sépales\", \n       y = \"Largeur des sépales\",\n       caption = \"Source : jeu de données iris\") + \n  theme_classic()\n```\n\n::: {.cell-output-display}\n![Thème classique](03-magiedesgraphiques_files/figure-html/fig-fig38-1.png){#fig-fig38 fig-align='center' width=65%}\n:::\n:::\n\n\n* Le thème gris (`theme_gray`) (@fig-fig39)\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() +\n  geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris) +\n  labs(title = \"Morphologie des sépales des iris\", subtitle = \"n = 150\",\n       x = \"Longueur des sépales\", \n       y = \"Largeur des sépales\",\n       caption = \"Source : jeu de données iris\") + \n  theme_gray()\n```\n\n::: {.cell-output-display}\n![Thème gris](03-magiedesgraphiques_files/figure-html/fig-fig39-1.png){#fig-fig39 fig-align='center' width=65%}\n:::\n:::\n\n\n* Le thème noir et blanc (`theme_bw`) (@fig-fig310)\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() +\n  geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris) +\n  labs(title = \"Morphologie des sépales des iris\", subtitle = \"n = 150\",\n       x = \"Longueur des sépales\", \n       y = \"Largeur des sépales\",\n       caption = \"Source : jeu de données iris\") + \n  theme_bw()\n```\n\n::: {.cell-output-display}\n![Thème noir et blanc](03-magiedesgraphiques_files/figure-html/fig-fig310-1.png){#fig-fig310 fig-align='center' width=65%}\n:::\n:::\n\n\n* Le thème minimal (`theme_minimal`) (@fig-fig311)\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() +\n  geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris) +\n  labs(title = \"Morphologie des sépales des iris\", subtitle = \"n = 150\",\n       x = \"Longueur des sépales\", \n       y = \"Largeur des sépales\",\n       caption = \"Source : jeu de données iris\") + \n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![Thème minimal](03-magiedesgraphiques_files/figure-html/fig-fig311-1.png){#fig-fig311 fig-align='center' width=65%}\n:::\n:::\n\n\nIl est aussi possible d'utiliser le *package* `ggthemes` qui apporte des thèmes complémentaires intéressants dont : \n\n* Le thème *tufte* (`theme_tufte`, à l'ancienne...) (@fig-fig312)\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(ggthemes)\nggplot() +\n  geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris) +\n  labs(title = \"Morphologie des sépales des iris\", subtitle = \"n = 150\",\n       x = \"Longueur des sépales\", \n       y = \"Largeur des sépales\",\n       caption = \"Source : jeu de données iris\") + \n  theme_tufte()\n```\n\n::: {.cell-output-display}\n![Thème tufte](03-magiedesgraphiques_files/figure-html/fig-fig312-1.png){#fig-fig312 fig-align='center' width=65%}\n:::\n:::\n\n\n* Le thème *economist* (`theme_economist`, inspiré de la revue du même nom) (@fig-fig313)\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() +\n  geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris) +\n  labs(title = \"Morphologie des sépales des iris\", subtitle = \"n = 150\",\n       x = \"Longueur des sépales\", \n       y = \"Largeur des sépales\",\n       caption = \"Source : jeu de données iris\") + \n  theme_economist()\n```\n\n::: {.cell-output-display}\n![Thème economist](03-magiedesgraphiques_files/figure-html/fig-fig313-1.png){#fig-fig313 fig-align='center' width=65%}\n:::\n:::\n\n\n* Le thème *solarized* (`theme_solarized`, plus original) (@fig-fig314)\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() +\n  geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris) +\n  labs(title = \"Morphologie des sépales des iris\", subtitle = \"n = 150\",\n       x = \"Longueur des sépales\", \n       y = \"Largeur des sépales\",\n       caption = \"Source : jeu de données iris\") + \n  theme_solarized()\n```\n\n::: {.cell-output-display}\n![Thème solarized](03-magiedesgraphiques_files/figure-html/fig-fig314-1.png){#fig-fig314 fig-align='center' width=65%}\n:::\n:::\n\n\nIl en existe bien d'autres et vous pouvez composer vos propres thèmes. N'hésitez pas à explorer la documentation de `ggplot2` et de `ggthemes` pour en apprendre plus!\n\n### Composition d'une figure avec plusieurs graphiques {#sec-0314}\n\nIl est très fréquent de vouloir combiner plusieurs graphiques dans une même figure. Deux cas se distinguent : \n\n1. Les données pour les différents graphiques proviennent du même *DataFrame* et peuvent être distinguées selon une variable catégorielle. L'objectif est alors de dupliquer le même graphique, mais pour des sous-groupes de données. Dans ce cas, nous recommandons d'utiliser la fonction `facet_wrap` de `ggplot2`.\n\n2. Les graphiques sont complètement indépendants. Dans ce cas, nous recommandons d'utiliser la fonction `ggarrange` du *package* `ggpubr`.\n\n#### `ggplot2` et ses facettes {#sec-03141}\n\nNous pourrions souhaiter réaliser une figure composite avec le jeu de données *iris* et séparer notre nuage de points en trois graphiques distincts selon l'espèce des iris (@fig-fig315). Pour cela, il faut au préalable convertir la variable *espèce* en facteur.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\niris$Species_fac <- as.factor(iris$Species)\n\nggplot() +\n  geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris) +\n  labs(title = \"Morphologie des sépales des iris\", subtitle = \"n = 150\",\n       x = \"Longueur des sépales\", \n       y = \"Largeur des sépales\",\n       caption = \"Source : jeu de données iris\") +\n  facet_wrap(vars(Species_fac), ncol = 2)\n```\n\n::: {.cell-output-display}\n![Graphique à facettes](03-magiedesgraphiques_files/figure-html/fig-fig315-1.png){#fig-fig315 fig-align='center' width=65%}\n:::\n:::\n\nNotez que le nom de la variable (ici `Species_fac`) doit être spécifié au sein d'une sous-fonction `vars` : `vars(Species_fac)`. Nous aurions aussi pu réaliser le graphique sur une seule ligne en spécifiant `ncol = 3` (@fig-fig316).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() +\n  geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris) +\n  labs(title = \"Morphologie des sépales des iris\", subtitle = \"n = 150\",\n       x = \"Longueur des sépales\", \n       y = \"Largeur des sépales\",\n       caption = \"Source : jeu de données iris\") +\n  facet_wrap(vars(Species_fac), ncol = 3)\n```\n\n::: {.cell-output-display}\n![Graphique à facettes en une ligne](03-magiedesgraphiques_files/figure-html/fig-fig316-1.png){#fig-fig316 fig-align='center' width=65%}\n:::\n:::\n\n\n#### Arrangement des graphiques {#sec-03142}\n\nLa solution avec les facettes est très pratique, mais également très limitée puisqu'elle ne permet pas de créer une figure avec des graphiques combinant plusieurs types de géométries. `ggarrange` du *package* `ggpubr` permet tout simplement de combiner des graphiques déjà existant. Créons deux nuages de points comparant plusieurs variables en fonction de l'espèce des iris, puis combinons-les (@fig-fig317). Attribuons également aux points une couleur en fonction de l'espèce des fleurs, afin de mieux les distinguer en associant la variable `Species` au paramètre `color`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(ggpubr)\n\nplot1 <- ggplot(data = iris) +\n  geom_point(aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +\n  labs(subtitle = \"Caractéristiques des sépales\",\n       x = \"Longueur\", \n       y = \"Largeur\",\n       color = \"Espèce\")\n\nplot2 <- ggplot(data = iris) +\n  geom_point(aes(x = Petal.Length, y = Petal.Width, color = Species)) +\n  labs(subtitle = \"Caractéristiques des pétales\",\n       x = \"Longueur\", \n       y = \"Largeur\",\n       color = \"Espèce\")\n\nliste_plots <- list(plot1, plot2)\ncomp_plot <- ggarrange(plotlist = liste_plots, ncol = 2, nrow = 1,\n          common.legend = TRUE, legend = \"bottom\") #gérer la légende\n\nannotate_figure(comp_plot,\n                top = text_grob(\"Morphologie des sépales et pétales des iris\",\n                                face = \"bold\", size = 12, just = \"center\"),\n                bottom = text_grob(\"Source : jeu de données iris\",\n                                face = \"italic\", size = 8, just = \"left\")\n                )\n```\n\n::: {.cell-output-display}\n![Figure avec plusieurs graphiques avec ggarrange](03-magiedesgraphiques_files/figure-html/fig-fig317-1.png){#fig-fig317 fig-align='center' width=65%}\n:::\n:::\n\n\nQuatre étapes sont nécessaires : \n\n1. Créer les graphiques et les enregistrer dans des objets (ici *plot1* et *plot2*).\n2. Encapsuler ces objets dans une liste (ici *liste_plots*).\n3. Composer la figure finale avec la fonction `ggarrange`.\n4. Ajouter les annotations à la figure composite.\n\nL'argument `common.legend` permet d'indiquer à la fonction `ggarrange` de regrouper les légendes des deux graphiques. Dans notre cas, les deux graphiques ont les mêmes légendes, il est donc judicieux de les regrouper. L'argument `legend` contrôle la position de la légende et peut prendre les valeurs : *top*, *bottom*, *left*, *right* ou *none* (absence de légende). La fonction `annotate_figure` permet d'ajouter des éléments de texte au-dessus, au-dessous et sur les cotés de la figure composite.\n\n### Couleur {#sec-0315}\n\nDans un graphique, la couleur peut être utilisée à la fois pour représenter une variable quantitative (dégradé de couleur ou mise en classes), ou une variable qualitative (couleur par catégorie). Dans `ggplot2`, il est possible d'attribuer une couleur au contour des géométries avec l'argument `color` et au remplissage avec l'argument `fill`. Il est possible de spécifier une couleur de trois façons dans R : \n\n* En utilisant le nom de la couleur dans une chaîne de caractère : `\"chartreuse4\"`. R dispose de 657 noms de couleurs prédéfinis. Pour tous les afficher, utilisez la fonction `colors()`, qui permet de les visualiser (@fig-colors).\n\n![Couleurs de base](images/Chap03/all_colors.png){#fig-colors width=\"100%\" fig-align=\"center\"}\n\n* En indiquant le code hexadécimal de la couleur. Il s'agit d'une suite de six lettres et de chiffres précédée par un dièse : `\"#99ff33\"`.\n\n* En utilisant une notation RGB (rouge, vert, bleu, transparence). Cette notation doit contenir quatre nombres entre 0 et 1 (0 % et 100 %), indiquant respectivement la quantité de rouge, de vert, de bleu et la transparence. Ces quatre nombres sont donnés comme argument à la fonction `rgb` : `rgb(0.6, 1, 0.2, 0)`.\n\nLe choix des couleurs est un problème plus complexe que la manière de les spécifier. Il existe d'ailleurs tout un pan de la sémiologie graphique dédié à la question du choix et de l'association des couleurs. Une première ressource intéressante est  [ColorBrewer](https://colorbrewer2.org/#type=sequential&scheme=BuGn&n=3){target=\"_blank\"}. Il s'agit d'une sélection de palettes de couleurs particulièrement efficaces et dont certaines sont même adaptées pour les personnes daltoniennes (@fig-colorBrewer). Il est possible d'accéder directement aux palettes dans R grâce au *package* `RColorBrewer` et la fonction `brewer.pal` : \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(RColorBrewer)\ndisplay.brewer.all()\n```\n\n::: {.cell-output-display}\n![Palette de couleurs de ColorBrewer](03-magiedesgraphiques_files/figure-html/fig-colorBrewer-1.png){#fig-colorBrewer fig-align='center' width=85%}\n:::\n:::\n\n\nUne autre ressource pertinente est le site web [coolors.co](https://coolors.co/palettes/trending){target=\"_blank\"} qui propose de nombreuses palettes à portée de clic.\n\n## Principaux graphiques {#sec-032}\n\n\n::: bloc_objectif\n::: bloc_objectif-header\n::: bloc_objectif-icon\n:::\n**Construire des graphiques avec `ggplot2`**\n:::\n::: bloc_objectif-body\nPuisque vous avez désormais une certaine connaissance des bases de la grammaire des graphiques implémentées par `ggplot2`, vous apprendrez dans les sous-sections suivantes à construire les principaux graphiques que vous utiliserez régulièrement ou que vous présenterez dans un article scientifique.\n:::\n:::\n\n### Histogramme {#sec-0321}\n\nL'histogramme permet de décrire graphiquement la forme de la distribution d'une variable. Pour le réaliser, nous utilisons la fonction `geom_histogram`. Le paramètre le plus important est le nombre de barres (`bins`) qui composent l'histogramme. Plus ce nombre est grand, plus l'histogramme est précis et, à l'inverse, plus il est petit, plus l'histogramme est simplifié. En revanche, il faut éviter d'utiliser un nombre de barres trop élevé comparativement au nombre d'observations disponibles dans le jeu de données, sinon l'histogramme risque d'avoir plein de trous.\n\n#### Histogramme simple {#sec-03211}\n\nGénérons quatre variables ayant respectivement une distribution gaussienne, Student, Gamma et bêta, puis réalisons un histogramme pour chacune de ces variables et combinons-les avec la fonction `ggarrange` (@fig-fig318).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndistribs <- data.frame(\n  gaussien = rnorm(1000, mean = 5, sd = 1.5),\n  gamma = rgamma(1000, shape = 2, rate = 12),\n  beta = rbeta(1000, shape1 = 5, shape2 = 1, ncp = 2),\n  student = rt(1000, ncp = 20, df = 5)\n)\n\nplot1 <- ggplot(data = distribs) +\n  geom_histogram(aes(x = gaussien), bins = 50, color = \"#343a40\", fill = \"#e63946\")+\n  labs(y = \"fréquences\")+ylim(c(0,130))\n\nplot2 <- ggplot(data = distribs) +\n  geom_histogram(aes(x = gamma), bins = 50, color = \"#343a40\", fill = \"#f1faee\")+\n  labs(y = \"fréquences\")+ylim(c(0,130))\n\nplot3 <- ggplot(data = distribs) +\n  geom_histogram(aes(x = beta), bins = 50, color = \"#343a40\", fill = \"#a8dadc\")+\n  labs(y = \"fréquences\")+ylim(c(0,130))\n\nplot4 <- ggplot(data = distribs) +\n  geom_histogram(aes(x = student), bins = 50, color = \"#343a40\", fill = \"#1d3557\")+\n  labs(y = \"fréquences\")+ylim(c(0,130))\n\nhistogrammes <- list(plot1, plot2, plot3, plot4)\n\nggarrange(plotlist = histogrammes, ncol = 2, nrow = 2)\n```\n\n::: {.cell-output-display}\n![Histogrammes](03-magiedesgraphiques_files/figure-html/fig-fig318-1.png){#fig-fig318 fig-align='center' width=65%}\n:::\n:::\n\n\n\nNotez que cette syntaxe est très lourde. Dans le cas présent, il serait plus judicieux d'utiliser la fonction `facet_wrap`. Pour cela, nous devons au préalable empiler nos données, ce qui signifie changer la forme du *DataFrame* actuel, qui comprend quatre colonnes (gaussien, Gamma, bêta et student) et 1000 observations, pour qu'il n'ait plus que deux colonnes (la valeur originale et le nom de l'ancienne colonne) et 4000 observations. La @fig-fig319 décrit graphiquement ce processus qui peut être effectué avec la fonction `melt` du *package* `reshape2`.\n\n![Empiler les données d'un DataFrame](images/Chap03/melting.png){#fig-fig319 width=\"30%\" fig-align=\"center\"}\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(reshape2)\n\n# Faire fondre le jeu de données\nmelted_distribs <- melt(distribs, measure.vars = c(\"gaussien\", \"gamma\",\n                                                   \"beta\" , \"student\"))\n# Renommer les colonnes du nouveau DataFrame\nnames(melted_distribs) <- c(\"distribution\", \"valeur\")\n# Convertir la variable catégorielle en facteur\nmelted_distribs$distribution <- as.factor(melted_distribs$distribution)\n\nggplot(data = melted_distribs)+\n  geom_histogram(aes(x = valeur, fill = distribution), bins = 50, color = \"#343a40\") +\n  ylim(c(0,130)) + \n  labs(x = \"valeur\", \n       y = \"fréquences\")+\n  scale_fill_manual(values = c(\"#e63946\" , \"#f1faee\" , \"#a8dadc\" , \"#1d3557\"))+\n  facet_wrap(vars(distribution), ncol = 2, scales = \"free\")+\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![Histogrammes à facettes](03-magiedesgraphiques_files/figure-html/fig-fig320-1.png){#fig-fig320 fig-align='center' width=65%}\n:::\n:::\n\n\n#### Histogramme de densité {#sec-03212}\n\nLes histogrammes que nous venons de construire utilisent la fréquence des observations pour délimiter la hauteur des barres. Il est possible de changer ce comportement pour plutôt utiliser la densité. L'intérêt est notamment de se rapprocher encore de la définition d'une distribution puisqu'avec cette configuration, la somme totale de la surface de l'histogramme est égale à 1. La hauteur de chaque barre représente alors la probabilité d'obtenir l'étendue de valeurs représentées par cette barre. Prenons pour exemple la variable avec la distribution normale que nous venons de voir.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot1 <- ggplot(data = distribs) +\n  geom_histogram(aes(x = gaussien, y = after_stat(density)),\n                 bins = 30, color = \"#343a40\", fill = \"#1d3557\")+\n      labs(x = \"gaussien\", y = \"densité\")\n\nplot2 <- ggplot(data = distribs) +\n  geom_histogram(aes(x = gaussien, y = ..count..),\n                 bins = 30, color = \"#343a40\", fill = \"#a8dadc\")+\n        labs(x = \"gaussien\", y = \"fréquences\")\n\nggarrange(plotlist = list(plot1, plot2), ncol = 2)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: The dot-dot notation (`..count..`) was deprecated in ggplot2 3.4.0.\nℹ Please use `after_stat(count)` instead.\n```\n:::\n\n::: {.cell-output-display}\n![Histogrammes de densité](03-magiedesgraphiques_files/figure-html/fig-fig321-1.png){#fig-fig321 fig-align='center' width=65%}\n:::\n:::\n\n\nLe graphique de droite (fréquence) nous indique donc que plus de 60 observations ont une valeur d'environ 5 (entre 4,76 et 5,34, compte tenu de la largeur de la barre), ce qui se traduit par une probabilité de presque 30 % d'obtenir cette valeur en tirant une observation au hasard dans le jeu de données.\n\n#### Histogramme avec courbe de distribution {#sec-03213}\n\nLes histogrammes sont souvent utilisés pour vérifier graphiquement si une distribution empirique s'approche d'une courbe normale. Pour cela, nous ajoutons sur l'histogramme de la variable empirique la forme qu'aurait une distribution normale parfaite en utilisant la moyenne et l'écart type de la distribution empirique. Pour créer cette figure dans `ggplot2`, il suffit d'utiliser la fonction `stat_function` pour créer un nouveau calque. Il est aussi possible d'ajouter une ligne verticale (`geom_vline`) pour indiquer la moyenne de la distribution.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmoyenne <- mean(distribs$gaussien)\necart_type <- sd(distribs$gaussien)\n\nggplot(data = distribs) +\n  geom_histogram(aes(x = gaussien, y = after_stat(density)),\n                 bins = 30, color = \"#343a40\", fill = \"#a8dadc\") +\n    labs(x = \"gaussien\", \n       y = \"densité\")+\n  stat_function(fun = dnorm, args = list(mean = moyenne, sd = ecart_type), \n                color = \"#e63946\", linewidth = 1.2, linetype = \"dashed\") +\n  geom_vline(xintercept = moyenne, color = \"red\", linetype = 1)+\n  annotate(\"text\", x = round(moyenne,2)+0.5, y = 0.31, hjust = 'left',\n           label = paste('moyenne : ', round(moyenne,2), sep=''))\n```\n\n::: {.cell-output-display}\n![Histogramme et courbe normale](03-magiedesgraphiques_files/figure-html/fig-fig322-1.png){#fig-fig322 fig-align='center' width=65%}\n:::\n:::\n\n\nDans notre cas, nous savons que notre variable est normalement distribuée (car produite avec la fonction `rnorm`), et nous pouvons constater la grande proximité entre l'histogramme et la courbe normale.\n\n#### Histogramme avec coloration des valeurs extrêmes {#sec-03214}\n\nIl peut être nécessaire d'attirer le regard sur certaines parties de l'histogramme, comme sur des valeurs extrêmes. Si nous reprenons notre distribution de Student, nous pouvons clairement distinguer un ensemble de valeurs fortes à droite de la distribution. Nous pourrions, dans notre cas, considérer que des valeurs au-delà de 50 constituent des cas extrêmes que nous souhaitons représenter dans une autre couleur. Pour cela, nous devons créer une variable catégorielle nous permettant de distinguer ces cas particuliers.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndistribs$cas_extreme <- ifelse(distribs$student >=50, \"extrême\", \"normale\")\n\nggplot(data = distribs) +\n  geom_histogram(aes(x = student, y = ..count.., fill = cas_extreme),\n                 bins = 30, color = \"#343a40\")+\n  scale_fill_manual(\"\", values = c(\"#a8dadc\" , \"#e63946\"))+\n  labs(title = \"Distribution de Student\", x = \"valeur\", y = \"fréquence\")\n```\n\n::: {.cell-output-display}\n![Histogramme coloré](03-magiedesgraphiques_files/figure-html/fig-fig323-1.png){#fig-fig323 fig-align='center' width=65%}\n:::\n:::\n\n\n### Graphique de densité {#sec-0322}\n\nL'histogramme est utilisé pour approximer graphiquement la distribution d'une variable. Sa principale limite est de représenter la variable de façon discontinue. Une option intéressante est d'utiliser une version lissée de l'histogramme, soit le graphique de densité. Cette opération de lissage est réalisée le plus souvent à partir de fonctions kernel. Reconstruisons notre figure avec les quatre distributions, mais en utilisant cette fois-ci des graphiques de densité.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = melted_distribs)+\n  geom_density(aes(x = valeur, fill = distribution), color = \"#343a40\") +\n  scale_fill_manual(values = c(\"#e63946\" , \"#f1faee\" , \"#a8dadc\" , \"#1d3557\"))+\n  facet_wrap(vars(distribution), ncol = 2, scales = \"free\")+\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![Graphiques de densité à facette](03-magiedesgraphiques_files/figure-html/fig-fig324-1.png){#fig-fig324 fig-align='center' width=65%}\n:::\n:::\n\n\nLes graphiques de densité sont souvent utilisés pour comparer la distribution d'une variable pour plusieurs sous-groupes d'une population. Si nous reprenons le jeu de données *iris*, nous pouvons comparer les longueurs de sépales en fonction des espèces. Nous constatons ainsi que les setosas ont une nette tendance à avoir des sépales plus courts et qu'à l'inverse, les virginicas ont les sépales généralement les plus longs.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = iris)+\n  geom_density(aes(x = Sepal.Length, fill = Species), \n               color = \"#343a40\", alpha = 0.4)+\n  labs(x = \"Longueur de sépales\",\n       y = \"\",\n       fill = \"Espèce\")\n```\n\n::: {.cell-output-display}\n![Graphiques de densité superposés](03-magiedesgraphiques_files/figure-html/fig-fig325-1.png){#fig-fig325 fig-align='center' width=65%}\n:::\n:::\n\n\n\n### Nuage de points {#sec-0323}\n\nUn nuage de points est un outil très intéressant pour visualiser la relation existante entre deux variables. Prenons un exemple concret et analysons le volume de CO~2~ produit annuellement par habitant en comparaison avec le niveau d'urbanisation dans l'ensemble des pays à travers le monde. Nous avons extrait ces données sur le site web de la [Banque mondiale](https://donnees.banquemondiale.org/indicateur){target=\"_blank\"}, puis nous les avons structurés dans un fichier *csv*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_co2 <- read.csv(\"data/graphique/world_urb_co2.csv\", encoding = \"UTF-8\")\nnames(data_co2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"country_code\" \"year\"         \"Population\"   \"Urbanisation\" \"CO2_kt\"      \n[6] \"Country.Name\" \"CO2t_hab\"     \"region7\"      \"region23\"    \n```\n:::\n:::\n\n\n#### Nuage de points simple {#sec-03231}\n\nCommençons par un nuage de points simple avec l'ensemble des données.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = data_co2)+\n  geom_point(aes(x = Urbanisation, y = CO2t_hab))+\n  labs(x = \"Niveau d'urbanisation (%)\",\n       y = \"Tonnes de CO2 par année et par habitant\",\n       title = \"Relation entre urbanisation et production de CO2 par habitant\")\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Nuage de points simple](03-magiedesgraphiques_files/figure-html/fig-fig326-1.png){#fig-fig326 fig-align='center' width=65%}\n:::\n:::\n\n\nÀ la première lecture de ce graphique, nous observons immédiatement un ensemble de points étranges dont le volume de CO~2~ par habitant annuel est au-dessus de 150 tonnes et dont le niveau d'urbanisation est proche de 50 %. Isolons ces données pour observer de quoi il s'agit.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncas_etrange <- subset(data_co2, data_co2$CO2t_hab >= 150)\nprint(cas_etrange$Country.Name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Aruba\" \"Aruba\" \"Aruba\" \"Aruba\" \"Aruba\" \"Aruba\" \"Aruba\" \"Aruba\" \"Aruba\"\n[10] \"Aruba\" \"Aruba\" \"Aruba\" \"Aruba\" \"Aruba\" \"Aruba\" \"Aruba\" \"Aruba\" \"Aruba\"\n[19] \"Aruba\" \"Aruba\" \"Aruba\" \"Aruba\" \"Aruba\" \"Aruba\" \"Aruba\"\n```\n:::\n:::\n\n\nIl s'agit d'une petite île néerlandaise des Caraïbes nommée Aruba disposant d'une faible population, mais avec des activités très polluantes (raffinerie et extraction d'or). Nous faisons ici le choix de retirer ces observations puisqu'elles sont assez peu représentatives de la tendance mondiale. Cette démarche si simple relève ainsi de l'analyse exploratoire des données! Sans ce graphique, nous n'aurions probablement jamais identifié ces cas problématiques.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_co2 <- subset(data_co2, data_co2$CO2t_hab <= 150)\n```\n:::\n\n\nReconstruisons le nuage de points maintenant que ces données aberrantes ont été retirées.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngraphique <-  ggplot(data = data_co2)+\n  geom_point(aes(x = Urbanisation, y = CO2t_hab))+\n  labs(x = \"Niveau d'urbanisation (%)\",\n       y = \"Tonnes de CO2 par année et par habitant\",\n       title = \"Relation entre urbanisation et production de CO2 par habitant\")\n```\n:::\n\n\nVoilà qui est mieux! Cependant, le grand nombre de points restant rend la lecture du graphique assez difficile puisqu'ils se superposent. Une première option à envisager, dans ce cas, est à la fois d'ajouter de la transparence aux points et de réduire leur taille : \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = data_co2)+\n  geom_point(aes(x = Urbanisation, y = CO2t_hab), alpha = 0.2, size = 0.5)+\n  labs(x = \"Niveau d'urbanisation (%)\",\n       y = \"Tonnes de CO2 par année et par habitant\",\n       title = \"Relation entre urbanisation et production de CO2 par habitant\")\n```\n\n::: {.cell-output-display}\n![Nuage de points simple avec transparence](03-magiedesgraphiques_files/figure-html/fig-fig328-1.png){#fig-fig328 fig-align='center' width=65%}\n:::\n:::\n\n\n\n#### Nuage de points avec densité {#sec-03232}\n\nBien que la transparence nous aide un peu à distinguer les secteurs du graphique avec le plus de points, il serait plus efficace d'abandonner la géométrie des points pour la remplacer par une géométrie de densité en deux dimensions. Une première approche consiste à diviser l'espace du graphique en petits carrés et à compter le nombre de points tombant dans chaque carré (en somme, un histogramme en deux dimensions).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = data_co2)+\n  geom_bin2d(aes(x = Urbanisation, y = CO2t_hab), bins = 50) +\n  scale_fill_continuous(type = \"viridis\") +\n  labs(x = \"Niveau d'urbanisation (%)\",\n       y = \"Tonnes de CO2 par année et par habitant\",\n       fill = \"Effectif\",\n       title = \"Relation entre urbanisation et production de CO2 par habitant\")\n```\n\n::: {.cell-output-display}\n![Nuage de points simple](03-magiedesgraphiques_files/figure-html/fig-fig329-1.png){#fig-fig329 fig-align='center' width=65%}\n:::\n:::\n\n\nNous observons ainsi une forte concentration dans le bas du graphique; les pays avec des rejets annuels de CO~2~  supérieurs à 15 tonnes par habitant sont relativement rares. Pour les personnes préférant les représentations plus élaborées, il est aussi possible de diviser l'espace du graphique avec des hexagones en utilisant le *package* `hexbin`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = data_co2)+\n  geom_hex(aes(x = Urbanisation, y = CO2t_hab), bins = 50) +\n  scale_fill_continuous(type = \"viridis\") +\n  labs(x = \"Niveau d'urbanisation (%)\",\n       y = \"Tonnes de CO2 par année et par habitant\",\n       fill = \"Effectif\",\n       title = \"Relation entre urbanisation et production de CO2 par habitant\")\n```\n\n::: {.cell-output-display}\n![Densité en deux dimensions par hexagones](03-magiedesgraphiques_files/figure-html/fig-fig330-1.png){#fig-fig330 fig-align='center' width=65%}\n:::\n:::\n\n\nEnfin, il est aussi possible de réaliser une version lissée de ces graphiques avec une fonction kernel en deux dimensions (`stat_density_2d`) : \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = data_co2)+\n  stat_density_2d(aes(x = Urbanisation, y = CO2t_hab, fill = ..density..), \n                  geom = \"raster\", n = 50, contour = FALSE) +\n  scale_fill_continuous(type = \"viridis\") +\n  labs(x = \"Niveau d'urbanisation (%)\",\n       y = \"Tonnes de CO2 par année et par habitant\",\n       fill = \"densité\",\n       title = \"Relation entre urbanisation et production de CO2 par habitant\")+\n  ylim(0,25)\n```\n\n::: {.cell-output-display}\n![Densité lissée en deux dimensions](03-magiedesgraphiques_files/figure-html/fig-fig331-1.png){#fig-fig331 fig-align='center' width=65%}\n:::\n:::\n\n\n#### Nuage de points et droite de régression {#sec-03233}\n\nAfin de faire ressortir une éventuelle relation entre les variables représentées sur les deux axes, il est possible d'afficher la droite de régression sur le graphique entre X et Y. Cette opération s'effectue avec la fonction `geom_smooth`.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = data_co2)+\n  geom_point(aes(x = Urbanisation, y = CO2t_hab), alpha = 0.2, size = 0.5)+\n  geom_smooth(aes(x = Urbanisation, y = CO2t_hab), method = lm, color = \"red\")+\n  labs(x = \"Niveau d'urbanisation (%)\",\n       y = \"Tonnes de CO2 par année et par habitant\",\n       title = \"Relation entre urbanisation et production de CO2 par habitant\")\n```\n\n::: {.cell-output-display}\n![Nuage de points avec droite de régression](03-magiedesgraphiques_files/figure-html/fig-fig332-1.png){#fig-fig332 fig-align='center' width=65%}\n:::\n:::\n\n\nNotez que l'argument `method = lm` permet d'indiquer que nous souhaitons utiliser une régression linéaire (*linear model*) pour tracer la géométrie (une droite de régression). La droite semble bien indiquer une relation positive entre les deux variables : une augmentation de l'urbanisation serait associée à une augmentation de la production annuelle de CO~2~ par habitant. Nous pourrions également vérifier si une relation non linéaire serait plus adaptée au jeu de données. Dans notre cas, une relation quadratique pourrait produire un meilleur ajustement.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = data_co2)+\n  geom_point(aes(x = Urbanisation, y = CO2t_hab), alpha = 0.2, size = 0.7)+\n  geom_smooth(aes(x = Urbanisation, y = CO2t_hab), method = lm, \n              color = \"red\", formula = y ~ I(x**2))+\n  labs(x = \"Niveau d'urbanisation (%)\",\n       y = \"Tonnes de CO2 par année et par habitant\",\n       title = \"Relation entre urbanisation et production de CO2 par habitant\")\n```\n\n::: {.cell-output-display}\n![Nuage de points avec droite de régression quadratique](03-magiedesgraphiques_files/figure-html/fig-fig333-1.png){#fig-fig333 fig-align='center' width=65%}\n:::\n:::\n\n\nLa régression quadratique (avec *x* au carré) nous indique ainsi que l'impact du niveau d'urbanisation est plus important à mesure que ce niveau augmente. Vous pouvez également constater que la courbe ne prédit pas de valeurs négatives comparativement à la droite précédente. Il est également possible d'ajuster une courbe sans choisir au préalable sa forme (dans le cas précédent $x^2$) en utilisant une méthode d'ajustement local appelée *loess*.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = data_co2)+\n  geom_point(aes(x = Urbanisation, y = CO2t_hab), alpha = 0.2, size = 0.5)+\n  geom_smooth(aes(x = Urbanisation, y = CO2t_hab), method = loess, \n              color = \"red\")+\n  labs(x = \"Niveau d'urbanisation (%)\",\n       y = \"Tonnes de CO2 par année et par habitant\",\n       title = \"Relation entre urbanisation et production de CO2 par habitant\")\n```\n\n::: {.cell-output-display}\n![Nuage de points avec droite de régression non linéaire](03-magiedesgraphiques_files/figure-html/fig-fig334-1.png){#fig-fig334 fig-align='center' width=65%}\n:::\n:::\n\n\nLa relation non linéaire révèle davantage d'informations : l'augmentation de l'urbanisation est associée à une augmentation de l'émission de CO~2~ par habitant uniquement jusqu'à 75 % d'urbanisation; au-delà de ce seuil, la relation ne tient plus. Ces résultats semblent cohérents avec l'évolution classique de l'économie d'un pays passant progressivement d'une économie agricole, à une économie industrialisée et finalement une économie de services.\n\n### Graphique en ligne {#sec-0324}\n\nUn graphique en ligne permet de représenter l'évolution d'une variable, généralement dans le temps. Dans le jeu de données précédent, nous disposons des émissions de CO~2~ par habitant de nombreux pays sur plusieurs années. Nous pouvons ainsi représenter l'évolution des émissions pour chaque pays avec un graphique en ligne. Pour éviter de le surcharger, cet exercice est réalisé uniquement sur les pays de l'Europe de l'Ouest.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# conversion de la variable year textuelle en variable numérique\ndata_co2$an <- as.numeric(data_co2$year)\n# extraction des données d'Europe de l'Ouest\ndata_europe <- subset(data_co2, data_co2$region23 == \"Europe de l'Ouest\")\n# choix des valeurs pour l'axe des x\nx_ticks <- seq(1960,2020,10)\n\nggplot(data = data_europe)+\n  geom_path(aes(x = an, y = CO2t_hab, color = Country.Name))+\n  labs(x = \"Années\",\n       y = \"Tonnes de CO2 par année et par habitant\",\n       color = \"Pays\",\n       title = \"Évolution de la production de CO2 par habitant\") +\n  scale_x_continuous(breaks = x_ticks, labels = x_ticks)+\n  theme_tufte()\n```\n\n::: {.cell-output-display}\n![Graphique en ligne](03-magiedesgraphiques_files/figure-html/fig-fig335-1.png){#fig-fig335 fig-align='center' width=65%}\n:::\n:::\n\n\nNous remarquons notamment qu'aucune donnée, avant 2005, n'est disponible pour le Liechtenstein.\n\n#### Barre d'erreur et en bande {#sec-03241}\n\nSur un graphique, il est souvent pertinent de représenter l'incertitude que nous avons sur nos données. Cela peut être fait à l'aide de barres d'erreur ou à l'aide de polygones délimitant les marges d'incertitude. En guise d'exemple, admettons que les données précédentes sont fiables à plus ou moins 10 %. En d'autres termes, la valeur d'émission de CO~2~ annuelle serait relativement incertaine et pourrait se situer dans un intervalle de 10 % autour de la valeur fournie par la Banque mondiale. Nous obtenons ainsi une borne inférieure (valeur donnée - 10 %) et une borne supérieure (valeur donnée + 10 %). Nous pouvons facilement calculer ces bornes et les faire apparaître dans notre graphique précédent.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata_europe$borne_basse <- data_europe$CO2t_hab - 0.1 * data_europe$CO2t_hab\ndata_europe$borne_haute <- data_europe$CO2t_hab + 0.1 * data_europe$CO2t_hab\n\nggplot(data = data_europe)+\n  geom_point(aes(x = an, y = CO2t_hab, color = Country.Name), size = 0.7)+\n  geom_errorbar(aes(x = an, ymin = borne_basse, ymax = borne_haute, color = Country.Name))+\n  labs(x = \"Années\",\n       y = \"Tonnes de CO2 par année et par habitant\",\n       color = \"Pays\",\n       title = \"Évolution de la production de CO2 par habitant\") +\n  scale_x_continuous(breaks = x_ticks, labels = x_ticks)+\n  theme_tufte()\n```\n\n::: {.cell-output-display}\n![Graphique en ligne avec barres d'erreur](03-magiedesgraphiques_files/figure-html/fig-fig336-1.png){#fig-fig336 fig-align='center' width=65%}\n:::\n:::\n\n\nCes barres d'erreurs indiquent notamment qu'il n'y a finalement aucun écart significatif entre la Belgique, les Pays-Bas et l'Allemagne à partir des années 1990. Une autre option de représentation est d'utiliser des polygones avec la fonction `geom_ribbon`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = data_europe)+\n  geom_path(aes(x = an, y = CO2t_hab, color = Country.Name), size = 0.7)+\n  geom_ribbon(aes(x = an, ymin = borne_basse, ymax = borne_haute,\n                  fill = Country.Name), alpha = 0.4)+\n  labs(x = \"Années\",\n       y = \"Tonnes de CO2 par année et par habitant\",\n       color = \"Pays\",\n       title = \"Évolution de la production de CO2 par habitant\") +\n  scale_x_continuous(breaks = x_ticks, labels = x_ticks)+\n  theme_tufte()+\n  guides(fill = FALSE,  scale = \"none\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: The `<scale>` argument of `guides()` cannot be `FALSE`. Use \"none\" instead as\nof ggplot2 3.3.4.\n```\n:::\n\n::: {.cell-output-display}\n![Graphique en ligne avec marge d'erreur](03-magiedesgraphiques_files/figure-html/fig-fig337-1.png){#fig-fig337 fig-align='center' width=65%}\n:::\n:::\n\n\nLe message du graphique est le même. Notez que nous avons utilisé ici la fonction `guides` pour retirer de la légende les couleurs associées au remplissage des marges d'erreur. Ces couleurs sont les mêmes que celles des lignes et il n'est pas utile de dédoubler la légende. De nombreuses méthodes statistiques produisent des résultats accompagnés d'une mesure de l'incertitude associée à ces résultats. Représenter cette incertitude est crucial pour que le lecteur puisse délimiter la portée des conclusions de vos analyses.\n\n### Boîte à moustaches {#sec-0325}\n\nLes boîtes à moustaches (*box plot* en anglais) sont des graphiques permettant de comparer les moyennes et les intervalles interquartiles d'une variable continue selon plusieurs groupes d'une population. Si nous reprenons notre exemple précédent, nous pourrions comparer, en fonction de la région du monde, la moyenne de production annuelle de CO~2~ par habitant. Pour cela, il suffit d'utiliser la fonction `geom_boxplot`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Retirer les observations n'étant pas associées à une région\ndata_co2_comp <- subset(data_co2, is.na(data_co2$region7) == FALSE)\n\nggplot(data = data_co2_comp)+\n  geom_boxplot(aes(y = region7, x = CO2t_hab))+\n  labs(x = \"Tonnes de CO2 par an et habitant\", y = \"Région\")\n```\n\n::: {.cell-output-display}\n![Boîtes à moustaches](03-magiedesgraphiques_files/figure-html/fig-fig338-1.png){#fig-fig338 fig-align='center' width=65%}\n:::\n:::\n\n\nLa barre centrale d'une boîte représente la moyenne. Les extrémités de la boîte représentent le premier et le troisième quartile. Plus une boîte est allongée, plus les situations sont diversifiées pour les observations appartenant au groupe représenté par la boîte. Au contraire, une boîte étroite indique un groupe homogène. Notez qu'en inversant les variables dans les axes *X* et *Y*, nous obtiendrions des boîtes à moustaches verticales. Cependant, les noms des régions étant assez longs, cela nécessiterait d'avoir un graphique très large. Améliorons quelque peu le rendu de ce graphique en ajoutant des titres.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = data_co2_comp)+\n  geom_boxplot(aes(y = region7, x = CO2t_hab))+\n  xlim(c(0,50))+\n  labs(x = \"Tonnes de CO2 par an et habitant\",\n       y = \"Région\")\n```\n\n::: {.cell-output-display}\n![Boîtes à moustaches améliorées](03-magiedesgraphiques_files/figure-html/fig-fig339-1.png){#fig-fig339 fig-align='center' width=65%}\n:::\n:::\n\n\nLes points noirs sur le graphique représentent des valeurs extrêmes, soit des observations situées à plus de 1,5 intervalle interquartile d'une extrémité de la boîte. Pour mieux rendre compte de la densité d'observations le long de chaque boîte à moustaches, il est possible de les représenter directement avec la fonction `geom_jitter`.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Boîtes à moustaches avec observations](03-magiedesgraphiques_files/figure-html/fig-fig340-1.png){#fig-fig340 fig-align='center' width=65%}\n:::\n:::\n\nNotez que pour éviter que les valeurs extrêmes identifiées par la fonction `geom_boxplot` se superposent avec les points représentant les observations, nous les avons supprimées avec l'argument `outlier.shape = NA`.\n\n### Graphique en violon {#sec-0326}\n\nLes boîtes à moustaches donnent des informations pertinentes sur le centre et la dispersion d'une variable en fonction de sous groupes de la population. Cependant, une grande partie de l'information reste masquée par la représentation sous forme de boîte. Une solution est de remplacer la simple boîte par la distribution de la variable étudiée. Nous obtenons ainsi des graphiques en violon (`geom_violin`). Considérant les très grands écarts que nous avons observés entre les régions avec les boîtes à moustaches, il est préférable de tracer les graphiques en violon en excluant les régions Afrique Sub-Saharienne et Asie du Sud.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Retirons les observations de régions que nous ne souhaitons pas garder\ndata_co2_comp <- subset(data_co2, (! data_co2$region7 %in% \n                                     c(\"Sub-Saharan Africa\", \"South Asia\")) \n                        & is.na(data_co2$region7) == FALSE)\n\nggplot(data = data_co2_comp)+\n  geom_violin(aes(y = region7, x = CO2t_hab))+\n  xlim(c(0,50))+\n  labs(x = \"Tonnes de CO2 par année et par habitant\",\n       y = \"\")+\n  geom_vline(xintercept = 12, linetype = 'dashed', color = \"blue\")\n```\n\n::: {.cell-output-display}\n![Graphiques en violon](03-magiedesgraphiques_files/figure-html/fig-fig341-1.png){#fig-fig341 fig-align='center' width=65%}\n:::\n:::\n\n\nCes distributions permettent notamment de souligner que deux groupes distincts se retrouvent en Amérique du Nord. L'un dont les émissions annuelles de CO~2~ par habitant sont inférieures à 12 tonnes (ligne bleue) et l'autre pour lequel elles sont supérieures. En explorant les données, nous constatons que les Bermudes appartiennent au groupe Amérique du Nord, mais ont des niveaux d'émission inférieurs à ceux du Canada et des États-Unis, ce qui explique cette distribution bimodale. Cette information était masquée avec les boîtes à moustaches. Finalement, il est aussi possible de superposer un graphique en violon et une boîte à moustaches pour bénéficier des avantages des deux.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = data_co2_comp)+\n  geom_violin(aes(y = region7, x = CO2t_hab))+\n  geom_boxplot(aes(y = region7, x = CO2t_hab), width = 0.15)+\n  xlim(c(0,50))+\n  labs(x = \"Tonnes de CO2 par année et par habitant\",\n       y = \"\")\n```\n\n::: {.cell-output-display}\n![Graphiques en violon et boîtes à moustaches](03-magiedesgraphiques_files/figure-html/fig-fig342-1.png){#fig-fig342 fig-align='center' width=65%}\n:::\n:::\n\n\n### Graphique en barres {#sec-0327}\n\nLes graphiques en barres permettent de représenter des quantités (hauteur des barres) réparties dans des catégories (une barre par catégorie). Nous proposons ici un exemple avec des données de déplacements issues de l'*Enquête origine-destination 2017 - Région Québec-Lévis*, au niveau des grands secteurs. La @fig-fig342, tirée du [rapport](https://www.transports.gouv.qc.ca/fr/ministere/Planification-transports/enquetes-origine-destination/quebec/2017/Documents/EOD17_faits_saillants_VF.pdf) intitulé *La mobilité des personnes dans la région de Québec-Lévis (Volet Enquête-ménages : faits saillants)* délimite ces grands secteurs.\n\n![Grands secteurs de Québec](images/Chap03/carte_secteurs.jpg){#fig-fig343 width=\"100%\" fig-align=\"center\"}\n\nNous représentons pour chaque secteur le nombre moyen de déplacements entrant et sortant un jour de semaine en heures de pointe. Les données sont présentées sous forme d'une matrice carrée (avec autant de lignes que de colonnes). L'intersection de la ligne A et de la colonne C indique le nombre de personnes partant du secteur A pour se rendre au secteur C. À l'inverse, l'intersection de la ligne C et de la colonne A indique le nombre de personnes partant du secteur C pour se rendre au secteur A. En sommant les valeurs de chaque ligne, nous obtenons le nombre total de départs par secteur tandis que le nombre d'arrivées est la somme de chaque colonne. Ces opérations peuvent simplement être effectuées avec les fonctions `rowSums` et `colSums`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Chargement des données\nmatriceOD <- read.csv('data/graphique/Quebec_2017_OD_MJ.csv',\n                 header = FALSE, sep = ';') # fichier csv sans entête\n\n# Calcul des sommes en lignes et en colonnes\ntot_depart <- rowSums(matriceOD)\ntot_arrivee <- colSums(matriceOD)\n\n# Création d'un DataFrame avec les valeurs et les noms des secteurs\ndf <- data.frame(depart = tot_depart,\n                 arrivee = tot_arrivee, \n                 secteur = c('Arr. de Beauport (Québec)',\n                            'Arr. de Charlesbourg (Québec)',\n                            'Arr. des Rivières (Québec)',\n                            'Arr. de la Cité-Limoilou (Québec)',\n                            'Arr. de la Haute-Saint-Charles (Québec)',\n                            'Arr. de Sainte-Foy-Sillery-Cap-Rouge (Québec)',\n                            'Arr.de Desjardins (Lévis)',\n                            'Arr. des Chutes–de-la-Chaudière-Est (Lévis)',\n                            'Arr. des Chutes de la Chaudière-Ouest (Lévis)',\n                            'Ceinture Nord',\n                            'Ceinture Sud',\n                            'Hors Territoire'),\n                 code = c('A','B','C','D','E','F','G','H','I','J','K','X'))\n\n# Création des deux graphiques en barre\nplot1 <- ggplot(data = df)+\n  geom_bar(aes(x = code, weight = depart))+\n  labs(subtitle = \"Départs\",\n       x = \"total\",\n       y = \"\")\n\nplot2 <- ggplot(data = df)+\n  geom_bar(aes(x = code, weight = arrivee))+\n  labs(subtitle = \"Arrivées\",\n       x = \"total\",\n       y = \"\")\n\n# Stocker les graphiques dans une liste et composer une figure\nlist_plot <- list(plot1, plot2)\ntot_plot <- ggarrange(plotlist = list_plot, ncol = 1)\n\n# Création d'une légende pour associer le code de chaque secteur \n# à son nom. Pour cela nous concaténons en premier les lettres et les noms.\n# Nous fusionnons ensuite le tout en les séparant par le symbole \\n représentant \n# un saut de ligne.\nnom_secteurs <- paste(df$code, df$secteur, sep= ' : ')\nstring_names <- paste(nom_secteurs, collapse = '\\n')\n\ntitre <- \"Déplacements journaliers moyens en heures de pointe\"\n# Production finale de la figure\nannotate_figure(tot_plot,\n                top = text_grob(titre, face = \"bold\", size = 11, just = \"left\"),\n                right = text_grob(string_names, face = \"italic\", size = 8,\n                                  just = \"left\", x = 0.05) # position du texte\n                )\n```\n\n::: {.cell-output-display}\n![Graphiques en barre simples](03-magiedesgraphiques_files/figure-html/fig-fig344-1.png){#fig-fig344 fig-align='center' width=75%}\n:::\n:::\n\n\nPlutôt que de représenter les arrivées et les départs dans deux graphiques séparés, il est possible de les empiler dans un même graphique en barres. Nous devons au préalable « faire fondre nos données » avec la fonction `melt`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Faire fondre le jeu de données (empiler les colonnes depart et arrivee)\nmelted_df <- melt(df, id.vars = c('code'), measure.vars = c('depart','arrivee'))\nnames(melted_df) <- c('code','deplacement','effectif')\n# Ajouter les accents dans la colonne déplacement\nmelted_df$deplacement <- ifelse(melted_df$deplacement == 'depart', 'départs', 'arrivées')\n# Comparaison du format original et du format \"fondu\"\nhead(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   depart arrivee                                       secteur code\nV1  49241   34777                     Arr. de Beauport (Québec)    A\nV2  48909   36344                 Arr. de Charlesbourg (Québec)    B\nV3  48044   67198                    Arr. des Rivières (Québec)    C\nV4  63132  108138             Arr. de la Cité-Limoilou (Québec)    D\nV5  57367   30859       Arr. de la Haute-Saint-Charles (Québec)    E\nV6  86504  112379 Arr. de Sainte-Foy-Sillery-Cap-Rouge (Québec)    F\n```\n:::\n\n```{.r .cell-code}\nhead(melted_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  code deplacement effectif\n1    A     départs    49241\n2    B     départs    48909\n3    C     départs    48044\n4    D     départs    63132\n5    E     départs    57367\n6    F     départs    86504\n```\n:::\n\n```{.r .cell-code}\n# Réalisation du graphique\nplot1 <- ggplot(data = melted_df)+\n  geom_bar(aes(x = code, weight = effectif, fill = deplacement), color = '#e3e3e3')+\n  scale_fill_manual(values = c(\"#e63946\" , \"#1d3557\"))+\n  labs(title = titre,\n       y = \"Effectifs\",\n       x = \"\",\n       fill = \"Déplacements\")\n\nannotate_figure(plot1, right = text_grob(string_names, face = \"italic\", size = 7,\n                                  just = \"left\", x = 0.05)) # position du texte)\n```\n\n::: {.cell-output-display}\n![Graphique en barre empilée](03-magiedesgraphiques_files/figure-html/fig-fig345-1.png){#fig-fig345 fig-align='center' width=65%}\n:::\n:::\n\n\n### Graphique circulaire {#sec-0328}\n\nUne option directe au graphique en barres est le graphique ou diagramme circulaire, appelé aussi graphique en tarte (pour les personnes à la dent sucrée) ou en camembert (pour celles amatrices de fromage). Il est suffisamment connu et utilisé pour qu'aucune présentation ne s'impose. Pour être exact, un graphique en tarte n'est rien d'autre qu'un graphique en barres dont le système de coordonnées a été modifié. Cela impose cependant de calculer à l'avance la position des étiquettes que nous souhaitons ajouter sur le graphique. Reprenons les données de production mondiale de CO~2~ et calculons les productions totales par région géographique en 2015.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\n# Extraire les données de 2018 pour lesquelles nous connaissons la région\ndata_co2_2015 <- subset(data_co2, data_co2$year == \"2015\" & ! is.na(data_co2$region7))\n\n# Effectuer la somme du CO2 par région\nco2_2015 <- data_co2_2015 %>% \n  group_by(region7) %>% \n  summarise(total_co2 = sum(CO2_kt, na.rm = TRUE))\n\n# Attribuer un code à chaque région pour faciliter la lecture\nco2_2015$code <- c(\"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" , \"G\")\n\n# Modifier l'ordre des données, calculer les proportions et la position des labels\ndf <- co2_2015 %>% \n  arrange(desc(code)) %>%\n  mutate(prop = total_co2 / sum(co2_2015$total_co2) *100) %>%\n  mutate(ypos = cumsum(prop)- 0.5*prop )\n\n# Préparer la légende (pourcentages et vrais noms)\nnom_region <- rev(paste(df$code, \" : \", df$region7, \"(\", round(df$prop,1),\"%)\"))\nstring_region <- paste(nom_region, collapse = '\\n')\n\n# Construire le graphique\nplot1 <- ggplot(df, aes(x = \"\", y = prop, fill = code)) +\n  geom_bar(stat = \"identity\", width=1, color = \"white\") +\n  coord_polar(\"y\", start=0) +\n  theme_void() + \n  theme(legend.position = \"none\") +\n  geom_text(aes(y = ypos, label = code), color = \"white\", size=3) +\n  scale_fill_grey()+\n  labs(title = \"Proportion du CO2 émis en 2015\")\n\n# Ajouter la légende\nannotate_figure(plot1, right = text_grob(string_region, face = \"italic\", size = 9,\n                                  just = \"left\", x = 0.05)) # position du texte)\n```\n\n::: {.cell-output-display}\n![Graphique en tarte](03-magiedesgraphiques_files/figure-html/fig-fig346-1.png){#fig-fig346 fig-align='center' width=65%}\n:::\n:::\n\n\nSi à la place de la géométrie `geom_bar`, vous utilisez `geom_rect`, vous pouvez convertir votre graphique en tarte en graphique en anneau (ou en beigne, pour les personnes à la dent sucrée) : \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Calculer la limite inférieure et supérieure du beigne\ndf$ymax <- cumsum(df$prop)\ndf$ymin <-  c(0, head(df$ymax, n=-1))\n\n# Construire le graphique\nplot1 <- ggplot(df, aes(ymax = ymax, ymin = ymin, \n                        xmax = 4, xmin = 3,\n                        y = prop, fill = code)) +\n  geom_rect(stat = \"identity\", color = \"white\") +\n  coord_polar(\"y\", start=0) +\n  theme_void() + \n  theme(legend.position = \"none\") +\n  geom_text(aes(x = 3.5, y = ypos, label = code), color = \"white\", size=3) +\n  scale_fill_grey()+\n  xlim(c(2,4))+\n  labs(title = \"Proportion du CO2 émis en 2015\")\n\n# Ajouter la légende\nannotate_figure(plot1, right = text_grob(string_region, face = \"italic\", size = 8,\n                                  just = \"left\", x = 0.05)) # position du texte)\n```\n\n::: {.cell-output-display}\n![Graphique en anneau](03-magiedesgraphiques_files/figure-html/fig-fig347-1.png){#fig-fig347 fig-align='center' width=65%}\n:::\n:::\n\n\n## Graphiques spéciaux {#sec-033}\n\nDans cette dernière section, nous abordons des graphiques plus rarement utilisés. Ils sont toutefois très utiles dans certains contextes du fait de leur capacité à synthétiser des informations complexes.\n\n### Graphique en radar {#sec-0331}\n\nLes graphiques en radar (ou en toile d'araignée) sont utilisés pour comparer une série de variables continues pour plusieurs observations ou groupes d'observations. Chaque variable est associée à un axe et chaque observation est représentée avec un polygone. Prenons l'exemple de données relatives aux logements par secteur de recensement dans la région métropolitaine de Montréal en 2016. Nous pourrions souhaiter comparer la moyenne des pourcentages des différents types de logements pour les régions des Laurentides, de la Montérégie, de Laval, de Longueuil et de Montréal. Malheureusement, `ggplot2` ne permet pas de dessiner des graphiques en radar satisfaisants, nous devons donc utiliser le *package* `fmsb`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(fmsb)\n\ndata <- read.csv('data/bivariee/sr_rmr_mtl_2016.csv', header = TRUE, encoding = 'UTF-8')\n\n# Agréger les données au niveau des régions en calculant la moyenne des pourcentages\nvariables <- c(\"MaisonIndi\" , \"App5Plus\" , \"MaisRangee\" , \"AppDuplex\" , \"Proprio\" , \"Locataire\")\n\ndata_region <- data[c(\"Region\", variables)] %>% \n  group_by(Region) %>%\n  summarise_all(.funs = list(mean))\n\n# Gérer le nom des colonnes pour ajuster les données aux besoins de \n# la fonction radachart\nnew_names <- c(\"Region\", paste(variables,\"_mean\", sep = \"\"))\nnames(data_region) <- new_names\ndata_region <- data.frame(data_region)\nrownames(data_region) <- data_region$Region\ndata_region$Region <- NULL\n\n# Ajouter deux lignes aux données avec les valeurs maximales et minimales \n# de chaque colonne. Ces informations aideront la fonction radachart à\n# dessiner chacun des axes du radar\ndata_chart <- rbind(apply(data_region, MARGIN = 2, FUN = max),\n                    apply(data_region, MARGIN = 2, FUN = min),\n                    data_region\n                    )\n\n# Choisir les couleurs pour l'intérieur des polygones (avec transparence)\ncouleurs <- c(\n  rgb(0.94, 0.28, 0.44, 0.25),\n  rgb(1.00, 0.82, 0.40, 0.25),\n  rgb(0.02, 0.84, 0.63, 0.25),\n  rgb(0.07, 0.54, 0.70, 0.25),\n  rgb(0.03, 0.23, 0.30, 0.25)\n)\n\n# Choisir les couleurs pour l'intérieur des polygones (sans transparence)\ncouleurs_contour <- c(\n  rgb(0.94, 0.28, 0.44),\n  rgb(1.00, 0.82, 0.40),\n  rgb(0.02, 0.84, 0.63),\n  rgb(0.07, 0.54, 0.70),\n  rgb(0.03, 0.23, 0.30)\n)\n\n# Dessiner du graphique\nradarchart(data_chart,\n           title = \"Comparaison des types de logements dans la RMR\",\n           pcol = couleurs_contour, pfcol = couleurs,\n           plwd = 2, plty = 1,\n           cglcol = \"grey\", cglty = 1, axislabcol=\"grey\", cglwd=0.8,\n           vlcex = 0.8,\n           vlabels = c(\"maison individuelle\", \"immeuble d'appartements\",\n                       \"maison \\nen rangée\", \"duplex\",\n                       \"propriétaire\", \"locataire\")\n           )\n\n# Ajouter une légende\nlegend(x = 1.3, y = 1, legend = rownames(data_chart[-c(1,2),]), bty = \"n\", \n       pch=20 , col=couleurs , text.col = \"black\", cex = 0.9, pt.cex = 1.5)\n```\n\n::: {.cell-output-display}\n![Graphique en anneau](03-magiedesgraphiques_files/figure-html/fig-fig348-1.png){#fig-fig348 fig-align='center' width=65%}\n:::\n:::\n\n\nÀ la lecture du graphique, nous constatons rapidement que l'île de Montréal a une situation très différente des trois autres régions. Laval se distingue également avec une part importante de logements dans des immeubles d'appartements. Ce type de graphique a pour objectif d'orienter le regard sur de potentielles différences dans un contexte multidimensionnel, mais il présente quelques inconvénients : \n\n* Les échelles de chaque axe sont différentes. Il est donc essentiel de se rapporter aux valeurs exactes pour estimer si les écarts sont importants en termes absolus.\n\n* La superposition de plusieurs polygones peut rendre la lecture difficile. Une solution envisageable est de réaliser un graphique par polygone, mais cela prend beaucoup de place dans un document.\n\n* L'utilisation de polygones donne parfois de fausses impressions d'écarts. Dans le précédent graphique, l'œil est attiré en bas à gauche par le polygone de Montréal qui est très différent des autres. Cependant, les écarts sur l'axe *maison en rangée* sont relativement petits comparativement à l'axe *locataire* situé à l'opposé.\n\n### Diagramme d'accord {#sec-0332}\n\nLes diagrammes d'accord (*chord diagram* en anglais) sont utilisés pour représenter des échanges ou des connexions entre des entités. Il peut s'agir par exemple de marchandises importées / exportées entre pays, des messages envoyés entre personnes via un réseau social, de flux de population, etc. Reprenons nos données de l'*Enquête origine-destination 2017 - Région Québec-Lévis* pour illustrer le tout. Nous utilisons le *package* `chorddiag`, très facile d'utilisation et produisant des graphiques interactifs, pour faciliter grandement la lecture de ce type de graphique. Cependant, ce *package* ne fait pas partie du répertoire CRAN, nous devons l'installer directement depuis *github* avec la fonction `devtools::install_github`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndevtools::install_github('mattflor/chorddiag')\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(chorddiag)\n\n# Chargement des données\nmatriceOD <- read.csv('data/graphique/Quebec_2017_OD_MJ.csv',\n                 header = FALSE, sep = ';') # fichier csv sans entête\n\n# Transformation du DataFrame en matrice\nmatriceOD <- as.matrix(matriceOD)\ncodes <- c('A','B','C','D','E','F','G','H','I','J','K','X')\nsecteurs <- c('Arr. de Beauport',\n            'Arr. de Charlesbourg',\n            'Arr. des Rivières',\n            'Arr. de la Cité-Limoilou',\n            'Arr. de la Haute-St-Charles',\n            'Arr. de Sainte-Foy-Sillery-Cap-Rouge',\n            'Arr.de Desjardins',\n            'Arr. des Chutes–de-la-Chaudière-Est',\n            'Arr. Les Chutes de la-Chaudière-Ouest',\n            'Ceinture Nord',\n            'Ceinture Sud',\n            'Hors Territoire')\n\n# Ajout de noms aux colonnes et aux lignes de la matrice\nrownames(matriceOD) <- secteurs\ncolnames(matriceOD) <- secteurs\n\n# Nous supprimons les trois secteurs Ceinture Nord, Sud et Hors territoire \n# qui comprennent de toute façon peu de déplacements\nmat <- matriceOD[1:8, 1:8]\n\n# Choix aléatoire de couleurs pour les lignes\n# col <- sample(colors(), nrow(mat), replace = FALSE)\n\n# Choix de couleurs \ncol <- c(\"#a491d3\", \"#818aa3\", \"#C5DCA0\", \"#F5F2B8\",\n         \"#F9DAD0\", \"#F45B69\", \"#22181C\", \"#5A0001\")\n\n# Réalisation du graphique : sortie HTLM\nif(knitr::is_html_output()){\n  chorddiag(mat, groupColors = col, showTicks = FALSE,\n        type = 'bipartite', chordedgeColor = 'white',\n        groupnameFontsize = 12, groupnamePadding = 5)\n}\n```\n\n::: {#fig-fig349 .cell-output-display}\n```{=html}\n<div class=\"chorddiag html-widget html-fill-item\" id=\"htmlwidget-879c1f5840631201a81e\" style=\"width:100%;height:480px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-879c1f5840631201a81e\">{\"x\":{\"matrix\":[[0,0,0,0,0,0,0,0,21163,3246,4710,12213,455,4864,481,133],[0,0,0,0,0,0,0,0,2645,20763,6293,10805,925,5543,309,126],[0,0,0,0,0,0,0,0,1376,1720,22274,8538,2547,8611,841,330],[0,0,0,0,0,0,0,0,2217,2696,6244,37369,703,11141,813,393],[0,0,0,0,0,0,0,0,1084,2451,10163,7996,22309,8672,774,413],[0,0,0,0,0,0,0,0,1178,1292,8178,15126,1198,52359,2002,1260],[0,0,0,0,0,0,0,0,169,189,978,2041,86,2534,21266,2877],[0,0,0,0,0,0,0,0,270,196,1556,2580,165,4942,5061,13245],[21163,2645,1376,2217,1084,1178,169,270,0,0,0,0,0,0,0,0],[3246,20763,1720,2696,2451,1292,189,196,0,0,0,0,0,0,0,0],[4710,6293,22274,6244,10163,8178,978,1556,0,0,0,0,0,0,0,0],[12213,10805,8538,37369,7996,15126,2041,2580,0,0,0,0,0,0,0,0],[455,925,2547,703,22309,1198,86,165,0,0,0,0,0,0,0,0],[4864,5543,8611,11141,8672,52359,2534,4942,0,0,0,0,0,0,0,0],[481,309,841,813,774,2002,21266,5061,0,0,0,0,0,0,0,0],[133,126,330,393,413,1260,2877,13245,0,0,0,0,0,0,0,0]],\"options\":{\"type\":\"bipartite\",\"width\":null,\"height\":null,\"margin\":100,\"showGroupnames\":true,\"groupNames\":[\"Arr. de Beauport\",\"Arr. de Charlesbourg\",\"Arr. des Rivières\",\"Arr. de la Cité-Limoilou\",\"Arr. de la Haute-St-Charles\",\"Arr. de Sainte-Foy-Sillery-Cap-Rouge\",\"Arr.de Desjardins\",\"Arr. des Chutes–de-la-Chaudière-Est\",\"Arr. de Beauport\",\"Arr. de Charlesbourg\",\"Arr. des Rivières\",\"Arr. de la Cité-Limoilou\",\"Arr. de la Haute-St-Charles\",\"Arr. de Sainte-Foy-Sillery-Cap-Rouge\",\"Arr.de Desjardins\",\"Arr. des Chutes–de-la-Chaudière-Est\"],\"groupColors\":[\"#a491d3\",\"#818aa3\",\"#C5DCA0\",\"#F5F2B8\",\"#F9DAD0\",\"#F45B69\",\"#22181C\",\"#5A0001\"],\"groupThickness\":0.1,\"groupPadding\":0.03490658503988659,\"groupnamePadding\":[5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5],\"groupnameFontsize\":12,\"groupedgeColor\":null,\"chordedgeColor\":\"white\",\"categoryNames\":null,\"categorynamePadding\":100,\"categorynameFontsize\":28,\"showTicks\":false,\"tickInterval\":1000,\"ticklabelFontsize\":10,\"fadeLevel\":0.1,\"showTooltips\":true,\"showZeroTooltips\":true,\"tooltipNames\":[\"Arr. de Beauport\",\"Arr. de Charlesbourg\",\"Arr. des Rivières\",\"Arr. de la Cité-Limoilou\",\"Arr. de la Haute-St-Charles\",\"Arr. de Sainte-Foy-Sillery-Cap-Rouge\",\"Arr.de Desjardins\",\"Arr. des Chutes–de-la-Chaudière-Est\",\"Arr. de Beauport\",\"Arr. de Charlesbourg\",\"Arr. des Rivières\",\"Arr. de la Cité-Limoilou\",\"Arr. de la Haute-St-Charles\",\"Arr. de Sainte-Foy-Sillery-Cap-Rouge\",\"Arr.de Desjardins\",\"Arr. des Chutes–de-la-Chaudière-Est\"],\"tooltipFontsize\":12,\"tooltipUnit\":\"\",\"tooltipGroupConnector\":\" &#x25B6; \",\"precision\":\"null\",\"clickAction\":null,\"clickGroupAction\":null}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n\nDiagramme d'accord\n:::\n:::\n\nLe graphique permet de remarquer que la plupart des flux s’effectuent au sein d’un même secteur. La majorité des déplacements se font au sein du secteur Sainte-Foy (segment rouge central). Nous pouvons cependant constater que les secteurs des Rivières, de la Cité-Limoilou et de la Haute-Saint-Charles attirent une plus grande quantité et diversité de flux. Si vous lisez ce livre dans un navigateur web (et pas au format *pdf*), le graphique est interactif! En plaçant votre souris sur un lien, vous verrez s'afficher le nombre de déplacements qu'il représente.\n\n### Nuage de mots {#sec-0333}\n\nUn nuage de mots est un graphique utilisé en analyse de texte pour représenter les mots les plus importants d'un document. Mesurer l'importance des termes dans un document est une discipline à part entière (*Natural Language Processing*). Nous proposons un simple exemple ici avec la méthode *TextRank* (basée sur la théorie des graphes) proposée par @mihalcea2004textrank et implémentée dans le *package* `textrank`. Nous avons également besoin des *packages* `udpipe` (fournissant des dictionnaires linguistiques), `RColorBrewer` (pour sélectionner une palette de couleurs) et `wordcloud2` (pour générer le graphique). En guise d'exemple, nous avons choisi d'extraire les textes de deux schémas d'aménagement et de développement (SAD), ceux des agglomérations de Québec et de Montréal en vigueur en 2020. Il s'agit de deux documents de planification définissant les lignes directrices de l'organisation physique du territoire des municipalités régionales de comté (MRC) ou des agglomérations. Pour ces deux documents, nous nous concentrons sur le chapitre portant sur les grandes orientations d'aménagement et de développement, soit les pages 30 à 135 pour Québec et 30 à 97 pour Montréal. Pour extraire les textes des fichiers *pdf*, nous utilisons le *package* `pdftools`.\n\nNous devons donc réaliser les étapes suivantes pour produire le nuage de mots : \n\n1. Extraire les sections qui nous intéressent des fichiers *pdf*.\n2. Extraire le texte de ces sections.\n3. Retirer les caractères représentant les sauts de lignes et les sauts de paragraphes (`\\n` et `\\r`).\n4. Concaténer tout le texte en une seule longue chaîne de caractère.\n5. Utiliser un dictionnaire pour déterminer la nature des mots du texte (nom, adjectif, verbe, etc.).\n6. Utiliser l'algorithme *TextRank* pour identifier les mots clefs.\n7. Nettoyer les erreurs potentielles parmi les mots clefs.\n8. Construire le nuage de mots.\n\nNotez que toutes ces étapes de nettoyage ne seraient pas nécessaires si nous utilisions un simple fichier texte comme point de départ. Cependant, comme il est plus courant de rencontrer des fichiers *pdf*, cet exercice est donc davantage révélateur de la difficulté réelle de la réalisation d'un nuage de mots.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(wordcloud2)\nlibrary(udpipe)\nlibrary(RColorBrewer)\nlibrary(pdftools)\nlibrary(textrank)\n\n# Étape 1 : extraire les sections pertinentes des fichiers pdf\nextrait_qc <- pdf_subset(\"data/graphique/SAD_quebec.pdf\", pages = c(30:135),\n                         output = \"data/graphique/SAD_quebec_ext.pdf\")\nextrait_mtl <- pdf_subset(\"data/graphique/SAD_montreal.pdf\", pages = c(30:97),\n                          output = \"data/graphique/SAD_montral_ext.pdf\")\n\n# Étape 2 : extraire le texte des fichiers pdf sous forme de vecteur de texte\nfile_qc <- pdf_text(extrait_qc)\nfile_mtl <- pdf_text(extrait_mtl)\n\n# Étape 3 : retirer les sauts de lignes et les paragraphes\nfile_qc <- gsub(\"\\r\" , \"\", x = file_qc)\nfile_qc <- gsub(\"\\n\" , \"\", x = file_qc)\n\nfile_mtl <- gsub(\"\\r\" , \"\", x = file_mtl)\nfile_mtl <- gsub(\"\\n\" , \"\", x = file_mtl)\n\n# Étape 4 : créer une seule longue chaîne de caractères\n# à partir des vecteurs de texte\ntext_qc <- paste(file_qc, collapse = \" \")\ntext_mtl <- paste(file_mtl, collapse = \" \")\n\n# charger le modèle linguistique français\nmodel <- udpipe_load_model('data/graphique/french-sequoia-ud-2.4-190531.udpipe')\n\n# pour télécharger le modèle si ce n'est pas encore fait : \n# model <- udpipe_download_model(\"french-sequoia\")\n# model <- udpipe_load_model(model)\n\n# Étape 5 : analyse de la nature des mots du texte avec le dictionnaire fr\n# Nous obtenons des DataFrames décrivant les mots des textes\nannote_qc <- udpipe_annotate(model, text_qc)\ndf_qc <- data.frame(annote_qc)\n\nannote_mtl <- udpipe_annotate(model, text_mtl)\ndf_mtl <- data.frame(annote_mtl)\n\n# Étape 6 : utilisation de la méthode TextRank\nstats_qc <- textrank_keywords(df_qc$lemma,\n                  relevant = df_qc$upos %in% c(\"NOUN\", \"ADJ\"), ngram_max = 2)\n\nstats_mtl <- textrank_keywords(df_mtl$lemma,\n                  relevant = df_mtl$upos %in% c(\"NOUN\" , \"ADJ\"), ngram_max = 2)\n\n# Étape 7 : nettoyer les coquilles dans les mots clefs \n# Note : nous faisons ici le choix de garder des mots clefs uniques (ngram == 1)\n# Il serait aussi possible de garder des associations de plusieurs mots\ndfstats_qc <- subset(stats_qc$keywords, stats_qc$keywords$ngram == 1 &\n                       nchar(stats_qc$keywords$keyword)>2)\ndfstats_qc$keyword <- gsub(\"d’\" , \"\", dfstats_qc$keyword, fixed = TRUE)\ndfstats_qc$keyword <- gsub(\"l’\" , \"\", dfstats_qc$keyword, fixed = TRUE)\n\ndfstats_mtl <- subset(stats_mtl$keywords, stats_mtl$keywords$ngram == 1 &\n                        nchar(stats_mtl$keywords$keyword)>2)\ndfstats_mtl$keyword <- gsub(\"d’\" , \"\", dfstats_mtl$keyword, fixed = TRUE)\ndfstats_mtl$keyword <- gsub(\"l’\" , \"\", dfstats_mtl$keyword, fixed = TRUE)\n\n# Étape 8 : réaliser les nuages de mots\ncouleurs <- sample(brewer.pal(12, \"Paired\")) # mise en désordre des couleurs\n\nwordcloud2(data = dfstats_mtl[c(\"keyword\", \"freq\")],\n           color = couleurs, size = 0.5, shuffle = FALSE)\n\nwordcloud2(data = dfstats_qc[c(\"keyword\", \"freq\")],\n           color = couleurs, size = 0.6, shuffle = FALSE)\n```\n:::\n\n\n![Nuage de mots pour le SAD de Montréal](images/Chap03/nuage_mtl.png){#fig-fig350 width=\"85%\" fig-align=\"center\"}\n\n![Nuage de mots pour le SAD de Québec](images/Chap03/nuage_qc.png){#fig-fig351 width=\"85%\" fig-align=\"center\"}\n\nNotez qu'à chaque génération du nuage de mots, vous obtiendrez une disposition différente. N'hésitez pas à en essayer plusieurs jusqu'à ce que vous trouviez celle qui vous semble optimale.\n\n### Carte proportionnelle {#sec-0334}\n\nUne carte proportionnelle ou carte à cases (*treemap* en anglais) est un graphique permettant de représenter une quantité partagée entre plusieurs observations structurées dans une hiérarchie de groupe. Le jeu de données portant sur les émissions de CO~2~ se prête tout à fait à une représentation par *treemap*. La variable de quantité est bien sûr les émissions de CO~2~ par pays; ces pays sont regroupés dans un premier ensemble de régions (découpage en 23 régions), qui elles-mêmes sont regroupées dans des régions plus larges (découpage en sept régions). Pour construire un *treemap*, nous allons utilisons le *package* `treemap`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(treemap)\nlibrary(RColorBrewer)\n\n# extraire les données de CO2 en 2015\ndata_co2_2015 <- subset(data_co2, data_co2$year == \"2015\" & ! is.na(data_co2$region7))\n\n# construire le treemap\n\ntreemap(data_co2_2015, index = c(\"region7\" , \"region23\"),\n    vSize = \"CO2_kt\", type = \"index\",\n    title = \"CO2 rejetés par pays en 2015\",\n    fontsize.labels=c(12,8), # taille des étiquettes              \n    fontcolor.labels=c(\"white\" , \"black\"), # couleur des étiquettes\n    fontface.labels=c(2,1), # style des polices\n    bg.labels = 0, # arrière-plan des étiquettes\n    align.labels=list(\n        c(\"center\", \"center\"), \n        c(\"right\", \"bottom\")\n        ),  # localisation des étiquettes dans les boîtes\n    overlap.labels=0.5, # tolérance de superposition\n    inflate.labels = FALSE, # agrandir la taille des étiquettes ou non\n    palette = brewer.pal(7,'Paired')\n)\n```\n\n::: {.cell-output-display}\n![Treemap](03-magiedesgraphiques_files/figure-html/fig-fig352-1.png){#fig-fig352 fig-align='center' width=90%}\n:::\n:::\n\n\n## Cartes {#sec-034}\n\nToute comme un graphique, une carte est aussi une illustration visuelle. Avec la généralisation des données géographiques, il peut être utile de savoir représenter ce type de données. Si R n'est pas un logiciel de cartographie, il est possible de réaliser des cartes assez facilement, directement avec `ggplot2`. Nous avons cependant une préférence pour le *package* `tmap`, qui propose de nombreuses fonctionnalités. Pour tracer des cartes, `tmap` et `ggplot2` ont besoin d'utiliser un format de données comprenant la géométrie (polygones, lignes ou points), la localisation et le système de projection des entités spatiales étudiées. Le format de fichier le plus courant pour ce type de données est le *shapefile* (*.shp*), mais vous pourrez parfois croiser des fichiers *geojson* (*.js*), ou encore *geopackages* (*.gpkg*). Pour lire ces fichiers, il est possible d'utiliser la fonction `readOGR` du *package* `rgdal`, ou la fonction `st_read` du *package* `sf`. Notez ici que ces deux fonctions ne produisent pas de *DataFrame*, mais respectivement un *SpatialDataFrame* et un objet `sf` (*spatial feature collection*). Sans entrer dans les détails, sachez que deux *packages* permettent de manipuler des objets spatiaux dans R : le traditionnel `sp` (avec les *SpatialDataFrames*) et le plus récent `sf` (avec les *spatial feature collections*). Il est assez facile de convertir un objet de `sp` vers `sf` (et inversement) et cette opération est souvent nécessaire, car de nombreux *packages* dédiés à l'analyse spatiale utilisent l'un ou l'autre des formats. Dans le cas de `tmap`, des objets `sp` et `sf` peuvent être utilisés sans distinction. En revanche, pour cartographier directement avec `ggplot2`, il est plus facile d'utiliser un objet de type `sf`. Toutefois, nous vous recommandons fortement d'utiliser le *package* `sf`, puisque `sp` (et son format *SpatialDataFrame*) est progressivement délaissé dans R.\n\nUne carte thématique permet de représenter la répartition spatiale de variables qualitatives ou quantitatives. Nous la distinguons des cartes topographiques, dont l'objectif est de représenter la localisation d'objets spécifiques (route, habitation, rivière, lac, etc.). La première est relativement facile à construire dans R, car elle se limite à quelques symboles relativement simples. Pour la seconde, nous préférons généralement utiliser un logiciel comme [QGIS](https://qgis.org/en/site/){target=\"_blank\"}.\n\nCréons une carte thématique à partir des données de densité de végétation sur l'île de Montréal avec les *packages* `ggplot2` puis `tmap`.\n\nAvec `ggplot2`, nous avons aussi besoin des *packages* `classInt` pour calculer les intervalles des classes et `ggsn` pour afficher une échelle.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(classInt)\nlibrary(ggspatial)\n\n# Chargement des données\nspatialdf <- st_read(\"data/bivariee/IlotsVeg2006.shp\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `IlotsVeg2006' from data source \n  `C:\\Users\\appariciop\\OneDrive - USherbrooke\\Articles Publies ne pas supprimer\\_Livres\\BolR_MethodesQuantitatives\\data\\bivariee\\IlotsVeg2006.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 10213 features and 12 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 267518.7 ymin: 5029292 xmax: 306663.7 ymax: 5062652\nProjected CRS: NAD83 / MTM zone 8\n```\n:::\n\n```{.r .cell-code}\n# Création d'une discrétisation en 7 classes égales\nvalues <- c(max(spatialdf$ArbPct)+0.01, spatialdf$ArbPct)\n\nquant <- classIntervals(values, n = 7,\n                        style = \"quantile\",\n                        intervalClosure = 'right')\n\nspatialdf$class_col <- cut(spatialdf$ArbPct, breaks = quant$brks, right = FALSE)\n\n# Cartographie avec ggplot2\nggplot(data = spatialdf) + \n  geom_sf(aes(fill = class_col), color = rgb(0,0,0,0))+\n  scale_fill_brewer(palette = \"Greens\")+\n  labs(title = \"Végétation dans les îlos de recensement\",\n       'fill' = 'Densité de la canopée (%)')+\n  theme(axis.line=element_blank(), axis.text.x = element_blank(),\n        axis.text.y = element_blank(), axis.ticks=element_blank(),\n        axis.title.x = element_blank(), axis.title.y = element_blank(),\n        panel.background=element_blank(),\n        panel.border=element_blank(), panel.grid.major=element_blank(),\n        panel.grid.minor=element_blank(), plot.background=element_blank(),\n        legend.key.size = unit(0.5, \"cm\"))+\n  annotation_scale()\n```\n\n::: {.cell-output-display}\n![Carte thématique avec ggplot2](03-magiedesgraphiques_files/figure-html/fig-fig353-1.png){#fig-fig353 fig-align='center' width=85%}\n:::\n:::\n\n\nIl est possible d'arriver à un résultat similaire avec `tmap` avec moins de code! \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tmap)\n\ncolors <- brewer.pal(7,\"Greens\")\ntm_shape(spatialdf) +\n  tm_polygons(\"ArbPct\", palette = colors, border.alpha = 0,\n            n = 7, style = 'quantile',\n            title = \"Densité de la canopée (%)\")+\n  tm_scale_bar(breaks = c(0,5,10)) + \n  tm_layout(title = \"Végétation dans les îlos de recensement\",\n            attr.outside = TRUE, frame = FALSE)\n```\n\n::: {.cell-output-display}\n![Carte thématique avec tmap](03-magiedesgraphiques_files/figure-html/fig-fig354-1.png){#fig-fig354 fig-align='center' width=85%}\n:::\n:::\n\n\nLes graphiques créés par `tmap` ne peuvent malheureusement pas être combinés avec la fonction `ggarrange`, mais `tmap` dispose de sa propre fonction `tmap_arrange` si vous souhaitez combiner plusieurs cartes.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tmap)\ncolors <- brewer.pal(7,\"Greens\")\ncolors2 <- brewer.pal(7,\"Reds\")\n\ncarte1 <- tm_shape(spatialdf) +\n  tm_polygons(\"ArbPct\", palette = colors, border.alpha = 0,\n            n = 7, \n\t\t\tstyle = \"quantile\",\n            title = \"Densité de la canopée (%)\") +\n  tm_scale_bar(breaks = c(0,5,10)) + \n  tm_layout(attr.outside = TRUE, frame = FALSE)\n\ncarte2 <- tm_shape(spatialdf) +\n  tm_polygons(\"LogDens\", palette = colors2, border.alpha = 0,\n            n = 7, \n\t\t\tstyle = \"quantile\",\n            title = \"Densité de logement\") + \n  tm_scale_bar(breaks = c(0,5,10)) + \n  tm_layout(attr.outside = TRUE, frame = FALSE)\n\ntmap_arrange(carte1, carte2, ncol = 2)\n```\n\n::: {.cell-output-display}\n![Combiner des cartes avec tmap](03-magiedesgraphiques_files/figure-html/fig-fig355-1.png){#fig-fig355 fig-align='center' width=85%}\n:::\n:::\n\n\n\n::: bloc_aller_loin\n::: bloc_aller_loin-header\n::: bloc_aller_loin-icon\n:::\n\n**Construction de cartes : aller plus loin avec `tmap`...**\n:::\n\n::: bloc_aller_loin-body\nPour explorer les multitudes possibilités du *package* `tmap`, nous vous recommandons les ressources suivantes :\n\n-   [La section intitulée *Cartographie avec R*](https://serieboldr.github.io/MethodesAnalyseSpatiale/01-ManipulationDonneesSpatiales.html#sec-016) du manuel [*Méthodes d’analyse spatiale : un grand bol d’R*](https://serieboldr.github.io/MethodesAnalyseSpatiale/).\n\n-   L'excellente vignette intitulée [*`tmap`: get started!*](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html)\n\n-   [*Visualizing Spatial Data in R with tmap*](http://www.wvview.org/os_sa/10_Maps_with_tmap.html#visualizing-spatial-data-in-r-with-tmap).\n\n-   [*Making Maps with R*](https://bookdown.org/nicohahn/making_maps_with_r5/docs/introduction.html).\n\n-   Le chapitre [*Making maps with R*](https://geocompr.robinlovelace.net/adv-map.html) du livre [*Geocomputation with R*](https://geocompr.robinlovelace.net/index.html).\n:::\n:::\n\n\n\n## Exportation des graphiques {#sec-035}\n\nTous les graphiques que nous avons construits dans ce chapitre peuvent être exportés assez facilement. Dans RStudio, vous pouvez directement cliquer sur le bouton *Export* (@fig-fig356) pour enregistrer votre figure au format image ou au format *pdf* (vectoriel). Notez qu'avec la seconde option, vous pourrez retoucher votre graphique avec un logiciel externe comme *Inkscape* ou *Illustrator*.\n\n![Exporter un graphique dans RStudio](images/Chap03/export.jpg){#fig-fig356 width=\"40%\" fig-align=\"center\"}\n\nLorsque vous créez un graphique avec `ggplot2`, il est aussi possible de l'exporter avec la fonction `ggsave`. Cette fonctionnalité est très pratique lorsque vous souhaitez automatiser la production de graphiques et ne pas avoir à tous les exporter à la main.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(iris)\n\nplot1 <- ggplot() +\n  geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris)\n\nggsave(filename = 'graphique.pdf',\n       path = 'mon/dossier',\n       plot = plot1,\n       width = 10, height = 10, units = \"cm\")\n```\n:::\n\nPour les graphiques n'étant pas réalisés avec `ggplot2`, la solution de remplacement à la fonction `ggsave` est l'ensemble de fonctions `png`, `bmp`, `jpeg`, `tiff` et `pdf`, qui permettent d'exporter n'importe quel graphique dans ces différents formats. Le processus comprend trois étapes : \n\n1. Ouvrir une connexion vers le fichier dans lequel le graphique sera exporté avec une des fonctions `png`, `bmp`, `jpeg`, `tiff` et `pdf`.\n\n2. Réaliser son graphique comme si nous souhaitions l'afficher dans RSudio. Il n'apparaîtra cependant pas, car il sera écrit dans le fichier en question à la place.\n\n3. Fermer la connexion au fichier avec la fonction `dev.off` pour définitivement enregistrer le graphique.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(iris)\n\n# 1. Ouvrir la connexion\npng(filename = 'mon/dossier/graphique.png')\n\n# 2. Afficher le graphique\nggplot() +\n  geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris)\n\n# 3. fermer la connexion\ndev.off()\n```\n:::\n\n\n## Conclusion sur les graphiques {#sec-036}\n\nVous avez pu constater que les capacités de représentation graphique de R sont vastes et pourtant nous n'avons qu'observé la partie émergée de l'iceberg dans ce chapitre. Il est également possible de réaliser une visualisation en 3D dans R (`plot3D`, `rgl`), d'animer des graphiques pour en faire des *GIF* ou des vidéos (`gganimate`), de rendre des graphiques interactifs, ou même de construire des plateformes de visualisation de données disponibles en ligne (`shiny`). Vous continuerez à découvrir de nouvelles formes de représentations au fur et à mesure de votre pratique, en apprenant de nouvelles méthodes nécessitant des visualisations spécifiques.\n\nVoici également deux références très utiles qui nous ont notamment aidé à construire ce chapitre : \n\n* [The R Graph Gallery](https://www.r-graph-gallery.com/){target=\"_blank\"}, probablement **LE** site web proposant le plus de matériel sur la réalisation des graphiques dans R.\n* [Data to viz](https://www.data-to-viz.com/){target=\"_blank\"}, si vous ne savez pas quel graphique pourrait le mieux correspondre à vos données, Data to viz est là pour vous aider. Vous y trouverez un arbre de décision pour vous indiquer quel graphique utiliser dans quelle situation, ainsi que de nombreux conseils sur la visualisation de données.\n",
    "supporting": [
      "03-magiedesgraphiques_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"site_libs/htmltools-fill-0.5.8.1/fill.css\" rel=\"stylesheet\" />\r\n<script src=\"site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\r\n<script src=\"site_libs/d3-4.13.0/d3.min.js\"></script>\r\n<script src=\"site_libs/d3-tip-0.8.1/index.js\"></script>\r\n<link href=\"site_libs/chorddiag-0.1.2.9000/chorddiag.css\" rel=\"stylesheet\" />\r\n<script src=\"site_libs/chorddiag-0.1.2.9000/chorddiag.js\"></script>\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}