{"title":"Prise en main de R","markdown":{"headingText":"Prise en main de R","headingAttr":{"id":"sec-chap01","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\nDans ce chapitre, nous revenons brièvement sur l’histoire de R et la philosophie qui entoure le logiciel. Nous donnons quelques conseils pour son installation et la mise en place d’un environnement de développement. Nous présentons les principaux objets qui sous-tendent le travail effectué avec R (*DataFrame*, vecteur, matrice, etc.) et comment les manipuler avec des exemples appliqués. Si vous maîtrisez déjà R, nullement besoin de lire ce chapitre!\n\n::: bloc_package\n::: bloc_package-header\n::: bloc_package-icon\n:::\n**Liste des *packages* utilisés dans ce chapitre**\n:::\n::: bloc_package-body\n* Pour importer des fichiers externes :\n  - `foreign` pour entre autres les fichiers *dbase* et ceux des logiciels SPSS et Stata.\n  - `sas7bdat` pour les fichiers du logiciel SAS.\n  - `xlsx` pour les fichiers Excel.\n* Pour manipuler des chaînes de caractères et des dates : \n  - `stringr` pour les chaînes de caractères.\n  - `lubridate` pour les dates.\n* Pour manipuler des données :\n  - `dplyr` du `tidyverse` propose une grammaire pour manipuler et structurer des données.\n:::\n:::\n\n\n## Histoire et philosophie de R{#sec-011}\n\nR est à la fois un langage de programmation et un logiciel libre (sous la licence publique générale GNU) dédié à l'analyse statistique et soutenu par une fondation : _R Foundation for Statistical Computing_. Il est principalement écrit en C et en Fortran, deux langages de programmation de « bas niveau », proches du langage machine. À l'inverse, R est un langage de « haut niveau », car plus proche du langage humain.\n\n\nR a été créé par Ross Ihaka et Robert Gentleman à l'Université d'Auckland en Nouvelle-Zélande. Si vous avez un jour l'occasion de passer dans le coin, une plaque est affichée dans le département de statistique de l'université; ça mérite le détour (@fig-Plaque). Une version expérimentale a été publiée en 1996, mais la première version stable ne date que de 2000. Il s'agit donc d'un logiciel relativement récent si nous le comparons à ses concurrents SPSS (1968), SAS (1976) et Stata (1984).\n\n\n![Lieu de pèlerinage de R](images/Chap01/plaque.jpg){#fig-Plaque width=\"40%\" fig-align=\"center\"}\n\n\nR a cependant réussi à s'imposer tant dans le milieu de la recherche que dans le secteur privé. Pour s'en convaincre, il suffit de lire l'excellent article concernant la popularité des logiciels d'analyse de données tiré du site [r4stats.com](http://r4stats.com/articles/popularity){target=\"_blank\"} (@fig-ArticlesR).\n\n![Nombre d'articles trouvés sur Google Scholar (source : Robert A. Muenchen)](images/Chap01/r_citations.jpg){#fig-ArticlesR width=\"50%\" fig-align=\"center\"}\n\nLes nombreux atouts de R justifient largement sa popularité sans cesse croissante : \n\n* R est un logiciel à code source ouvert (*open source*) et ainsi accessible à tous gratuitement.\n\n* Le développement du langage R est centralisé, mais la communauté peut créer et partager facilement des *packages*. Les nouvelles méthodes sont ainsi rapidement implémentées comparativement aux logiciels propriétaires.\n\n* R est un logiciel multiplateforme, fonctionnant sur Linux, Unix, Windows et Mac.\n\n* Comparativement à ses concurrents, R dispose d'excellentes solutions pour manipuler des données et réaliser des graphiques.\n\n* R dispose de nombreuses interfaces lui permettant de communiquer, notamment avec des systèmes de bases de données SQL et non SQL (MySQL, PostgresSQL, MongoDB, etc.), avec des systèmes de *big data* (Spark, Hadoop), avec des systèmes d'information géographique (QGIS, ArcGIS) et même avec des services en ligne comme Microsoft Azure ou Amazon AWS.\n\n* R est un langage de programmation à part entière, ce qui lui donne plus de flexibilité que ses concurrents commerciaux (SPSS, SAS, STATA). Avec R, vous pouvez accomplir de nombreuses tâches : monter un site web, créer un robot collectant des données en ligne, combiner des fichiers PDF, composer des diapositives pour une présentation ou même éditer un livre (comme celui-ci), mais aussi, et surtout, réaliser des analyses statistiques.\n\nUn des principaux attraits de R est la quantité astronomique de *packages* actuellement disponibles. **Un *package* est un ensemble de nouvelles fonctionnalités développées par des personnes utilisatrices de R et mises à disposition de l'ensemble de la communauté**. Par exemple, le *package* `ggplot2` est dédié à la réalisation de graphiques; les *packages* `data.table` et `dplyr` permettent de manipuler des tableaux de données; le *package* `car` offre de nombreux outils pour faciliter l'analyse de modèles de régressions, etc. Ce partage de *packages* rend accessible à tous des méthodes d'analyses complexes et récentes et favorise grandement la reproductibilité de la recherche. Cependant, ce fonctionnement implique quelques désavantages : \n\n* Il existe généralement plusieurs *packages* pour effectuer le même type d'analyse, ce qui peut devenir une source de confusion.\n\n* Certains *packages* cessent d'être mis à jour au fil des années, ce qui nécessite de trouver des solutions de rechange (et ainsi apprendre la syntaxe de nouveaux *packages*).\n\n* Il est impératif de s'assurer de la fiabilité des *packages* que vous souhaitez utiliser, car n'importe qui peut proposer un *package*.\n\nIl nous semble important de relativiser d'emblée la portée du dernier point. Il est rarement nécessaire de lire et d'analyser le code source d'un *package* pour s'assurer de sa fiabilité. Nous ne sommes pas des spécialistes de tous les sujets et il peut être extrêmement ardu de comprendre la logique d'un code écrit par une autre personne. Nous vous recommandons donc de privilégier l'utilisation de *packages* qui :\n\n* ont fait l'objet d'une publication dans une revue à comité de lecture ou qui ont déjà été cités dans des études ayant fait l'objet d'une publication revue par les pairs;\n\n* font partie de projets comme [ROpensci](https://ropensci.org/){target=\"_blank\"} prônant la vérification  par les pairs ou subventionnés par des organisations comme [R Consortium](https://www.r-consortium.org/){target=\"_blank\"};\n\n* sont disponibles sur l'un des deux principaux répertoires de *packages* R, soit [CRAN](https://cran.r-project.org/){target=\"_blank\"} et [Bioconductor](https://www.bioconductor.org/){target=\"_blank\"}.\n\nToujours pour nuancer notre propos, il convient de distinguer *package* de *package*! Certains d'entre eux sont des ensembles très complexes de fonctions permettant de réaliser des analyses poussées alors que d'autres sont des projets plus modestes dont l'objectif principal est de simplifier le travail des personnes utilisant R. Ces derniers ressemblent à de petites boîtes à outils et font généralement moins l'objet d'une vérification intensive.\n\nPour conclure cette section, l'illustration partagée sur Twitter par Darren L Dahly résume avec humour la force du logiciel R et de sa communauté\n(@fig-fig03) : R apparaît clairement comme une communauté hétéroclite, mais diversifiée et adaptable.\n\n\n![Métaphore sur les langages et programmes d'analyse statistique](images/Chap01/softwares_and_cars.jpeg){#fig-fig03 width=\"60%\" fig-align=\"center\"}\n\n\nDans ce livre, nous détaillons les *packages* utilisés dans chaque section avec un encadré spécifique.\n\n\n::: bloc_package\n::: bloc_package-header\n::: bloc_package-icon\n:::\n\n**Bloc *packages***\n:::\n\n::: bloc_package-body\nHabituellement localisé au début d'un chapitre, il comprend la liste des *packages* R utilisés pour un chapitre.\n:::\n:::\n\n\n## Environnement de travail{#sec-012}\n\nDans cette section, nous vous proposons une visite de l'environnement de travail de R.\n\n### Installation de R {#sec-0121}\n\nLa première étape pour travailler avec R est bien sûr de l'installer. Pour cela, il suffit de visiter le site web de [CRAN](https://cran.r-project.org/){target=\"_blank\"} et de télécharger la dernière version de R en fonction de votre système d'exploitation : Windows, Linux ou Mac. Une fois installé, si vous démarrez R immédiatement, vous aurez accès à une console, plutôt rudimentaire, attendant sagement vos instructions (@fig-fig05).\n\n![Console de base de R](images/Chap01/r_console.jpeg){#fig-fig05 width=\"85%\" fig-align=\"center\"}\n\nNotez que vous pouvez aussi télécharger des versions plus anciennes de R en allant sur ce [lien](https://cran.r-project.org/bin/windows/base/old/){target=\"_blank\"}. Cela peut être intéressant lorsque vous voulez reproduire des résultats d'une autre étude ou que certains *packages* ne sont plus disponibles dans les nouvelles versions.\n\n### Environnement RStudio{#sec-0122}\n\nRares sont les adeptes de R qui préfèrent travailler directement avec la console classique. Nous vous recommandons vivement d'utiliser RStudio, un environnement de développement (*IDE*) dédié à R offrant une intégration très intéressante d'une console, d'un éditeur de texte, d'une fenêtre de visualisation des données et d'une autre pour les graphiques, d'un accès à la documentation, etc. En d'autres termes, si R est un vélo minimaliste, RStudio permet d'y rajouter des freins, des vitesses, un porte-bagages, des garde-boues et une selle confortable. Vous pouvez [télécharger](https://rstudio.com/products/rstudio/download){target=\"_blank\"} et installer RStudio sur Windows, Linux et Mac. La version de base est gratuite, mais l'entreprise qui développe ce logiciel propose aussi des versions commerciales du logiciel qui assurent essentiellement une assistance technique. Il existe d'autres environnements de développement pour travailler avec R (Visual Studio Code, Jupyter, Tinn-R, Radiant, RIDE, etc.), mais RStudio offre à ce jour la meilleure option en termes de facilité d'installation, de prise en main et de fonctionnalités proposées (voir l'interface de RStudio à la @fig-fig06).\n\n\n![Environnement de base de RStudio](images/Chap01/r_studio_01.jpeg){#fig-fig06 width=\"85%\" fig-align=\"center\"}\n\nAvant d'aller plus loin, notez que : \n\n* La console actuellement ouverte dans RStudio vous informe de la version de R que vous utilisez. Vous pouvez en effet avoir plusieurs versions de R installées sur votre ordinateur et passer de l'une à l'autre avec RStudio. Pour cela, naviguez dans l'onglet *Tools/Global Options* et dans le volet  *General*, puis sélectionnez la version de R que vous souhaitez utiliser.\n\n* L'aspect de RStudio peut être modifié en naviguant dans l'onglet *Tools/Global Options* et dans le volet *Appearance*. Nous avons une préférence pour le mode sombre avec le style *pastel on dark* (@fig-fig07), mais libre à vous de choisir le style qui vous convient.\n\n\n![RStudio avec le style pastel on dark](images/Chap01/r_studio_02.jpeg){#fig-fig07 width=\"85%\" fig-align=\"center\"}\n\nUne fois ces détails réglés, vous pouvez ouvrir votre première feuille de code en allant dans l'onglet *File/New File/R Script*. Votre environnement est maintenant découpé en quatre fenêtres (@fig-fig08) : \n\n1. L'éditeur de code, vous permettant d'écrire le script que vous voulez exécuter et de garder une trace de votre travail. Ce script peut être enregistré sur votre ordinateur avec l'extension **.R**, mais ce n'est qu'un simple fichier texte.\n\n2. La console vous permettant d'exécuter votre code R et de voir les résultats s'afficher au fur et à mesure.\n\n3. La fenêtre d'environnement vous montrant les objets, les fonctions et les jeux de données actuellement disponibles dans votre session (chargés dans la mémoire vive).\n\n4. La fenêtre de l'aide, des graphiques et de l'explorateur de fichiers. Vous pouvez accéder ici à la documentation de R et des *packages* que vous utilisez, aux sorties graphiques que vous produisez et aux dossiers de votre environnement de travail.\n\n\n![Fenêtres de RStudio](images/Chap01/r_studio_03.jpeg){#fig-fig08 width=\"85%\" fig-align=\"center\"}\n\nPrenons un bref exemple : tapez la syntaxe suivante dans l'éditeur de code (fenêtre 1 à la @fig-fig08) : \n\n```{r}\n#| label: \"ma_somme\"\nma_somme <- 4+4\n```\n\nSélectionnez ensuite cette syntaxe (mettre en surbrillance avec la souris) et utilisez le raccourci *Ctrl+Entrée* ou cliquez sur le bouton *Run* (avec la flèche verte) pour envoyer cette syntaxe à la console qui l'exécutera immédiatement. Notez que rien ne se passe tant que le code n'est pas envoyé à la console. Il s'agit donc de deux étapes distinctes : écrire son code, puis l'envoyer à la console. Constatez également qu'un objet *ma_somme* est apparu dans votre environnement et que sa valeur est bien 8. Votre console se « souvient » de cette valeur : elle est actuellement stockée dans votre mémoire vive sous le nom de *ma_somme* (@fig-fig09).\n\n\n![Exécuter du code dans RStudio](images/Chap01/r_studio_04.jpeg){#fig-fig09 width=\"85%\" fig-align=\"center\"}\n\nPour conclure cette section, nous vous invitons à enregistrer votre première syntaxe R (*File/Save As*) dans un fichier **.R** que vous pouvez appeler `mon_premier_script.R` par exemple. Fermez ensuite RStudio, redémarrez-le et ouvrez (*File/Open File*) votre fichier `mon_premier_script.R`. Vous pouvez constater que votre code est toujours présent, mais que votre environnement est vide tant que vous n'exécutez pas votre syntaxe. En effet, lorsque vous fermez RStudio, l'environnement est vidé pour libérer de la mémoire vive. Cela peut poser problème lorsque certains codes sont très longs à exécuter, nous verrons donc plus tard comment enregistrer l'environnement en cours pour le recharger par la suite.\n\n\n### Installation et chargement un *package*{#sec-0123}\n\nDans la section sur la Philosophie de R, nous avons souligné la place centrale jouée par les *packages*. Notez que les termes *paquet* et plus rarement *librairie* sont parfois utilisés en français. Voyons ensemble comment installer un *package*, par exemple celui intitulé `lubridate`, qui nous permettra plus tard de manipuler des données temporelles.\n\n#### Installation d'un *package* depuis *CRAN*{#sec-01231}\n\nPour installer un *package*, il est nécessaire d'être connecté à Internet puisque R va accéder au répertoire de *packages* *CRAN* pour télécharger le *package* et l'installer sur votre machine. Cette opération est réalisée avec la fonction `install.packages`.\n\n```{r}\n#| message: false\n#| warning: false\n#| eval: false\ninstall.packages(\"lubridate\")\n```\n\nNotez qu'une fois que le *package* est installé, il demeure disponible localement sur votre ordinateur, à moins de le désinstaller explicitement avec la fonction `remove.packages`.\n\n#### Installation d'un *package* depuis GitHub{#sec-01232}\n\n*CRAN* est le répertoire officiel des *packages* de R. Vous pouvez cependant télécharger des *packages* provenant d'autres sources. Très souvent, les *packages* sont disponibles sur le site web [GitHub](https://github.com/){target=\"_blank\"} et nous pouvons même y trouver des versions en développement avec des fonctionnalités encore non intégrées dans la version sur *CRAN*. Reprenons le cas de `lubridate`, mais sur GitHub (il est disponible  [ici](https://github.com/tidyverse/lubridate){target=\"_blank\"}). Pour l'installer, nous devons d'abord installer un autre *package* appelé `remotes` (depuis *CRAN*).\n\n```{r}\n#| message: false\n#| warning: false\n#| eval: false\ninstall.packages(\"remotes\")\n```\n\nMaintenant que nous disposons de `remotes`, nous pouvons utiliser la fonction d'installation `remotes::install_github` pour directement télécharger `lubridate` depuis GitHub.\n\n```{r}\n#| message: false\n#| warning: false\n#| eval: false\nremotes::install_github(\"tidyverse/lubridate\")\n```\n\n#### Chargement d'un *package* {#sec-01233}\n\nMaintenant que `lubridate` est installé, nous pouvons le charger dans notre session actuelle de R et accéder aux fonctions qu'il propose. Pour cela, il suffit d'utiliser la fonction `library`. Conventionnellement, l'appel des *packages* se fait au tout début du script que vous rédigez. Rien ne vous empêche de le faire au fur et à mesure de votre code, mais ce dernier perd alors en lisibilité. Notez que pour chaque nouvelle session (redémarrage de R), il faut recharger les *packages* dont vous avez besoin avec la fonction `library`.\n\n```{r}\n#| message: false\n#| warning: false\nlibrary(lubridate)\n```\n\nSi vous obtenez un message d'erreur du type : \n\n`Error in library(monPackage) : aucun package nommé ‘monPackage’ n'est trouvé`\n\nCela signifie que le *package* que vous tentez de charger n'est pas encore installé sur votre ordinateur. Dans ce cas, réessayer de l'installer avec la fonction `install.packages`. Si le problème persiste, vérifiez que vous n'avez pas fait une faute de frappe dans le nom du *package.* Vous pouvez également redémarrer RStudio et réessayer d'installer ce *package*.\n\n### Aide disponible\n\nLorsque vous installez des *packages* dans R, vous téléchargez aussi leur documentation. Tous les *packages* de *CRAN* disposent d'une documentation, ce qui n'est pas forcément vrai pour ceux sur *GitHub*. Dans RStudio, vous pouvez accéder à la documentation des *packages* dans l'onglet **Packages** (@fig-fig010). Vous pouvez utiliser la barre de recherche pour retrouver rapidement un *package* installé. Si vous cliquez sur le nom du *package*, vous accédez directement à sa documentation dans cette fenêtre.\n\n\n![Description des packages](images/Chap01/rstudio_packages.jpeg){#fig-fig010 width=\"45%\" fig-align=\"center\"}\n\nVous pouvez également accéder à ces informations en utilisant la syntaxe suivante dans votre console : \n\n```{r}\n#| eval: false\nhelp(package = 'lubridate')\n```\n\nSouvent, vous aurez besoin d'accéder à la documentation d'une fonction spécifique d'un *package*. Affichons la documentation de la fonction `now` de `lubridate` : \n\n```{r}\n#| eval: false\nhelp(now, package = 'lubridate')\n```\n\nou plus simplement :\n```{r}\n#| eval: false\n?lubridate::now\n```\n\nVous pouvez aussi utiliser le raccourci suivant.\n\n```{r}\n#| eval: false\n?now\n```\n\nSi  vous ne vous souvenez plus à quel *package* la fonction appartient, lancez une recherche en utilisant un double point d'interrogation : \n\n```{r}\n#| eval: false\n??now\n```\n\nVous découvrirez ainsi que la fonction `now` n'existe pas que dans `lubridate`, ce qui souligne l'importance de bien connaître les *packages* que nous installons et que nous chargeons dans notre session ! \n\nMaintenant que nous avons fait le tour de l'environnement de travail, nous pouvons passer aux choses sérieuses, soit les bases du langage R.\n\n## Bases du langage R {#sec-013}\n\nR est un langage de programmation. Il vous permet de communiquer avec votre ordinateur pour lui donner des tâches à accomplir. Dans cette section, nous abordons les bases du langage. Ce type de section introductive à R est présente dans tous les manuels sur R; elle est donc incontournable. À la première lecture, elle vous semblera probablement aride, et ce, d'autant plus que nous ne réalisons pas d'analyse à proprement parler. Gardez en tête que l'analyse de données requiert au préalable une phase de structuration de ces dernières, opération qui nécessite la maîtrise des notions abordées dans cette section. Nous vous recommandons une première lecture de ce chapitre pour comprendre les manipulations que vous pouvez effectuer avec R, avant de poursuivre avec de la lecture des chapitres suivants dédiés aux analyses statistiques. Vous pourrez revenir consulter cette section au besoin. Notez aussi que la maîtrise des différents objets et des différentes opérations de base de R ne s’acquiert qu'en pratiquant. Vous gagnerez cette expertise au fil de vos prochains codes R, période durant laquelle vous pourrez consulter ce chapitre tel un guide de référence des objets et des notions fondamentales de R.\n\n\n### *Hello World*! {#sec-0131}\n\nUne introduction à un langage de programmation se doit de commencer par le rite de passage *Hello World*. Il s'agit d'une forme de tradition consistant à montrer aux néophytes comment afficher le message `Hello World` à l'écran avec le langage en question.\n\n```{r}\nprint(\"Hello World\")\n```\n\nBravo! Vous venez officiellement de faire votre premier pas dans R!\n\n### Objets et expressions {#sec-0132}\n\nDans R, nous passons notre temps à manipuler des **objets** à l'aide d'**expressions**. Prenons un exemple concret : si vous tapez la syntaxe `4 + 3`, vous manipulez deux objets (4 et 3) avec une expression indiquant que vous souhaitez obtenir la somme des deux objets.\n\n```{r}\n4 + 3\n```\n\nCette expression est correcte, R comprend vos indications et effectue le calcul.\n\nIl est possible d'enregistrer le résultat d'une expression et de le conserver dans un nouvel objet. On appelle cette opération : « déclarer une variable ».\n\n```{r}\nma_somme <- 4 + 3\n```\n\nConcrètement, nous venons de demander à R d'enregistrer le résultat de `4 + 3` dans un espace spécifique de notre mémoire vive. Si vous regardez dans votre fenêtre **Environment**, vous verrez en effet qu'un objet appelé ma_somme est actuellement en mémoire et a pour valeur 7.\n\nNotez ici que le nom des variables ne peut être composé que de lettres, de chiffres, de points (.) et de tirets bas (_) et doit commencer par une lettre. R est sensible à la casse; en d'autres termes, les variables `Ma_somme`, `ma_sommE`, `ma_SOMME`, et `MA_SOMME` renvoient toutes à un objet différent. Attention donc aux fautes de frappe. Si vous déclarez une variable en utilisant le nom d'une variable existante, la première est écrasée par la seconde : \n\n```{r}\nage <- 35\nage\n\nage <- 45\nage\n```\n\nPortez alors attention aux noms de variables que vous utilisez et réutilisez. Réutilisons notre objet `ma_somme` dans une nouvelle expression : \n\n```{r}\nma_somme2 <- ma_somme + ma_somme\n```\n\nAvec cette nouvelle expression, nous indiquons à R que nous souhaitons déclarer une nouvelle variable appelée `ma_somme2`, et que cette variable aura pour valeur `ma_somme + ma_somme`, soit `7 + 7`. Sans surprise, `ma_somme2` a pour valeur 14.\n\nNotez que la mémoire vive (l'environnement) est vidée lorsque vous fermez R. Autrement dit, R perd complètement la mémoire lorsque vous le fermez. Vous pouvez bien sûr recréer vos objets en relançant les mêmes syntaxes. C'est pourquoi vous devez conserver vos feuilles de codes et ne pas seulement travailler dans la console. La console ne garde aucune trace de votre travail. Pensez donc à bien enregistrer votre code!\n\nNous verrons dans une prochaine section comment sauvegarder des objets et les recharger dans une session ultérieure de R ([section @sec-017]). Ce type d'opération est pertinent quand le temps de calcul nécessaire à la production de certains objets est très long.\n\n### Fonctions et arguments {#sec-0_133}\n\nDans R, nous manipulons le plus souvent nos objets avec des **fonctions**. Une fonction est elle-même un objet, mais qui a la particularité de pouvoir effectuer des opérations sur d'autres objets. Par exemple, déclarons l'objet `taille` avec une valeur de 175,897 : \n\n```{r}\ntaille <- 175.897\n```\n\nNous utilisons la fonction `round`, dont l'objectif est d'arrondir un nombre avec décimales pour obtenir un nombre entier.\n\n```{r}\nround(taille)\n```\n\nPour effectuer leurs opérations, les fonctions ont généralement besoin d'**arguments**. Ici, `taille` est un argument passé à la fonction `round`. Si nous regardons la documentation de `round` avec `help(round)` (@fig-fig011), nous constatons que cette fonction prend en réalité deux arguments : *x* et *digits*. Le premier est le nombre que nous souhaitons arrondir et le second est le nombre de décimales à conserver. Nous pouvons lire dans la documentation que la valeur par défaut de *digits* est 0, ce qui explique que `round(taille)` a produit le résultat de 176.\n\n\n![Arguments de la fonction `round`](images/Chap01/help_round.jpeg){#fig-fig011 width=\"35%\" fig-align=\"center\"}\n\nRéutilisons maintenant la fonction `round`, mais en gardant une décimale : \n\n```{r}\nround(taille, digits = 1)\n```\n\nIl est aussi possible que certaines fonctions ne requièrent pas d'argument. Par exemple, la fonction `now` indique la date précise (avec l'heure) et n'a besoin d'aucun argument pour le faire : \n\n```{r}\nnow()\n```\n\nPar contre, si nous essayons de lancer la fonction `round` sans argument, nous obtenons une erreur :\n\n```{r}\n#| eval: false\nround()\n```\n\n`Erreur : 0 argument passé à 'round' qui en exige 1 ou 2`\n\nLe message est très clair, `round` a besoin d'au moins un argument pour fonctionner. Si, au lieu d'un nombre, nous avions donné du texte à la fonction `round`, nous aurions aussi obtenu une erreur : \n\n```{r}\n#| eval: false\nround(\"Hello World\")\n```\n\n`Erreur dans round(\"Hello World\") : argument non numérique pour une fonction mathématique`\n\nÀ nouveau le message est très explicite : nous avons passé un argument non numérique à une fonction mathématique. Lisez toujours vos messages d'erreurs : ils permettent de repérer les coquilles et de corriger votre code!\n\nNous terminons cette section avec une fonction essentielle, `print`, qui permet d'afficher la valeur d'une variable.\n\n```{r}\nprint(ma_somme)\n```\n\n\n### Principaux types de données {#sec-0134}\n\nDepuis le début de ce chapitre, nous avons déclaré plusieurs variables et essentiellement des données numériques. Dans R, il existe trois principaux types de données de base : \n\n* Les données numériques qui peuvent être des nombres entiers (appelés *integers*) ou des nombres décimaux (appelés *floats* ou *doubles*), par exemple `15` et `15.3`.\n\n* Les données de type texte qui sont des chaînes de caractères (appelées *strings*) et déclarées entre guillemets `\"abcdefg\"`.\n\n* Les données booléennes (*booleans*) qui peuvent n'avoir que deux valeurs : vrai (`TRUE`) ou faux (`FALSE`).\n\nDéclarons une variable pour chacun de ces types : \n\n```{r}\nage <- 35\ntaille <- 175.5\nadresse <- '4225 rue de la gauchetiere'\nproprietaire <- TRUE\n```\n\n::: bloc_notes\n::: bloc_notes-header\n::: bloc_notes-icon\n:::\n**Simples ou doubles quotes?**\n:::\n::: bloc_notes-body\nPour déclarer des données de type texte, il est possible d'utiliser des quotes simples `'` (apostrophe) ou des quotes doubles `\"` (guillemets), cela ne fait aucune différence pour R. Cependant, si la chaîne de caractères que vous créez contient une apostrophe, il est nécessaire d'utiliser des quotes doubles et inversement si votre chaîne de caractère contient des guillemets.\n\n```{r}\nphrase1 <- \"J'adore le langage R!\"\nphrase2 <- 'Je cite : \"il est le meilleur langage de statistique\".'\n```\n\nSi la chaîne de caractère contient des guillemets et des apostrophes, il est nécessaire d'utiliser la barre oblique inversée `\\` pour indiquer à R que ces apostrophes ou ces guillemets ne doivent pas être considérés comme la fin de la chaîne de caractère.\n\n```{r}\nphrase3 <- \"Je cite : \\\"j'en rêve la nuit\\\".\"\ncat(phrase3)\n```\n\nLes barres obliques inversées ne font pas partie de la chaîne de caractère, ils sont là pour \"échapper\" les guillemets qui doivent rester dans la chaîne de caractère. Si une chaîne de caractère doit contenir une barre oblique inversée, alors il faut l'échapper également en utilisant une deuxième barre oblique inversée.\n\n```{r}\nphrase4 <- \"Une phrase avec une barre oblique inversée : \\\\\"\ncat(phrase4)\n```\nFaites attention à la coloration syntaxique de RStudio! Elle peut vous aider à repérer facilement une chaîne de caractère qui aurait été interrompue par un guillemet ou une apostrophe mal placés.\n:::\n:::\n\nSi vous avez un doute sur le type de données stockées dans une variable, vous pouvez utiliser la fonction `typeof`. Par exemple, cela permet de repérer si des données qui sont censées être numériques sont en fait stockées sous forme de texte comme dans l'exemple ci-dessous.\n\n```{r}\ntypeof(age)\ntypeof(taille)\n\n# Ici tailletxt est définie comme une chaîne de caractère car la valeur est \n# définie entre des guillemets.\ntailletxt <- \"175.5\"\ntypeof(tailletxt)\n\n```\n\n\nNotez également qu'il existe des types pour représenter l'absence de données : \n\n* pour représenter un objet vide, nous utilisons l'objet `NULL`,\n\n* pour représenter une donnée manquante, nous utilisons l'objet `NA`,\n\n* pour représenter un texte vide, nous utilisons une chaîne de caractère de longueur 0, soit `\"\"`.\n\n```{r}\nage2 <- NULL\ntaille2 <- NA\nadresse2 <- ''\n```\n\n### Opérateurs {#sec-0135}\n\nNous avons vu que les fonctions permettent de manipuler des objets. Nous pouvons également effectuer un grand nombre d'opérations avec les opérateurs.\n\n#### Opérateurs mathématiques {#sec-01351}\n\nLes opérateurs mathématiques (@tbl-OperateurMath) permettent d'effectuer des calculs avec des données de type numérique.\n\n```{r}\n#| label: tbl-OperateurMath\n#| tbl-cap: Opérateurs mathématiques\n#| echo: false\n#| message: false\n#| warning: false\n\ndf <- data.frame(\n        Operateur = c(\"`+`\" , \"`-`\" , \"`*`\" , \"`/`\", \"`^`\", \"`**`\",\n                      \"`%%`\", \"`%/%`\"),\n        Description = c(\"Addition\", 'Soustraction', 'Multiplication',\n                        'Division', 'Exponentiel', 'Exponentiel',\n                        'Reste de division', 'Division entière'),\n        Syntaxe = c(\"`4 + 4`\", \"`4 - 3`\", \"`4 * 3`\", \"`12 / 4`\",\n                    \"`4 ^ 3`\", '`4 ** 3`', \"`15,5 %% 2`\",\n                    \"`15,5 %/% 2`\"), \n        Resultat = c(8,1,12,3,64,64,1.5,7))\n\nknitr::kable(df, \n             format.args = list(decimal.mark = ',', big.mark = \" \"),\n             col.names = c(\"Opérateur\" , \"Description\" , \"Syntaxe\" , \"Résultat\"),\n             align= c(\"l\", \"l\", \"l\", \"r\")\n             )\n```\n\n#### Opérateurs relationnels  {#sec-01352}\n\nLes opérateurs relationnels (@tbl-OperateurRelationnels) permettent de vérifier des conditions dans R. Ils renvoient un booléen, `TRUE` si la condition est vérifiée et `FALSE` si ce n'est pas le cas.\n\n```{r}\n#| label: tbl-OperateurRelationnels\n#| tbl-cap: Opérateurs relationnels\n#| echo: false\n#| message: false\n#| warning: false\n\ndf <- data.frame(\n        Operateur = c(\"`==`\" , \"`!=`\" , \"`>`\" , \"`<`\", \"`>=`\", \"`<=`\"),\n        Description = c(\"Égalité\", 'Différence', 'Est supérieur ', 'Est inférieur', 'Est supérieur ou égal', 'Est inférieur ou égal'),\n        Syntaxe = c(\"`4 == 4`\", \"`4 != 4`\", \"`5 > 4`\", \"`5 < 4`\", \"`5 >= 4`\", '`5 <= 4`'), \n        Resultat = c(TRUE, FALSE, TRUE, FALSE, TRUE, FALSE))\n\nknitr::kable(df,\n           format.args = list(decimal.mark = ',', big.mark = \" \"),\n           col.names = c(\"Opérateur\" , \"Description\" , \"Syntaxe\" , \"Résultat\"),\n                      align= c(\"l\", \"l\", \"l\", \"l\"))\n```\n\n#### Opérateurs logiques {#sec-01353}\n\nLes opérateurs logiques (@tbl-tableOperateurLogi) permettent de combiner plusieurs conditions :\n\n* L'opérateur **ET** (`&`) permet de vérifier que deux conditions (l'une ET l'autre) sont TRUE. Si l'une des deux est FALSE, il renvoie FALSE.\n\n* L'opérateur **OU** (`|`) permet de vérifier que l'une des deux conditions est TRUE (l'une OU l'autre). Si les deux sont FALSE, alors il renvoie FALSE.\n\n* L'opérateur **NOT** (`!`) permet d'inverser une condition. Ainsi, NOT TRUE donne FALSE et NOT FALSE donne TRUE.\n\n\n```{r}\n#| label: tbl-tableOperateurLogi\n#| tbl-cap: Opérateurs logiques\n#| echo: false\n#| message: false\n#| warning: false\ndf <- data.frame(\n        Operateur = c(\"`&`\" , \"`|`\" , \"`!`\"),\n        Description = c(\"ET\", \"OU\", \"NOT\"),\n        Syntaxe = c(\"`TRUE & FALSE`\", \"`TRUE | FALSE`\", \"`! TRUE`\"), \n        Resultat = c(FALSE, TRUE, FALSE))\n\nknitr::kable(df, \n           format.args = list(decimal.mark = ',', big.mark = \" \"),\n           col.names = c(\"Opérateur\" , \"Description\" , \"Syntaxe\" , \"Résultat\"),\n           align= c(\"l\", \"l\", \"l\", \"l\")\n           )\n```\n\nPrenons le temps pour un rapide exemple : \n\n```{r}\n\nA <- 4 \nB <- 10\nC <- -5\n\n# Produit TRUE car A est bien plus petit que B et C est bien plus petit que A\nA < B & C < A\n\n# Produit FALSE car si A est bien plus petit que B, \n# B est en revanche plus grand que c\nA < B & B < C\n\n# Produit TRUE car la seconde condition est inversée\nA < B &  ! B < C\n\n# Produit TRUE car au moins une des deux conditions est juste\nA < B |  B < C\n\n```\n\nNotez que l'opérateur **ET** est prioritaire sur l'opérateur **OU** et que les parenthèses sont prioritaires sur tous les opérateurs : \n\n```{r}\n# Produit TRUE car nous commençons par tester A < B puis B < C ce qui donne FALSE\n# On obtient ensuite\n# FALSE |  A > C\n# Enfin, A est bien supérieur à C, donc l'une des deux conditions est vraie\nA < B & B < C |  A > C\n\n```\n\nNotez qu'en arrière-plan, les opérateurs sont en réalité des fonctions déguisées. Il est donc possible de définir de nouveaux comportements pour les opérateurs. Il est par exemple possible d'additionner ou de comparer des objets spéciaux comme des dates, des géométries, des graphes, etc.\n\n### Structures de données {#sec-0136}\n\nJusqu'à présent, nous avons utilisé des objets ne comprenant qu'une seule valeur. Or, des analyses statistiques nécessitent de travailler avec des volumes de données bien plus grands. Pour stocker des valeurs, nous travaillons avec différentes structures de données : les vecteurs, les matrices, les tableaux de données et les listes.\n\n#### Vecteurs {#sec-01361}\n\nLes vecteurs sont la brique élémentaire de R. Ils permettent de stocker une série de valeurs **du même type** dans une seule variable. Pour déclarer un vecteur, nous utilisons la fonction `c()` : \n\n```{r}\nages <- c(35,45,72,56,62)\ntailles <- c(175.5,180.3,168.2,172.8,167.6)\nadresses <- c('4225 rue de la gauchetiere',\n              '4223 rue de la gauchetiere',\n              '4221 rue de la gauchetiere',\n              '4219 rue de la gauchetiere',\n              '4217 rue de la gauchetiere')\nproprietaires <- c(TRUE, TRUE, FALSE, TRUE, TRUE)\n```\n\nNous venons ainsi de déclarer quatre nouvelles variables étant chacune un vecteur de longueur cinq (comprenant chacun cinq valeurs). Ces vecteurs représentent, par exemple, les réponses de plusieurs personnes à un questionnaire.\n\n::: bloc_attention\n::: bloc_attention-header\n::: bloc_attention-icon\n:::\n**Distinction entre un vecteur de type texte et un vecteur de type facteur**\n:::\n\n::: bloc_attention-body\nIl existe dans R une subtilité à l'origine de nombreux malentendus :  la distinction entre un vecteur de type **texte** et un vecteur de type **facteur**. Dans l'exemple précédent, le vecteur *adresses* est un vecteur de type texte. Chaque nouvelle valeur ajoutée dans le vecteur peut être n'importe quelle nouvelle adresse. Déclarons un nouveau vecteur qui contient cette fois-ci la couleur des yeux de personnes ayant répondu au questionnaire.\n\n```{r}\ncouleurs_yeux <- c('marron', 'marron', 'bleu', 'bleu', 'marron', 'vert')\n```\n\nContrairement aux adresses, il y a un nombre limité de couleurs que nous pouvons mettre dans ce vecteur. Il est donc intéressant de fixer les valeurs possibles du vecteur pour éviter d'en ajouter de nouvelles par erreur. Pour cela, nous devons convertir ce vecteur texte en vecteur de type facteur, ci-après nommé simplement facteur, avec la fonction `as.factor`.\n\n```{r}\ncouleurs_yeux_facteur <- as.factor(couleurs_yeux)\n```\n\nNotez qu'à présent, nous pouvons ajouter une nouvelle couleur dans le premier vecteur, mais pas dans le second.\n\n```{r}\ncouleurs_yeux[7] <- \"rouge\"\ncouleurs_yeux_facteur[7] <- \"rouge\"\n```\n\nLe message d'erreur nous informe que nous avons tenté d'introduire une valeur invalide dans le facteur.\n\nLes facteurs peuvent sembler restrictifs et, très régulièrement, nous préférons travailler avec de simples vecteurs de type texte plutôt que des facteurs. Cependant, de nombreuses fonctions d'analyse nécessitent d'utiliser des facteurs, car ils assurent une certaine cohérence dans les données. Il est donc essentiel de savoir passer du texte au facteur avec la fonction `as.factor`. À l'inverse, il est parfois nécessaire de revenir à une variable de type texte avec la fonction `as.character`.\n\nNotez que des vecteurs numériques peuvent aussi être convertis en facteurs : \n\n```{r}\ntailles_facteur <- as.factor(tailles)\n```\n\nCependant, si vous souhaitez reconvertir ce facteur en format numérique, il faudra passer dans un premier temps par le format texte : \n\n```{r}\nas.numeric(tailles_facteur)\n```\n\nComme vous pouvez le voir, convertir un facteur en valeur numérique renvoie des nombres entiers. Ceci est dû au fait que les valeurs dans un facteur sont recodées sous forme de nombres entiers, chaque nombre correspondant à une des valeurs originales (appelées niveaux). Si nous convertissons un facteur en valeurs numériques, nous obtenons donc ces nombres entiers.\n\n```{r}\nas.numeric(as.character(tailles_facteur))\n```\n\nMorale de l'histoire : ne confondez pas les données de type texte et de type facteur. Dans le doute, vous pouvez demander à R quel est le type d'un vecteur avec la fonction `class`.\n\n```{r}\nclass(tailles)\nclass(tailles_facteur)\nclass(couleurs_yeux)\nclass(couleurs_yeux_facteur)\n```\n:::\n:::\n\n\nQuasiment toutes les fonctions utilisent des vecteurs. Par exemple, nous pouvons calculer la moyenne du vecteur *ages* en utilisant la fonction `mean` présente de base dans R.\n\n```{r}\nmean(ages)\n```\n\nCela démontre bien que le vecteur est la brique élémentaire de R! Toutes les variables que nous avons déclarées dans les sections précédentes sont aussi des vecteurs, mais de longueur 1.\n\n#### Matrices {#sec-01362}\n\nIl est possible de combiner des vecteurs pour former des matrices. Une matrice est un tableau en deux dimensions (colonnes et lignes) et est généralement utilisée pour représenter certaines structures de données comme des images (pixels), effectuer du calcul matriciel ou plus simplement présenter des matrices de corrélations. Vous aurez rarement à travailler directement avec des matrices, mais il est bon de savoir ce qu'elles sont. Créons deux matrices à partir de nos précédents vecteurs.\n\n```{r}\nmatrice1 <- cbind(ages, tailles)\n# Afficher la matrice 1\nprint(matrice1)\n# Afficher les dimensions de la matrice 1 (1er chiffre : lignes; 2e chiffre : colonnes)\nprint(dim(matrice1))\n\nmatrice2 <- rbind(ages, tailles)\n# Afficher la matrice 2\nprint(matrice2)\n# Afficher les dimensions de la matrice 2\nprint(dim(matrice2))\n```\n\nComme vous pouvez le constater, la fonction `cbind` permet de concaténer des vecteurs comme s'ils étaient les colonnes d'une matrice, alors que `rbind` les combine comme s'ils étaient les lignes d'une matrice. La @fig-fig012 présente graphiquement le passage du vecteur à la matrice.\n\n![Du vecteur à la matrice](images/Chap01/vecteur_to_matrix.png){#fig-fig012 width=\"30%\" fig-align=\"center\"}\n\nNotez que vous pouvez transposer une matrice avec la fonction `t`. Si nous essayons maintenant de comparer la matrice 1 à la matrice 2 nous allons avoir une erreur, car elles n'ont pas les mêmes dimensions.\n\n```{r}\n#| eval: false\nmatrice1 == matrice2\n```\n\n`Erreur dans matrice1 == matrice2 : tableaux de tailles inadéquates`\n\nEn revanche, nous pouvons transposer la matrice 1 et refaire cette comparaison : \n\n```{r}\nt(matrice1) == matrice2\n```\n\nLe résultat souligne bien que nous avons les mêmes valeurs dans les deux matrices. Il est aussi possible de construire des matrices directement avec la fonction `matrix`, ce que nous montrons dans la prochaine section.\n\n#### *Arrays*  {#sec-01363}\n\nS'il est rare de travailler avec des matrices, il est encore plus rare de manipuler des *arrays*. Un *array* est une matrice spéciale qui peut avoir plus que deux dimensions. Un cas simple serait un *array* en trois dimensions : lignes, colonnes, profondeur, que nous pourrions représenter comme un cube, ou une série de matrices de mêmes dimensions et empilées. Au-delà de trois dimensions, il devient difficile de les représenter mentalement. Cette structure de données peut être utilisée pour représenter les différentes bandes spectrales d'une image satellitaire. Les lignes et les colonnes délimiteraient les pixels de l'image et la profondeur délimiterait les différentes bandes composant l'image (@fig-fig012).\n\n\n![Un array avec trois dimensions](images/Chap01/array.png){#fig-fig013 width=\"15%\" fig-align=\"center\"}\n\nCréons un *array* en combinant trois matrices avec la fonction `array`. Chacune de ces matrices est composée respectivement de 1, de 2 et de 3 et a une dimension de 5 x 5. L'*array* final a donc une dimension de 5 x 5 x 3.\n\n```{r}\nmat1 <- matrix(1, nrow = 5, ncol = 5)\nmat2 <- matrix(2, nrow = 5, ncol = 5)\nmat3 <- matrix(3, nrow = 5, ncol = 5)\n\nmon_array <- array(c(mat1, mat2, mat3), dim = c(5,5,3))\n\nprint(mon_array)\n```\n\n\n#### *DataFrames* {#sec-01364}\n\nS'il est rare de manipuler des matrices et des *arrays*, le *DataFrame* (tableau de données en français) est la structure de données la plus souvent utilisée. Dans cette structure, chaque ligne du tableau représente un individu et chaque colonne représente une caractéristique de cet individu. Ces colonnes ont des noms qui permettent facilement d'accéder à leurs valeurs. Créons un *DataFrame* (@tbl-tabfirsttable) à partir de nos quatre vecteurs et de la fonction `data.frame`.\n\n```{r}\ndf <- data.frame(\n  \"age\" = ages,\n  \"taille\" = tailles,\n  \"adresse\" = adresses,\n  \"proprietaire\" = proprietaires\n)\n```\n\n```{r}\n#| label: tbl-tabfirsttable\n#| tbl-cap: Premier DataFrame\n#| echo: false\n#| message: false\n#| warning: false\nknitr::kable(df, \n           format.args = list(decimal.mark = ',', big.mark = \" \"),\n           align= c(\"c\", \"c\", \"l\", \"l\")\n)\n```\n\nDans RStudio, vous pouvez visualiser votre tableau de données avec la fonction `View(df)`. Comme vous pouvez le constater, chaque vecteur est devenu une colonne de votre tableau de données *df*. La @fig-fig013 résume ce passage d'une simple donnée à un *DataFrame* en passant par un vecteur.\n\n\n![De la donnée au DataFrame](images/Chap01/vecteur_to_dataframe.png){#fig-fig013 width=\"25%\" fig-align=\"center\"}\n\nPlusieurs fonctions de base de R fournissent des informations importantes sur un *DataFrame* : \n\n* `names` renvoie les noms des colonnes du *DataFrame*;\n* `nrow` renvoie le nombre de lignes;\n* `ncol` renvoie le nombre de colonnes.\n\n```{r}\nnames(df)\nnrow(df)\nncol(df)\n```\n\nVous pouvez accéder à chaque colonne de *df* en utilisant le symbole `$` ou `[[\"nom_de_la_colonne\"]]`. Recalculons ainsi la moyenne des âges :\n\n```{r}\nmean(df$age)\nmean(df[[\"age\"]])\n```\n\n#### Listes {#sec-01365}\n\nLa dernière structure de données à connaître est la liste. Elle ressemble à un vecteur, au sens où elle permet de stocker un ensemble d'objets les uns à la suite des autres. Cependant, une liste peut contenir n'importe quel type d'objets. Vous pouvez ainsi construire des listes de matrices, des listes d'*arrays*, des listes mixant des vecteurs, des graphiques, des *DataFrames*, des listes de listes...\n\nCréons ensemble une liste qui va contenir des vecteurs et des matrices à l'aide de la fonction `list.`\n\n```{r}\nma_liste <- list(c(1,2,3,4),\n                 matrix(1, ncol = 3, nrow = 5),\n                 matrix(5, ncol = 3, nrow = 7),\n                 'A'\n                 )\n```\n\nIl est possible d'accéder aux éléments de la liste par leur position dans cette dernière en utilisant les doubles crochets `[[ ]]` : \n\n```{r}\nprint(ma_liste[[1]])\nprint(ma_liste[[4]])\n```\n\nIl est aussi possible de donner des noms aux éléments de la liste et d'utiliser le symbole `$` pour y accéder. Créons une nouvelle liste de vecteurs et donnons-leur des noms avec la fonction `names`.\n\n```{r}\nliste2 <- list(c(35, 45, 72, 56, 62), \n               c(175.5, 180.3, 168.2, 172.8, 167.6),\n               c(TRUE, TRUE, FALSE, TRUE, TRUE)\n)\nnames(liste2) <- c(\"age\", \"taille\", \"proprietaire\")\n\nprint(liste2$age)\n```\n\nSi vous avez bien suivi, vous devriez avoir compris qu'un *DataFrame* n'est en fait rien d'autre qu'une liste de vecteurs avec des noms!\n\nBravo! Vous venez de faire le tour des bases du langage R. Vous allez apprendre désormais à manipuler des données dans des *DataFrames*!\n\n## Manipulation de données {#sec-014}\n\nDans cette section, vous apprendrez à charger et à manipuler des *DataFrames* en vue d'effectuer des opérations classiques de gestion de données.\n\n\n### Chargement d'un *DataFrame* depuis un fichier {#sec-0141}\n\nIl est rarement nécessaire de créer vos *DataFrames* manuellement. Le plus souvent, vous disposerez de fichiers contenant vos données et utiliserez des fonctions pour les importer dans R sous forme d'un *DataFrame*. Les formats à importer les plus répandus sont :  \n\n* *.csv*, soit un fichier texte dont chaque ligne représente une ligne du tableau de données et dont les colonnes sont séparées par un délimiteur (généralement une virgule ou un point-virgule);\n\n* *.dbf*, ou fichier *dBase*, souvent associés à des fichiers d'information géographique au format *ShapeFile*;\n\n* *.xls* et *.xlsx*, soit des fichiers générés par Excel;\n\n* *.json*, soit un fichier texte utilisant la norme d'écriture propre au langage JavaScript.\n\nPlus rarement, il se peut que vous ayez à charger des fichiers provenant de logiciels propriétaires : \n\n* *.sas7bdat* (SAS);\n* *.sav* (SPSS);\n* *.dta* (STATA).\n\nPour lire la plupart de ces fichiers, nous utilisons le *package* `foreign` dédié à l'importation d'une multitude de formats. Nous commençons donc par l'installer (`install.packages(\"foreign\")`). Ensuite, nous chargeons cinq fois le même jeu de données enregistré dans des formats différents (*csv*, *dbf*, *dta*, *sas7bdat* et *xlsx*) et nous mesurons le temps nécessaire pour importer chacun de ces fichiers avec la fonction `Sys.time`.\n\n#### Lecture d'un fichier *csv* {#sec-01411}\n\nPour le format *csv*, il n'est pas nécessaire d'utiliser un *package* puisque R dispose d'une fonction de base pour lire ce format.\n\n```{r}\n#| message: false\n#| warning: false\nt1 <- Sys.time()\ndf1 <- read.csv(\"data/priseenmain/SR_MTL_2016.csv\", \n         header = TRUE, sep = \",\", dec = \".\",\n         stringsAsFactors = FALSE)\nt2 <- Sys.time()\nd1 <- as.numeric(difftime(t2, t1, units = \"secs\"))\ncat(\"Le DataFrame df1 a \", nrow(df1),\" observations\",\n    'et ', ncol(df1),\" colonnes\\n\")\n```\n\nRien de bien compliqué! Notez tout de même que :  \n\n* Lorsque vous chargez un fichier *csv*, vous devez connaître le **délimiteur** (ou **séparateur**), soit le caractère utilisé pour délimiter les colonnes. Dans le cas présent, il s'agit d'une virgule (spécifiez avec l'argument `sep = \",\"`), mais il pourrait tout aussi bien être un point virgule (`sep = \";\"`), une tabulation (`sep = \"    \"`), etc.\n\n* Vous devez également spécifier le caractère utilisé comme séparateur de décimales. Le plus souvent, ce sera le point (`dec = \".\"`), mais certains logiciels avec des paramètres régionaux de langue française (notamment Excel) exportent des fichiers *csv* avec des virgules comme séparateur de décimales (utilisez alors `dec = \",\"`).\n\n* L'argument `header` indique si la première ligne (l'entête) du fichier comprend ou non les noms des colonnes du jeu de données (avec les valeurs `TRUE` ou `FALSE`). Il arrive que certains fichiers *csv* soient fournis sans entête et que le nom et la description des colonnes soient fournis dans un autre fichier.\n\n* L'argument `stringsAsFactors` permet d'indiquer à R que les colonnes comportant du texte doivent être chargées comme des vecteurs de type texte et non de type facteur.\n\n#### Lecture d'un fichier *dbase* {#sec-01412}\n\nPour lire un fichier *dbase* (.dbf), nous utilisons la fonction `read.dbf` du *package* `foreign` installé précédemment : \n\n```{r}\n#| message: false\n#| warning: false\nlibrary(foreign)\n\nt1 <- Sys.time()\ndf2 <- read.dbf(\"data/priseenmain/SR_MTL_2016.dbf\")\nt2 <- Sys.time()\nd2 <- as.numeric(difftime(t2, t1, units = \"secs\"))\ncat(\"Le DataFrame df2 a \", nrow(df2),\" observations\",\n    \"et \", ncol(df2),\" colonnes\\n\")\n```\n\nComme vous pouvez le constater, nous obtenons les mêmes résultats qu'avec le fichier *csv*.\n\n#### Lecture d'un fichier *dta* (Stata) {#sec-01413}\n\nSi vous travaillez avec des collègues utilisant le logiciel Stata, il se peut que ces derniers vous partagent des fichiers *dta*. Toujours en utilisant le *package* `foreign`, vous serez en mesure de les charger directement dans R.\n\n```{r}\n#| message: false\n#| warning: false\nt1 <- Sys.time()\ndf3 <- read.dta(\"data/priseenmain/SR_MTL_2016.dta\")\nt2 <- Sys.time()\nd3 <- as.numeric(difftime(t2, t1, units = \"secs\"))\ncat(\"Le DataFrame df3 a \", nrow(df3),\" observations \",\n    \"et \", ncol(df3), \" colonnes\\n\", sep = \"\")\n```\n\n\n#### Lecture d'un fichier *sav* (SPSS) {#sec-01414}\n\nPour importer un fichier *sav* provenant du logiciel statistique SPSS, utilisez la fonction `read.spss` du *package* `foreign`.\n\n```{r}\n#| message: false\n#| warning: false\nt1 <- Sys.time()\ndf4 <- as.data.frame(read.spss(\"data/priseenmain/SR_MTL_2016.sav\"))\nt2 <- Sys.time()\nd4 <- as.numeric(difftime(t2, t1, units = \"secs\"))\ncat(\"Le DataFrame df4 a \", nrow(df4),\" observations \",\n    \"et \", ncol(df4), \" colonnes\\n\", sep = \"\")\n```\n\n#### Lecture d'un fichier *sas7bdat* (SAS) {#sec-01415}\n\nPour importer un fichier *sas7bdat* provenant du logiciel statistique SAS, utilisez la fonction `read.sas7bdat` du *package* `sas7bdat`. Installez préalablement le *package* (`install.packages(\"sas7bdat\")`) et chargez-le (`library(sas7bdat)`).\n\n```{r}\n#| message: false\n#| warning: false\nlibrary(sas7bdat)\n\nt1 <- Sys.time()\ndf5 <- read.sas7bdat(\"data/priseenmain/SR_MTL_2016.sas7bdat\")\nt2 <- Sys.time()\nd5 <- as.numeric(difftime(t2, t1, units = \"secs\"))\ncat(\"Le DataFrame df5 a \", nrow(df5),\" observations \",\n    \"et \", ncol(df5),\" colonnes\\n\", sep = \"\")\n```\n\n\n#### Lecture d'un fichier *xlsx* (Excel) {#sec-01416}\n\nLire un fichier Excel dans R n'est pas toujours une tâche facile. Généralement, nous recommandons d'exporter le fichier en question au format *csv* dans un premier temps, puis de le lire avec la fonction `read.csv` dans un second temps ([section @sec-01411]). \n\nIl est néanmoins possible de lire directement un fichier *xlsx* avec le *package* `xlsx`. Ce dernier requiert que le logiciel JAVA soit installé sur votre ordinateur (Windows, Mac ou Linux). Si vous utilisez la version 64 bit de R, vous devrez télécharger et installer la version 64 bit de JAVA. Une fois que ce logiciel tiers est installé, il ne vous restera plus qu'à installer (`install.packages(\"xlsx\")`) et charger (`library(xlsx)`) le *package* `xlsx`. Sous windows, il est possible que vous deviez également installer manuellement le *package* `rJava` et indiquer à R où se trouve JAVA sur votre ordinateur. La procédure est détaillée [ici](https://cimentadaj.github.io/blog/2018-05-25-installing-rjava-on-windows-10/installing-rjava-on-windows-10/).\n\n```{r}\n#| message: false\n#| warning: false\nlibrary(xlsx)\n\nt1 <- Sys.time()\ndf6 <- read.xlsx(file=\"data/priseenmain/SR_MTL_2016.xlsx\",\n                 sheetIndex = 1,\n                 as.data.frame = TRUE)\nt2 <- Sys.time()\nd6 <- as.numeric(difftime(t2, t1, units = \"secs\"))\ncat(\"Le DataFrame df6 a \", nrow(df6),\" observations \",\n    \"et \", ncol(df6),\" colonnes\\n\", sep = \"\")\n```\n\nIl est possible d'accélérer significativement la vitesse de lecture d'un fichier *xlsx* en utilisant la fonction `read.xlsx2`. Il faut cependant indiquer à cette dernière le type de données de chaque colonne. Dans le cas présent, les cinq premières colonnes contiennent des données de type texte (`character`), alors que les 43 autres sont des données numériques (`numeric`). Nous utilisons la fonction `rep` afin de ne pas avoir à écrire plusieurs fois *character* et *numeric*.\n\n```{r}\n#| echo: true\n#| message: false\n#| warning: false\nlibrary(xlsx)\n\nt1 <- Sys.time()\ndf7 <- read.xlsx2(file=\"data/priseenmain/SR_MTL_2016.xlsx\",\n                  sheetIndex = 1, \n                  as.data.frame = TRUE,\n                  colClasses = c(rep(\"character\",5), rep(\"numeric\",43))\n                  )\nt2 <- Sys.time()\nd7 <- as.numeric(difftime(t2, t1, units = \"secs\"))\ncat(\"Le DataFrame df6 a \", nrow(df7),\" observations \",\n    \"et \", ncol(df7),\" colonnes\\n\", sep = \"\")\n```\n\nSi nous comparons les temps d'exécution (@tbl-tableduration), nous constatons que la lecture des fichiers *xlsx* peut être extrêmement longue si nous ne spécifions pas le type des colonnes, ce qui peut devenir problématique pour des fichiers volumineux. Notez également que la lecture d'un fichier *csv* devient de plus en plus laborieuse à mesure que sa taille augmente. Si vous devez un jour charger des fichiers *csv* de plusieurs gigaoctets, nous vous recommandons vivement d'utiliser la fonction `fread` du *package* `data.table` qui est beaucoup plus rapide.\n\n\n```{r}\n#| label: tbl-tableduration\n#| tbl-cap: Temps nécessaire pour lire les données en fonction du type de fichiers\n#| echo: false\n#| message: false\n#| warning: false\nDureeImportation <- data.frame(\n  \"fonction\" = c(\"read.csv\" , \"read.dbf\" , \"read.spss\" , \"read.dta\",\n                 'read.sas7bdat',\"read.xlsx\" , \"read.xlsx2\"),\n  \"duree\" = c(d1, d2, d3, d4, d5, d6, d7)\n\n)\n\nknitr::kable(DureeImportation, \n           format.args = list(decimal.mark = ',', big.mark = \" \"),\n           digits = 2, \n           col.names = c(\"Fonction\", \"Durée (secondes)\"),\n           align= c(\"r\", \"l\")\n\t\t   )\n```\n\n### Manipulation d'un *DataFrame* {#sec-0142}\n\nUne fois le *DataFrame* chargé, voyons comment il est possible de le manipuler.\n\n#### Petit mot sur le `tidyverse` {#sec-01421}\n\n`tidyverse` est un ensemble de *packages* conçus pour faciliter la structuration et la manipulation des données dans R. Avant d'aller plus loin, il est important d'aborder brièvement un débat actuel dans la Communauté R. Entre 2010 et 2020, l'utilisation du `tidyverse` s'est peu à peu répandue. Développé et maintenu par Hadley Wickham, `tidyverse` introduit une philosophie et une grammaire spécifiques qui diffèrent du langage R traditionnel. Une partie de la communauté a pour ainsi dire complètement embrassé le `tidyverse` et de nombreux *packages*, en dehors du `tidyverse`, ont adopté sa grammaire et sa philosophie. À l'inverse, une autre partie de la communauté est contre cette évolution ([voir l'article du blogue suivant](https://blog.ephorie.de/why-i-dont-use-the-tidyverse){target=\"_blank\"}). Les arguments pour et contre `tidyverse` sont résumés dans le (@tbl-Tidyverse). \n\n\n```{r}\n#| label: tbl-Tidyverse\n#| tbl-cap: Avantages et inconvénients du tidyverse\n#| echo: false\n#| message: false\n#| warning: false\n\ndf <- data.frame(\n          Pour = c(\"Simplicité d'écriture et d'apprentissage\",\n  \"Ajout de l'opérateur `%>%` permettant d'enchaîner les traitements\",\n  \"La meilleure librairie pour réaliser des graphiques : `ggplot2`\",\n  \"Crée un écosystème cohérent\",\n  \"*Package* en développement et de plus en plus utilisé\"),\n          Contre = c(\"Nouvelle syntaxe à apprendre\",\n  \"Perte de lisibilité avec l'opérateur `->`\",\n  \"Remplacement de certaines fonctions de base par d'autres provenant du `tidyverse` lors de son chargement, pouvant créer des erreurs.\",\n  \"Ajout d'une dépendance dans le code\",\n  \"Philosophie d'évolution agressive, aucune assurance de rétrocompatibilité\")\n)\n\nknitr::kable(df, \n      format.args = list(decimal.mark = ',', big.mark = \" \"),\n      col.names = c(\"Avantage du tidyverse\",\n                  \"Problème posé par le tidyverse\"),\n      align= c(\"l\", \"l\"),\n      col.to.resize = c(1,2), \n      col.width = \"7cm\")\n```\n\n\nLe dernier point est probablement le plus problématique. Dans sa volonté d'évoluer au mieux et sans restriction, le *package* `tidyverse` n'offre aucune garantie de rétrocompatibilité. En d'autres termes, des changements importants peuvent être introduits d'une version à l'autre rendant potentiellement obsolète votre ancien code. Nous n'avons pas d'opinion tranchée sur le sujet : `tidyverse` est un outil très intéressant dans de nombreux cas; nous évitons simplement de l'utiliser systématiquement et préférons charger directement des sous-*packages* (comme `dplyr` ou `ggplot2`) du `tidyverse`. Notez que le *package* `data.table` offre une alternative au `tidyverse` dans la manipulation de données. Au prix d'une syntaxe généralement un peu plus complexe, le package `data.table` offre une vitesse de calcul bien supérieure au `tidyverse` et assure une bonne rétrocompatibilité.\n\n\n#### Gestion des colonnes d'un *DataFrame* {#sec-01422}\n\nRepartons du *DataFrame* que nous avions chargé précédemment en important un fichier *csv*.\n\n```{r}\n#| message: false\n#| warning: false\ndf <- read.csv(file=\"data/priseenmain/SR_MTL_2016.csv\", \n               header = TRUE, sep = \",\", dec = \".\",\n               stringsAsFactors = FALSE)\n```\n\n##### Sélection d'une colonne {#sec-014221}\n\nRappelons qu'il est possible d'accéder aux colonnes dans ce *DataFrame* en utilisant le symbole dollar `$ma_colonne` ou les doubles crochets `[[\"ma_colonne\"]]`.\n\n```{r}\n#| message: false\n#| warning: false\n# Calcul de la superficie totale de l'Île de Montréal\nsum(df$KM2)\nsum(df[[\"KM2\"]])\n```\n\n##### Sélection de plusieurs colonnes {#sec-014222}\n\nIl est possible de sélectionner plusieurs colonnes d'un *DataFrame* et de filtrer ainsi les colonnes inutiles. Pour cela, nous pouvons utiliser un vecteur contenant soit les positions des colonnes (1 pour la première colonne, 2 pour la seconde et ainsi de suite), soit les noms des colonnes.\n\n```{r}\n#| message: false\n#| warning: false\n# Conserver les 5 premières colonnes\ndf2 <- df[1:5]\n\n# Conserver les colonnes 1, 5, 10 et 15\ndf3 <- df[c(1,5,10,15)]\n\n# Cela peut aussi être utilisé pour changer l'ordre des champs\ndf3 <- df[c(10,15,1,5)]\n\n# Conserver les colonnes 1 à 5, 7 à 12, 17 et 22\ndf4 <- df[c(1:5,7:12,17,22)]\n\n# Conserver les colonnes avec leurs noms\ndf5 <- df[c(\"SRIDU\" , \"KM2\" , \"Pop2016\" , \"MaisonIndi\" , \"LoyerMed\")]\n```\n\n##### Suppression de colonnes {#sec-014223}\n\nIl est parfois plus intéressant et rapide de  supprimer directement des colonnes plutôt que de recréer un nouveau *DataFrame*. Pour ce faire, nous attribuons la valeur `NULL` à ces colonnes.\n\n```{r}\n#| message: false\n#| warning: false\n# Supprimer les colonnes 2, 3 et 5\ndf3[c(2,3,5)] <- list(NULL)\n\n# Supprimer une colonne avec son nom\ndf4$OID <- NULL\n\n# Supprimer plusieurs colonnes par leur nom\ndf5[c(\"SRIDU\" , \"LoyerMed\")] <- list(NULL)\n```\n\nNotez que si vous supprimez une colonne, vous ne pouvez pas revenir en arrière. Il faudra recharger votre jeu de données ou éventuellement relancer les calculs qui avaient produit cette colonne.\n\n##### Modification du nom des colonnes {#sec-014224}\n\nIl est possible de changer le nom d'une colonne. Cette opération est importante pour faciliter la lecture du *DataFrame* ou encore s'assurer que l'exportation du *DataFrame* dans un format particulier (tel que *.dbf* qui ne supporte que les noms de colonnes avec moins de 10 caractères) ne posera pas de problème.\n\n```{r}\n#| message: false\n#| warning: false\n# Voici les noms des colonnes\nnames(df5)\n\n# Renommer toutes les colonnes\nnames(df5) <- c('superficie_km2','population_2016', 'maison_individuelle_prt')\nnames(df5)\n\n# Renommer avec dplyr\nlibrary(dplyr)\ndf4 <- rename(df4, \"population_2016\" = \"Pop2016\",\n              \"prs_moins_14ans_prt\" = \"A014\",\n              \"prs_15_64_ans_prt\" = \"A1564\",\n              \"prs_65plus_ans_prt\" = \"A65plus\"\n              )\n```\n\n\n#### Calcul de nouvelles variables {#sec-01423}\n\nIl est possible d'utiliser les colonnes de type numérique pour calculer de nouvelles colonnes en utilisant les opérateurs mathématiques vus dans la [section @sec-0135]. Prenons un exemple concret : calculons la densité de population par secteur de recensement dans notre *DataFrame*, puis affichons un résumé de cette nouvelle variable.\n\n```{r}\n#| message: false\n#| warning: false\n# Calcul de la densité\ndf$pop_density_2016 <- df$Pop2016 / df$KM2\n\n# Statistiques descriptives\nsummary(df$pop_density_2016)\n```\n\nNous pouvons aussi calculer le ratio entre le nombre de maisons et le nombre d'appartements.\n\n```{r}\n#| message: false\n#| warning: false\n\n# Calcul du ratio\ndf$total_maison <- (df$MaisonIndi + df$MaisJumule + df$MaisRangee + df$AutreMais)\ndf$total_apt <- (df$AppDuplex + df$App5Moins + df$App5Plus)\ndf$ratio_maison_apt <- df$total_maison / df$total_apt\n```\n\nRetenez ici que R applique le calcul à chaque ligne de votre jeu de données et stocke le résultat dans une nouvelle colonne. Cette opération est du calcul vectoriel : toute la colonne est calculée en une seule fois. R est d'ailleurs optimisé pour le calcul vectoriel.\n\n#### Fonctions mathématiques {#sec-01424}\n\nR propose un ensemble de fonctions de base pour effectuer du calcul. Voici une liste non exhaustive des principales fonctions : \n\n* `abs` calcule la valeur absolue de chaque valeur d'un vecteur;\n\n* `sqrt` calcule la racine carrée de chaque valeur d'un vecteur;\n\n* `log` calcule le logarithme de chaque valeur d'un vecteur;\n\n* `exp` calcule l'exponentielle de chaque valeur d'un vecteur;\n\n* `factorial` calcule la factorielle de chaque valeur d'un vecteur;\n\n* `round` arrondit la valeur d'un vecteur;\n\n* `ceiling`, `floor` arrondit à l'unité supérieure ou inférieure de chaque valeur d'un vecteur;\n\n* `sin`, `asin`, `cos`, `acos`, `tan`, `atan` sont des fonctions de trigonométrie;\n\n* `cumsum` calcule la somme cumulative des valeurs d'un vecteur.\n\nCes fonctions sont des fonctions vectorielles puisqu'elles s'appliquent à tous les éléments d'un vecteur. Si votre vecteur en entrée comprend cinq valeurs, le vecteur en sortie comprendra aussi cinq valeurs.\n\nÀ l'inverse, les fonctions suivantes s'appliquent directement à l'ensemble d'un vecteur et ne vont renvoyer qu'une seule valeur :\n\n* `sum` calcule la somme des valeurs d'un vecteur;\n\n* `prod` calcule le produit des valeurs d'un vecteur;\n\n* `min`, `max` renvoient les valeurs maximale et minimale d'un vecteur;\n\n* `mean`, `median` renvoient la moyenne et la médiane d'un vecteur;\n\n* `quantile` renvoie les percentiles d'un vecteur.\n\n#### Fonctions pour manipuler des chaînes de caractères {#sec-01425}\n\nOutre les données numériques, vous aurez à travailler avec des données de type texte (`string`). Le `tidyverse` avec le *package* `stringr` offre des fonctions très intéressantes pour manipuler ce type de données. Pour un aperçu de toutes les fonctions offertes par `stringr`, référez-vous à sa [*Cheat Sheet*](https://github.com/rstudio/cheatsheets/blob/master/strings.pdf){target=\"_blank\"}. Commençons avec un *DataFrame* assez simple comprenant des adresses et des noms de personnes.\n\n```{r}\n#| message: false\n#| warning: false\nlibrary(stringr)\n\ndf <- data.frame(\n  noms = c(\"Jérémy Toutanplace\" , \"constant Tinople\" , \"dino Resto\" , \"Luce tancil\"),\n  adresses = c('15 rue Levy', '413 Blvd Saint-Laurent', '3606 rue Duké', '2457 route St Marys')\n)\n```\n\n##### Majuscules et minuscules {#sec-014251}\n\nPour harmoniser ce *DataFrame*, nous mettons, dans un premier temps, des majuscules à la première lettre des prénoms et des noms des individus avec la fonction `str_to_title`.\n\n```{r}\n#| message: false\n#| warning: false\ndf$noms_corr <- str_to_title(df$noms)\nprint(df$noms_corr)\n```\n\nNous pourrions également tout mettre en minuscules ou tout en majuscules.\n\n```{r}\n#| message: false\n#| warning: false\ndf$noms_min <- tolower(df$noms)\ndf$noms_maj <- toupper(df$noms)\nprint(df$noms_min)\nprint(df$noms_maj)\n```\n\n##### Remplacement du texte {#sec-014252}\n\nLes adresses comprennent des caractères accentués. Ce type de caractères cause régulièrement des problèmes d'encodage. Nous pourrions alors décider de les remplacer par des caractères simples avec la fonction `str_replace_all`.\n\n```{r}\n#| message: false\n#| warning: false\ndf$adresses_1 <- str_replace_all(df$adresses,'é','e')\nprint(df$adresses_1)\n```\n\nLa même fonction peut être utilisée pour remplacer les *St* par *Saint* et les *Blvd* par *Boulevard*.\n\n```{r}\n#| message: false\n#| warning: false\ndf$adresses_2 <- str_replace_all(df$adresses_1,' St ',' Saint ')\ndf$adresses_3 <- str_replace_all(df$adresses_2,' Blvd ',' Boulevard ')\nprint(df$adresses_3)\n```\n\n##### Découpage du texte {#sec-014253}\n\nIl est parfois nécessaire de découper du texte pour en extraire des éléments. Nous devons alors choisir un caractère de découpage. Dans notre exemple, nous pourrions vouloir extraire les numéros civiques des adresses en sélectionnant le premier espace comme caractère de découpage, et en utilisant la fonction `str_split_fixed`.\n\n```{r}\n#| message: false\n#| warning: false\ndf$num_civique <- str_split_fixed(df$adresses_3, ' ', n=2)[,1]\nprint(df$num_civique)\n```\n\nPour être exact, sachez que pour notre exemple, la fonction `str_split_fixed` renvoie deux colonnes de texte : une avec le texte avant le premier espace, soit le numéro civique, et une avec le reste du texte. Le nombre de colonnes est contrôlé par l'argument `n`. Si `n = 1`, la fonction ne fait aucun découpage; avec `n = 2` la fonction découpe en deux parties le texte avec la première occurrence du délimiteur et ainsi de suite.  En ajoutant `[,1]` à la fin, nous indiquons que nous souhaitons garder seulement la première des deux colonnes.\n\nIl est également possible d'extraire des parties de texte et de ne garder par exemple que les *N* premiers caractères ou les *N* derniers caractères : \n\n```{r}\n#| message: false\n#| warning: false\n# Ne garder que les 5 premiers caractères\nsubstr(df$adresses_3, start = 1, stop = 5)\n\n# Ne garder que les 5 derniers caractères\nn_caract <- nchar(df$adresses_3)\nsubstr(df$adresses_3, start = n_caract-4, stop = n_caract)\n```\n\nNotez que les paramètres `start` et `stop` de la fonction `substr` peuvent accepter un vecteur de valeurs. Il est ainsi possible d'appliquer une sélection de texte différente à chaque chaîne de caractères dans notre vecteur en entrée. Nous pourrions par exemple vouloir récupérer tout le texte avant le second espace pour garder uniquement le numéro civique et le type de rue.\n\n```{r}\n#| message: false\n#| warning: false\n# Étape 1 : récupérer les positions des espaces pour chaque adresses\npositions <- str_locate_all(df$adresses_3, \" \")\n# Étape 2 : récupérer les positions des seconds espaces\nsec_positions <- sapply(positions, function(i){\n  i[2,1]\n})\n# Étape 3 : appliquer le découpage\nsubstr(df$adresses_3, start = 1, stop = sec_positions-1)\n```\n\n\n##### Concaténation du texte {#sec-014254}\n\nÀ l'inverse du découpage, il est parfois nécessaire de concaténer des éléments de texte, ce qu'il est possible de réaliser avec la fonction `paste`.\n\n```{r}\n#| message: false\n#| warning: false\ndf$texte_complet <- paste(df$noms_corr, df$adresses_3, sep = \" : \")\nprint(df$texte_complet)\n```\n\nLe paramètre `sep` permet d'indiquer le ou les caractères à intercaler entre les éléments à concaténer. Notez qu'il est possible de concaténer plus que deux éléments.\n\n```{r}\n#| message: false\n#| warning: false\ndf$ville <- c('Montreal','Montreal','Montreal','Montreal')\npaste(df$noms_corr, df$adresses_3, df$ville, sep = \", \")\n```\n\nSi vous souhaitez concaténer des éléments de texte sans séparateur, la fonction `paste0` peut être plus simple à utiliser.\n\n```{r}\n#| message: false\n#| warning: false\npaste0(\"Please conca\", \"tenate me!\")\n```\n\n#### Manipulation des colonnes de type date {#sec-01426}\n\nNous avons vu que les principaux types de données dans R sont le numérique, le texte, le booléen et le facteur. Il existe d'autres types introduits par différents *packages*. Nous abordons ici les types date et heure (*date* and *time*). Pour les manipuler, nous privilégions l'utilisation du *package* `lubridate` du `tidyverse`. Pour illustrer le tout, nous l'utilisons avec un jeu de données ouvertes de la Ville de Montréal représentant les collisions routières impliquant au moins un cycliste survenues après le 1^er^ janvier 2017.\n\n```{r}\n#| message: false\n#| warning: false\naccidents_df <- read.csv(file=\"data/priseenmain/accidents.csv\", sep = \",\")\nnames(accidents_df)\n```\n\nNous disposons de trois colonnes représentant respectivement l'heure, la date et le nombre de victimes impliquées dans la collision.\n\n##### Du texte à la date {#sec-014261}\n\nActuellement, les colonnes `HEURE_ACCDN` et `DT_ACCDN` sont au format texte. Nous pouvons afficher quelques lignes du jeu de données avec la fonction `head` pour visualiser comment elles ont été saisies.\n\n```{r}\n#| message: false\n#| warning: false\nhead(accidents_df, n = 5)\n```\n\nUn peu de ménage s'impose : les heures sont indiquées comme des périodes d'une heure. Nous utilisons la fonction `str_split_fixed` du *package* `stringr` pour ne garder que la première partie de l'heure (avant le tiret). Ensuite, Nous concaténons l'heure et la date avec la fonction `paste`, puis nous convertissons ce résultat en un objet *date-time*.\n\n```{r}\n#| message: false\n#| warning: false\nlibrary(lubridate)\n\n# Étape 1 : découper la colonne Heure_ACCDN\naccidents_df$heure <- str_split_fixed(accidents_df$HEURE_ACCDN, \"-\", n=2)[,1]\n# Étape 2 : concaténer l'heure et la date\naccidents_df$date_heure <- paste(accidents_df$DT_ACCDN, \n                                 accidents_df$heure,\n                                 sep = ' ')\n# Étape 3 : convertir au format datetime\naccidents_df$datetime <- as_datetime(accidents_df$date_heure,\n                                     format = \"%Y/%m/%d %H:%M:%S\")\n```\n\nPour effectuer la conversion, nous avons utilisé la fonction `as_datetime` du *package* `lubridate`. Elle prend comme paramètre un vecteur de texte et une indication du format de ce vecteur de texte. Il existe de nombreuses façons de spécifier une date et une heure et l'argument *format* permet d'indiquer celle à utiliser. Dans cet exemple, la date est structurée comme suit : \n`année/mois/jour heure:minute:seconde`, ce qui se traduit par le format `%Y/%m/%d %H:%M:%S`.\n\n* %Y signifie une année indiquée avec quatre caractères : 2017;\n\n* %m signifie un mois, indiqué avec deux caractères : 01, 02, 03, ... 12;\n\n* %d signifie un jour, indiqué avec deux caractères : 01, 02, 03, ... 31;\n\n* %H signifie une heure, au format 24 heures avec deux caractères : 00, 02, ... 23;\n\n* %M signifie des minutes indiquées avec deux caractères : 00, 02, ... 59;\n\n* %S signifie des secondes, indiquées avec deux caractères : 00, 02, ... 59.\n\nNotez que les caractères séparant les années, jours, heures, etc. sont aussi à indiquer dans le format. Dans notre exemple, nous utilisons la barre oblique (`/`) pour séparer les éléments de la date et le deux points (`:`) pour l'heure, et une espace pour séparer la date et l'heure.\n\nIl existe d'autres nomenclatures pour spécifier un format *datetime* : par exemple, des mois renseignés par leur nom, l'indication AM-PM, etc. Vous pouvez vous référer à la documentation de la fonction `strptime` (`help(strptime)`) pour explorer les différentes nomenclatures et choisir celle qui vous convient. Bien évidemment, il est nécessaire que toutes les dates de votre colonne soient renseignées dans le même format, pour éviter que la fonction ne retourne la valeur `NA` lorsqu'elle ne peut lire le format. Après toutes ces opérations, rejetons un oeil à notre *DataFrame*.\n\n```{r}\n#| message: false\n#| warning: false\nhead(accidents_df, n = 5)\n```\n\n##### Extraction des informations d'une date {#sec-014262}\n\nÀ partir de la nouvelle colonne `datetime`, nous sommes en mesure d'extraire des informations intéressantes comme : \n\n* le nom du jour de la semaine avec la fonction `weekdays`\n```{r}\n#| message: false\n#| warning: false\naccidents_df$jour <- weekdays(accidents_df$datetime)\n```\n\n* la période de la journée avec les fonctions `am` et `pm` \n```{r}\n#| message: false\n#| warning: false\naccidents_df$AM <- am(accidents_df$datetime)\naccidents_df$PM <- pm(accidents_df$datetime)\nhead(accidents_df[c(\"jour\", \"AM\", \"PM\")], n=5)\n```\n\nIl est aussi possible d'accéder aux sous-éléments d'un *datetime* comme l'année, le mois, le jour, l'heure, la minute et la seconde avec les fonctions `year()`, `month()`,`day()`, `hour()`,  `minute()` et `second()`.\n\n##### Calcul d'une durée entre deux *datetime* {#sec-014263}\n\nUne autre utilisation intéressante du format *datetime* est de calculer des différences de temps. Par exemple, nous pourrions utiliser le nombre de minutes écoulées depuis 7 h comme une variable dans une analyse visant à déterminer le moment critique des collisions routières durant l'heure de pointe du matin. \nPour cela, nous devons créer un *datetime* de référence en concaténant la date de chaque observation, et le temps `07:00:00`, qui est notre point de départ.\n\n```{r}\n#| message: false\n#| warning: false\naccidents_df$date_heure_07 <- paste(accidents_df$DT_ACCDN, \n                                 '07:00:00',\n                                 sep = ' ')\naccidents_df$ref_datetime <- as_datetime(accidents_df$date_heure_07,\n                                     format = \"%Y/%m/%d %H:%M:%S\")\n```\nIl ne nous reste plus qu'à calculer la différence de temps entre la colonne *datetime* et notre temps de référence *ref_datetime*.\n\n```{r}\n#| message: false\n#| warning: false\naccidents_df$diff_time <- difftime(accidents_df$datetime,\n                                   accidents_df$ref_datetime,\n                                   units = 'min')\n```\n\nNotez qu'ici la colonne *diff_time* est d'un type spécial : une différence temporelle (*difftime*). Il faut encore la convertir au format numérique pour l'utiliser avec la fonction `as.numeric`. Par curiosité, réalisons rapidement un histogramme avec la fonction `hist` pour analyser rapidement cette variable d'écart de temps!\n\n```{r}\n#| label: fig-fig015\n#| fig-cap: Répartition temporelle des accidents à vélo\n#| warning: false\n#| fig.align: \"center\"\n#| out.width: \"65%\"\n\naccidents_df$diff_time_num <- as.numeric(accidents_df$diff_time)\nhist(accidents_df$diff_time_num, breaks = 50)\n```\n\nNous observons clairement deux pics, un premier entre 0 et 100 (entre 7 h et 8 h 30 environ) et un second plus important entre 550 et 650 (entre 16 h et 17 h 30 environ), ce qui correspond sans surprise aux heures de pointe (@fig-fig015). Il est intéressant de noter que plus d'accidents se produisent à l'heure de pointe du soir qu'à celle du matin.\n\n##### Fuseau horaire {#sec-014264}\n\nLorsque nous travaillons avec des données provenant de différents endroits dans le monde ou que nous devons tenir compte des heures d'été et d'hiver, il convient de tenir compte du fuseau horaire. Pour créer une date avec un fuseau horaire, il est possible d'utiliser le paramètre `tz` dans la fonction `as_datetime` et d'utiliser l’identifiant du fuseau approprié. Dans notre cas, les données d'accident ont été collectées à Montréal, qui a un décalage de -5 heures par rapport au temps de référence UTC (+1 heure en été). Le code spécifique de ce fuseau horaire est *EDT*; il est facile de trouver ces codes avec le site web [timeanddate.com](https://www.timeanddate.com/time/map/).\n\n```{r}\n#| message: false\n#| warning: false\naccidents_df$datetime <- as_datetime(accidents_df$date_heure,\n                                     format = \"%Y/%m/%d %H:%M:%S\",\n                                     tz = \"EDT\")\n```\n\n#### Recodage des variables {#sec-01427}\n\nRecoder une variable signifie changer ses valeurs selon une condition afin d'obtenir une nouvelle variable. Si nous reprenons le jeu de données précédent sur les accidents à vélo, nous pourrions vouloir créer une nouvelle colonne nous indiquant si la collision a eu lieu en heures de pointe ou non. Nous obtiendrions ainsi une nouvelle variable avec seulement deux catégories plutôt que la variable numérique originale. Nous pourrions aussi définir quatre catégories avec l'heure de pointe du matin, l'heure de pointe du soir, le reste de la journée et la nuit.\n\n##### Cas binaire avec `ifelse` {#sec-014271}\n\nSi nous ne souhaitons créer que deux catégories, le plus simple est d'utiliser la fonction `ifelse`. Cette fonction évalue une condition ([section @sec-0135]) pour chaque ligne d'un *DataFrame* et produit un nouveau vecteur. Créons donc une variable binaire indiquant si une collision a eu lieu durant les heures de pointe ou hors heures de pointe. Nous devons alors évaluer les conditions suivantes : \n\nEst-ce que l'accident a eu lieu entre 7 h (0) **ET** 9 h (120), **OU** entre 16 h 30 (570) **ET** 18 h 30 (690)?\n\n```{r}\n#| message: false\n#| warning: false\ntable(is.na(accidents_df$diff_time_num))\n```\n\nNotons dans un premier temps que nous avons 40 observations sans valeur pour la colonne `diff_time_num`. Il s'agit d'observations pour lesquelles nous ne disposions pas de dates au départ.\n\n```{r}\n#| message: false\n#| warning: false\nCond1 <- accidents_df$diff_time_num >= 0 & accidents_df$diff_time_num <= 120\nCond2 <- accidents_df$diff_time_num >= 570 & accidents_df$diff_time_num <= 690\n\naccidents_df$moment_bin <- ifelse(Cond1 | Cond2,\n                                  \"en heures de pointe\",\n                                  \"hors heures de pointe\")\n```\n\nComme vous pouvez le constater, la fonction `ifelse` nécessite trois arguments : \n\n* une condition, pouvant être `TRUE` ou `FALSE`;\n\n* la valeur à renvoyer si la condition est `FALSE`;\n\n* la valeur à renvoyer si la condition est `TRUE`.\n\nAvec la fonction `table`, nous pouvons rapidement visualiser les effectifs des deux catégories ainsi créées : \n\n```{r}\n#| message: false\n#| warning: false\ntable(accidents_df$moment_bin)\n\n# Vérifier si nous avons toujours seulement 40 NA\ntable(is.na(accidents_df$moment_bin))\n```\nLes heures de pointe représentent quatre heures de la journée, ce qui nous laisse neuf heures hors heures de pointe entre 7 h et 20 h.\n\n```{r}\n#| message: false\n#| warning: false\n# Ratio de collisions routières en heures de pointe\n(841 / 2414) / (4 / 13)\n\n# Ratio de collisions routières hors heure de pointe\n(1573 / 2414) / (9 / 13)\n```\n\nEn rapportant les collisions aux durées des deux périodes, nous observons une nette surreprésentation des collisions impliquant un vélo pendant les heures de pointe d'environ 13 % comparativement à la période hors des heures de pointe.\n\n##### Cas multiple avec la `case_when` {#sec-014272}\n\nLorsque nous souhaitons créer plus que deux catégories, il est possible soit d'enchaîner plusieurs fonctions `ifelse` (ce qui produit un code plus long et moins lisible), soit d'utiliser la fonction `case_when` du *package* `dplyr` du `tidyverse`. Reprenons notre exemple et créons quatre catégories : \n\n* en heures de pointe du matin;\n\n* en heures de pointe du soir;\n\n* le reste de la journée (entre 7 h et 20 h);\n\n* la nuit (entre 21 h et 7 h).\n\n```{r}\n#| message: false\n#| warning: false\nlibrary(dplyr)\n\naccidents_df$moment_multi <- case_when(\n  accidents_df$diff_time_num >= 0 & accidents_df$diff_time_num <= 120 ~ \"pointe matin\",\n  accidents_df$diff_time_num >= 570 & accidents_df$diff_time_num <= 690 ~ \"pointe soir\",\n  accidents_df$diff_time_num > 690 & accidents_df$diff_time_num < 780 ~ \"journee\",\n  accidents_df$diff_time_num > 120 & accidents_df$diff_time_num < 570 ~ \"journee\",\n  accidents_df$diff_time_num < 0 | accidents_df$diff_time_num >= 780 ~ \"nuit\"\n)\n\ntable(accidents_df$moment_multi)\n\n# Vérifions encore les NA\ntable(is.na(accidents_df$moment_multi))\n```\n\nLa syntaxe de cette fonction est un peu particulière. Elle accepte un nombre illimité (ou presque) d'arguments. Chaque argument est composé d'une condition et d'une valeur à renvoyer si la condition est vraie; ces deux éléments étant reliés par le symbole `~`. Notez que toutes les évaluations sont effectuées dans l'ordre des arguments. En d'autres termes, la fonction teste d'abord la première condition et assigne ses valeurs, puis recommence pour les prochaines conditions. Ainsi, si une observation (ligne du tableau de données) obtient `TRUE` à plusieurs conditions, elle obtient au final la valeur de la dernière condition validée. Dans l'exemple précédent, si la première condition est `accidents_df$diff_time_num >= 0 | accidents_df$diff_time_num <= 120`, alors nous obtenons pour seule valeur en résultat `\"pointe matin\"` puisque chaque observation a une valeur supérieure à 0 et que nous avons remplacé l'opérateur `&` (ET) par l'opérateur `|` (OU). \n\n#### Sous-sélection d'un *DataFrame* {#sec-01428}\n\nDans cette section, nous voyons comment extraire des sous-parties d'un *DataFrame*. Il est possible de sous-sélectionner des lignes et des colonnes en se basant sur des conditions ou leur index. Pour cela, nous utilisons un jeu de données fourni avec R : le jeu de données **iris** décrivant des fleurs du même nom.\n\n```{r}\n#| message: false\n#| warning: false\ndata(\"iris\")\n\n# Nombre de lignes et de colonnes\ndim(iris)\n```\n\n##### Sous-sélection des lignes {#sec-014281}\n\nSous-sélectionner des lignes par index est relativement simple. Admettons que nous souhaitons sélectionner les lignes 1 à 5, 10 à 25, 37 et 58.\n\n```{r}\n#| message: false\n#| warning: false\nsub_iris <- iris[c(1:5, 10:25, 37, 58),]\nnrow(sub_iris)\n```\n\nSous-sélectionner des lignes avec une condition peut être effectué soit avec une syntaxe similaire, soit en utilisant la fonction `subset`. Sélectionnons toutes les fleurs de l'espèce Virginica.\n\n```{r}\n#| message: false\n#| warning: false\niris_virginica1 <- iris[iris$Species == \"virginica\",]\niris_virginica2 <- subset(iris, iris$Species == \"virginica\")\n\n# Vérifions que les deux DataFrames ont le même nombre de lignes\nnrow(iris_virginica1) == nrow(iris_virginica2)\n```\n\nVous pouvez utiliser, dans les deux cas, tous les opérateurs vus dans les sections [-@sec-01351] et [-@sec-01353]. L'enjeu est d'arriver à créer un vecteur booléen final permettant d'identifier les observations à conserver.\n\n##### Sous-sélection des colonnes {#sec-014282}\n\nNous avons déjà vu comment sélectionner des colonnes en utilisant leur nom ou leur index dans la [section @sec-014221]. Ajoutons ici un cas particulier où nous souhaitons sélectionner des colonnes selon une condition. Par exemple, nous pourrions vouloir conserver que les colonnes comprenant le mot *Length*. Pour cela, nous utilisons la fonction `grepl`, permettant de déterminer si des caractères sont présents dans une chaîne de caractères.\n\n```{r}\n#| message: false\n#| warning: false\nnom_cols <- names(iris)\nprint(nom_cols)\n\ntest_nom <- grepl(\"Length\", nom_cols, fixed = TRUE)\nok_nom <- nom_cols[test_nom]\n\niris_2 <- iris[ok_nom]\nprint(names(iris_2))\n```\n\nIl est possible d'obtenir ce résultat en une seule ligne de code, mais elle est un peu moins lisible.\n\n```{r}\n#| message: false\n#| warning: false\niris2 <- iris[names(iris)[grepl(\"Length\", names(iris), fixed = TRUE)]]\n```\n\n##### Sélection des colonnes et des lignes {#sec-014283}\n\nNous avons vu qu'avec les crochets `[]`, nous pouvons extraire les colonnes et les lignes d'un *DataFrame*. Il est possible de combiner les deux opérations simultanément. Pour ce faire, il faut indiquer en premier les index ou la condition permettant de sélectionner une ligne, puis les index ou la condition pour sélectionner les colonnes : `[index_lignes , index_colonnes]`. Sélectionnons cinq premières lignes et les trois premières colonnes du jeu de données iris : \n\n```{r}\n#| message: false\n#| warning: false\niris_5x3 <- iris[c(1,2,3,4,5), c(1,2,3)]\nprint(iris_5x3)\n```\n\nCombinons nos deux exemples précédents pour sélectionner uniquement les lignes avec des fleurs de l'espèce *virginica*, et les colonnes avec le mot *Length*.\n\n```{r}\n#| message: false\n#| warning: false\niris_virginica3 <- iris[iris$Species == \"virginica\",\n                       names(iris)[grepl(\"Length\", names(iris), fixed = TRUE)]]\nhead(iris_virginica3, n=5)\n```\n\n#### Fusion de *DataFrames* {#sec-01429}\n\nTerminons cette section avec la fusion de *DataFrames*. Nous distinguons deux méthodes répondant à des besoins différents : par ajout ou par jointure.\n\n##### Fusion de *DataFrames* par ajout {#sec-014291}\n\nAjouter deux *DataFrames* peut se faire en fonction de leurs colonnes ou en fonction de leurs lignes. Dans ces deux cas, nous utilisons respectivement les fonctions `cbind` et `rbind`. La @fig-fig016 résume graphiquement le fonctionnement des deux fonctions.\n\n![Fusion de DataFrames](images/Chap01/rbind_cbind.png){#fig-fig016 width=\"30%\" fig-align=\"center\"}\n\nPour que `cbind` fonctionne, il faut que les deux *DataFrames* aient le même nombre de lignes. Pour `rbind`, les deux *DataFrames* doivent avoir le même nombre de colonnes. Prenons à nouveau comme exemple le jeu de données iris. Nous commençons par le séparer en trois sous-jeux de données comprenant chacun une espèce d'iris. Puis, nous fusionnons deux d'entre eux avec la fonction `rbind`.\n\n```{r}\n#| message: false\n#| warning: false\niris1 <- subset(iris, iris$Species == \"virginica\")\niris2 <- subset(iris, iris$Species == \"versicolor\")\niris3 <- subset(iris, iris$Species == \"setosa\")\n\niris_comb <- rbind(iris2,iris3)\n```\n\nNous pourrions aussi extraire dans les deux *DataFrames* les colonnes comprenant le mot *Length* et le mot *Width*, puis les fusionner.\n\n```{r}\n#| message: false\n#| warning: false\niris_l <- iris[names(iris)[grepl(\"Length\", names(iris), fixed = TRUE)]]\niris_w <- iris[names(iris)[grepl(\"Width\", names(iris), fixed = TRUE)]]\n\niris_comb <- cbind(iris_l,iris_w)\nnames(iris_comb)\n```\n\n##### Jointure de *DataFrames* {#sec-014292}\n\nUne jointure est une opération un peu plus complexe qu'un simple ajout. L'idée est d'associer des informations de plusieurs *DataFrames* en utilisant une colonne (appelée une clef) présente dans les deux jeux de données. Nous distinguons plusieurs types de jointure : \n\n* Les jointures internes permettant de combiner les éléments communs entre deux *DataFrames* A **et** B.\n\n* La jointure complète permettant de combiner les éléments présents dans A **ou** B.\n\n* La jointure à gauche, permettant de ne conserver que les éléments présents dans A même s'ils n'ont pas de correspondance dans B.\n\nCes trois jointures sont présentées à la @fig-fig017; pour ces trois cas, la colonne commune se nomme *id*.\n\n\n![Jointure de DataFrames](images/Chap01/merging.png){#fig-fig017 width=\"30%\" fig-align=\"center\"}\n\nVous retiendrez que les deux dernières jointures peuvent produire des valeurs manquantes. Pour réaliser ces opérations, nous utilisons la fonction `merge`. Prenons un exemple simple à partir d'un petit jeu de données.\n\n```{r}\n#| message: false\n#| warning: false\nauteurs <- data.frame(\n    name = c(\"Tukey\", \"Venables\", \"Tierney\", \"Ripley\", \"McNeil\", \"Apparicio\"),\n    nationality = c(\"US\", \"Australia\", \"US\", \"UK\", \"Australia\", \"Canada\"),\n    retired = c(\"yes\", rep(\"no\", 5)))\nlivres <- data.frame(\n    aut = c(\"Tukey\", \"Venables\", \"Tierney\", \"Ripley\", \"Ripley\", \"McNeil\" , \"Wickham\"),\n    title = c(\"Exploratory Data Analysis\",\n              \"Modern Applied Statistics ...\",\n              \"LISP-STAT\",\n              \"Spatial Statistics\", \"Stochastic Simulation\",\n               \"Interactive Data Analysis\", \"R for Data Science\"))\n```\n\nNous avons donc deux *DataFrames*, le premier décrivant des auteurs et le second des livres. Effectuons une première jointure interne afin de savoir pour chaque livre la nationnalité de son auteur et si ce dernier est à la retraite.\n\n```{r}\n#| message: false\n#| warning: false\ndf1 <- merge(livres, auteurs, #les deux DataFrames \n             by.x = \"aut\", by.y = \"name\", #les noms des colonnes de jointures\n             all.x = FALSE, all.y = FALSE)\nprint(df1)\n```\n\nCette jointure est interne, car les deux paramètres *all.x* et *all.y* ont pour valeur `FALSE`. Ainsi, nous indiquons à la fonction que nous ne souhaitons ni garder tous les éléments du premier *DataFrame* ni tous les éléments du second, mais uniquement les éléments présents dans les deux. Vous noterez ainsi que le livre \"R for Data Science\" n'est pas présent dans le jeu de données final, car son auteur \"Wickham\" ne fait pas partie du *DataFrame* auteurs. De même, l'auteur \"Apparicio\" n'apparaît pas dans la jointure, car aucun livre dans le *DataFrame* books n'a été écrit par cet auteur.\n\nPour conserver tous les livres, nous pouvons effectuer une jointure à gauche en renseignant `all.x = TRUE`. Nous forçons ainsi la fonction à garder tous les livres et à mettre des valeurs vides aux informations manquantes des auteurs.\n\n```{r}\n#| message: false\n#| warning: false\ndf2 <- merge(livres, auteurs, #les deux DataFrames \n             by.x = \"aut\", by.y = \"name\", #les noms des colonnes de jointures\n             all.x = TRUE, all.y = FALSE)\nprint(df2)\n```\n\nPour garder tous les livres et tous les auteurs, nous pouvons faire une jointure complète en indiquant `all.x = TRUE` et `all.y = TRUE`.\n\n```{r}\n#| message: false\n#| warning: false\ndf3 <- merge(livres, auteurs, #les deux DataFrames \n             by.x = \"aut\", by.y = \"name\", #les noms des colonnes de jointures\n             all.x = TRUE, all.y = TRUE)\nprint(df3)\n```\n\n## Code R bien structuré {#sec-016}\n\nTerminons ici avec quelques conseils sur la rédaction d’un code R. Bien rédiger son code est essentiel pour trois raisons :\n\n1. Pouvoir relire et réutiliser son code dans le futur.\n2. Permettre à d'autres personnes de bien lire et de réutiliser votre code.\n3. Minimiser les risques d'erreurs.\n\nNe négligez pas l'importance d'un code bien rédigé et bien documenté, vous vous éviterez ainsi des migraines lorsque vous devrez exhumer du code écrit il y a plusieurs mois.\n\nVoici quelques lignes directrices peu contraignantes, mais qui devraient vous être utiles : \n\n1. **Privilégier la clarté à la concision** : il vaut mieux parfois scinder une ligne de code en plusieurs sous-étapes afin de faciliter la lecture de l’opération réalisée. Par exemple, si nous reprenons une ligne de code d’une section précédente où nous sélectionnions l'ensemble des colonnes du jeu de données `iris` comprenant le mot `Length` : \n```{r}\n#| message: false\n#| warning: false\niris_l <- iris[names(iris)[grepl(\"Length\", names(iris), fixed = TRUE)]]\n```\n\nNous pouvons simplifier la lecture de ce code en détaillant les différentes étapes comme suit : \n\n```{r}\n#| message: false\n#| warning: false\nnoms_cols <- names(iris)\nsel_noms <- noms_cols[grepl(\"Length\", noms_cols, fixed = TRUE)]\niris_l <- iris[sel_noms]\n```\n\n2. **Documenter et commenter son code le plus possible** : il est possible d'ajouter du texte dans un code R qui ne sera pas exécuté, ce que nous appelons des commentaires. Typiquement, une ligne commençant par un `#` n'est pas interprétée par le logiciel. Utilisez des commentaires le plus souvent possible pour décrire les actions que vous souhaitez effectuer avec votre code. Il sera ainsi plus facile de le relire, de naviguer dedans, mais également de repérer d'éventuelles erreurs. Si nous reprenons l'exemple précédent : \n\n```{r}\n#| message: false\n#| warning: false\n# Récupération du nom des colonnes dans le DataFrame iris\nnoms_cols <- names(iris)\n# Sélection des colonnes avec les caractères \"Length\"\nsel_noms <- noms_cols[grepl(\"Length\", noms_cols, fixed = TRUE)]\n# Extraction des colonnes sélectionnées dans un nouveau DataFrame\niris_l <- iris[sel_noms]\n```\n\n3. **Éviter le code à rallonge…** : typiquement, essayez de vous limiter à des lignes de code d'une longueur maximale de 80 caractères. Au-delà de ce seuil, il est judicieux de découper votre code en plusieurs lignes.\n\n4. **Adopter une convention d'écriture** : une convention d'écriture est un ensemble de règles strictes définissant comment un code doit être rédigé. À titre d'exemple, il est parfois recommandé d'utiliser le *lowerCamelCase*, le *UpperCamelCase*, ou encore de séparer les mots par des tirets bas *upper_camel_case*. Un mélange de ces différentes conventions peut être utilisé pour distinguer les variables, les fonctions et les classes. Il peut être difficile de réellement arrêter une telle convention, car les différents *packages* dans R utilisent des conventions différentes. Dans vos propres codes, il est surtout important d'avoir une certaine cohérence et ne pas changer de convention.\n\n5. **Indenter le code** : l'indentation du code permet de le rendre beaucoup plus lisible. Indenter son code signifie d'insérer, au début de chaque ligne de code, un certain nombre d'espaces permettant d'indiquer à quel niveau de profondeur nous nous situons. Typiquement, lorsque des accolades ou des parenthèses sont ouvertes dans une fonction, une boucle ou une condition, nous rajoutons deux ou quatre espaces en début de ligne. Prenons un exemple très concret : admettons que nous écrivons une fonction affichant un résumé statistique à chaque colonne d'un jeu de données si cette colonne est de type numérique. L'indentation dans cette fonction joue un rôle crucial dans sa lisibilité. \nSans indentation et sans respecter la règle des 80 caractères, nous obtenons ceci : \n\n```{r}\n#| message: false\n#| warning: false\nsummary_all_num_cols <- function(dataset){for(col in names(dataset)){if(class(dataset[[col]] == \"numeric\")){print(summary(dataset[[col]]))}}}\n```\n\nAvec de l'indentation et des commentaires, la syntaxe est beaucoup plus lisible puisqu’elle permet de repérer facilement trois niveaux/paliers dans le code : \n\n```{r}\n#| message: false\n#| warning: false\n# Définition d'une fonction\nsummary_all_num_cols <- function(dataset){\n  # Itération sur chaque colonne de la fonction\n  for(col in names(dataset)){\n    # A chaque itération, testons si la colonne est de type numérique\n    if(class(dataset[[col]] == \"numeric\")){\n      # Si oui, nous affichons un résumé statistique pour cette colonne\n      print(summary(dataset[[col]]))\n    } # Ici nous sortons de la condition (niveau 3)\n  } # Ici nous sortons de la boucle (niveau 2)\n} # Ici nous sortons de la fonction (niveau 1)\n```\n\n6. **Adopter une structure globale pour vos scripts** : un code R peut être comparé à une recette de cuisine. Si tous les éléments sont dans le désordre et sans structure globale, la recette risque d'être très difficile à suivre. Cette structure risque de changer quelque peu en fonction de la recette ou de l'auteur(e), mais les principaux éléments restent les mêmes. Dans un code R, nous pouvons distinguer plusieurs éléments récurrents que nous vous recommandons d'organiser de la façon suivante : \n  \n  a. Charger les différents *packages* **utilisés** par le script. Cela permet dès le début du code de savoir quelles sont les fonctions et méthodes qui seront employées dans le script. Cela limite aussi les risques d'oublier des *packages* qui seraient chargés plus loin dans le code.\n  \n  b. Définir les fonctions dont vous aurez besoin en plus de celles présentes dans les *packages.* Idem, placer nos fonctions en début de code évite d'oublier de les charger ou de les chercher quand nous en avons besoin.\n  \n  c. Définir le répertoire de travail avec la fonction `setwd` et charger les données nécessaires.\n  \n  d. Effectuer au besoin les opérations de manipulation sur les données.\n  \n  e. Effectuer les analyses nécessaires en scindant si possible les différentes étapes. Notez également que l'étape de définition des fonctions complémentaires peut être effectuée dans une feuille de code séparée, et l'ensemble de ces fonctions chargées à l'aide de la fonction `source`. De même, si la manipulation des données est conséquente, il est recommandé de l'effectuer avec un code à part, d'enregistrer les données structurées, puis de les charger directement au début de votre code dédié à l'analyse.\n\n7. **Exploiter les commentaires délimitant les sections dans RStudio** :  il est possible d'écrire des commentaires d'une certaine façon pour que l'IDE les détecte comme des délimiteurs de sections. L'intérêt principal est que nous pouvons ensuite facilement naviguer entre ces sections en utilisant RStudio comme montré à la @fig-sectionsRstudio, mais aussi masquer des sections afin de faciliter la lecture du reste du code. Pour délimiter une section, il suffit d'ajouter une ligne de commentaire comprenant quatre fois les caractères `-`, `=` ou `#` à la suite. \n\n\n```{r}\n#| echo: true\n#| eval: false\n\n# Voici ma section 1 ----------------------------------\n\n# Voici ma section 2 ==================================\n\n# Voici ma section 3 ##################################\n\n# Autre exemple pour mieux marquer la rupture dans un code : \n\n#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n#### Titre de ma section 4 ####\n#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n```\n\n![Navigation dans des sections de codes avec RStudio](images/Chap01/sections_rstudio.png){#fig-sectionsRstudio width=\"100%\" fig-align=\"center\"}\n\n8. **Adopter une structure globale pour vos projets** : au-delà du script, il est nécessaire de bien structurer vos projets, le plus important étant d'utiliser une structure commune à chaque projet pour vous faciliter le travail. Nous proposons à la @fig-structFolder un exemple de structure assez générale pouvant être utilisée dans la plupart des cas. Elle sépare notamment les données originales des données structurées, ainsi que les fonctions complémentaires et la structuration des données du principal bloc d'analyse.\n\n\n![Structure de dossier recommandée pour un projet avec R](images/Chap01/structurationprojet.png){#fig-structFolder width=\"50%\" fig-align=\"center\"}\n\n\n**Ne négligez jamais l'importance d'un code bien écrit et documenté !**\n\n## Enregistrement des résultats {#sec-017}\n\nComme nous l'avons indiqué précédemment, l'ensemble des objets actuellement chargés dans votre session R sont perdus si vous la fermez. Cela peut être problématique si certains résultats nécessitent de longs temps de calcul ou si vous avez besoin de partager les objets obtenus avec d'autres personnes, mais pas le code pour les obtenir. Il est possible de retrouver les résultats d'une session précédente si ceux-ci ont été enregistrés sur votre disque dur puisque l'action d'enregistrer permet de faire passer vos objets présents dans votre mémoire vive dans des fichiers stockés sur votre disque dur. Vous pouvez pour cela utiliser la fonction `save.image` ou `save`.\n\n`save.image` enregistre une copie exacte de votre session actuelle avec tous les objets présents dans votre environnement dans un fichier `RData`. La fonction `save` permet d'être plus sélectif et de ne garder que certains objets spécifiques.\n\nVoici la syntaxe pour enregistrer toute votre session :\n\n```{r}\n#| eval: false\nsave.image(file = 'chemin/vers/mon/fichier/session.RData', compress = TRUE)\n```\n\nVous pouvez aussi utiliser le bouton d'enregistrement dans l'onglet *Environnement* dans RStudio (@fig-saveobj).\n\n\n![Bouton enregistrer la session](images/Chap01/save_session.png){#fig-saveobj width=\"25%\" fig-align=\"center\"}\n\nIl est recommandé de compresser ces fichiers (`compress = TRUE`) pour minimiser leur taille. Pour n'enregistrer que certains objets (ici `iris` et `noms_cols`), vous pouvez adapter cette syntaxe :\n\n```{r}\n#| eval: false\nsave(iris, noms_cols, file = 'chemin/vers/mon/fichier/mes_objet.RData', compress = TRUE)\n```\n\nPour récupérer ces objets dans une autre session, il suffit d'utiliser la fonction `load` :\n\n```{r}\n#| eval: false\nload(file = 'chemin/vers/mon/fichier/mes_objet.RData')\n```\n\nou d'utiliser le bouton *ouvrir* de l'onglet *Environnement* dans RStudio (@fig-loadobj).\n\n![Bouton charger un fichier RDA](images/Chap01/load_session.png){#fig-loadobj width=\"25%\" fig-align=\"center\"}\n\n## Session de travail {#sec-018}\n\nComme vous avez pu le constater dans les sections @sec-017 et @sec-0141, il est nécessaire de connaître les chemins vers les fichiers que vous souhaitez utiliser dans votre code R. Si tous ces fichiers sont organisés dans un même dossier (ce que nous vous recommandons à la @fig-structFolder, il est possible de définir un répertoire de travail avec la fonction `setwd`.\nIl est recommandé d'effectuer cette étape au début de votre code R, après le chargement des *packages*. Ainsi, vous n'aurez pas besoin de réécrire à chaque fois le chemin complet pour accéder à vos fichiers.\n\n```{r}\n#| eval: false\n# Chemin complet\nmes_donnes <- read.csv(\"C:/projets/articles/2022/mon_projet/data/mes_donnes.csv\")\n# Utilisation de setwd\nsetwd(\"C:/projets/articles/2022/mon_projet\")\nmes_donnes <- read.csv(\"data/mes_donnes.csv\")\n```\n\nLa fonction `getwd` permet d'afficher le répertoire de travail utilisé actuellement par R.\n\nSi vous utilisez RStudio, il est possible d'utiliser une petite astuce pour définir comme répertoire de travail le dossier dans lequel se trouve le fichier de code R que vous utilisez actuellement :\n\n```{r}\n#| eval: false\nsetwd(dirname(rstudioapi::getActiveDocumentContext()$path))\n```\n\nAdmettons que votre code R se trouve dans un sous dossier appelé *CodeR* de votre répertoire de travail, vous pouvez remonter d'un niveau dans votre arborescence en utilisant la syntaxe suivante :\n\n```{r}\n#| eval: false\nsetwd(paste0(dirname(rstudioapi::getActiveDocumentContext()$path), \"/..\"))\n```\n\nLe double point (`..`) indique que nous souhaitons remonter dans le dossier parent du dossier dans lequel nous se trouvons acutellement.\n\nIl existe deux solutions de rechange à l'utilisation de `setwd` que certains jugent un peu démodé.\n\n* La première est le package `here` permettant de spécifier plus facilement des chemins relatifs et de définir un *top-level directory* pour votre projet.\n* La seconde est l'utilisation de la fonctionnalité [projects](https://support.rstudio.com/hc/en-us/articles/200526207-Using-Projects) de RStudio.\n\n## Conclusion et ressources pertinentes  {#sec-019}\n\nVoilà qui conclut ce chapitre sur les bases du langage R. Vous avez maintenant les connaissances nécessaires pour commencer à travailler. N'hésitez pas à revenir sur les différentes sous-sections au besoin! Quelques ressources pertinentes qui pourraient vous être utiles sont aussi reportées au @tbl-tableRessources \n\n\n```{r}\n#| label: tbl-tableRessources\n#| tbl-cap: Ressources pertinente pour en apprendre plus sur R\n#| echo: false\n#| message: false\n#| warning: false\n\ndf <- data.frame(\n        Ressource = c(\"[Rbloggers](https://www.r-bloggers.com){target='_blank'}\" , \"[CRAN packages by date](https://cran.r-project.org/web/packages/available_packages_by_date.html){target='_blank'}\", \"[Introduction à R et au TidyVerse](https://juba.github.io/tidyverse/index.html){target='_blank'}\", \"[Numyard](https://www.youtube.com/user/TheLearnR/featured){target='_blank'}\", \"[cheatsheets](https://rstudio.com/resources/cheatsheets){target='_blank'}\"), \n        Description = c(\"Un recueil de nombreux blogues sur R : parfait pour être tenu au courant des nouveautés et faire des découvertes.\", \"Les derniers packages publiés sur *CRAN* : cela permet de garder un oeil sur les nouvelles fonctionnalités de vos packages préférés.\", \"Une excellente ressource en français pour en apprendre plus sur le tidyverse.\", \"Une chaîne YouTube pour revoir les bases de R en vidéo.\", \"Des feuilles de triche résumant les fonctionnalités de nombreux packages.\"))\n\nknitr::kable(df,\n             format.args = list(decimal.mark = ',', big.mark = \" \"),\n             col.names = c(\"Ressource\" , \"Description\"),\n             col.to.resize = c(2,3),\n             col.width = \"6cm\")\n```\n\n## Quiz de révision du chapitre {#sec-0110}\n\n```{r}\n#| label: quizChapitre01\n#| echo: false\n#| warning: false\n#| results: asis\nsource(\"code_complementaire/QuizzFunctions.R\")\nChap01Quiz <- quizz(\"quiz/Chapitre1_manipulerdesdonnees.yml\", \"Chap01\")\nrender_quizz(Chap01Quiz)\n```\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":true,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["css/quizlib.min.css"],"output-file":"01-priseenmainR.html"},"language":{"toc-title-document":"Table des matières","toc-title-website":"Sur cette page","related-formats-title":"Autres formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"La source","section-title-abstract":"Résumé","section-title-appendices":"Annexes","section-title-footnotes":"Notes de bas de page","section-title-references":"Les références","section-title-reuse":"Réutilisation","section-title-copyright":"Droits d'auteur","section-title-citation":"Citation","appendix-attribution-cite-as":"Veuillez citer ce travail comme suit :","appendix-attribution-bibtex":"BibTeX","title-block-author-single":"Auteur·rice","title-block-author-plural":"Auteurs","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Date de publication","title-block-modified":"Modifié","callout-tip-title":"Astuce","callout-note-title":"Note","callout-warning-title":"Avertissement","callout-important-title":"Important","callout-caution-title":"Mise en garde","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Montrer tout le code","code-tools-hide-all-code":"Cacher tout le code","code-tools-view-source":"Voir les sources","code-tools-source-code":"Code source","code-line":"Ligne","code-lines":"Lignes","copy-button-tooltip":"Copier vers le presse-papier","copy-button-tooltip-success":"Copié","repo-action-links-edit":"Modifier cette page","repo-action-links-source":"Voir la source","repo-action-links-issue":"Signaler un problème ou<br>formuler une suggestion","back-to-top":"Retour au sommet","search-no-results-text":"Pas de résultats","search-matching-documents-text":"documents trouvés","search-copy-link-title":"Copier le lien vers la recherche","search-hide-matches-text":"Cacher les correspondances additionnelles","search-more-match-text":"correspondance de plus dans ce document","search-more-matches-text":"correspondances de plus dans ce document","search-clear-button-title":"Effacer","search-detached-cancel-button-title":"Annuler","search-submit-button-title":"Envoyer","search":"Recherche","toggle-section":"Basculer la section","toggle-sidebar":"Basculer la barre latérale","toggle-dark-mode":"Basculer le mode sombre","toggle-reader-mode":"Basculer en mode lecteur","toggle-navigation":"Basculer la navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Théorème","crossref-lem-title":"Lemme","crossref-cor-title":"Corollaire","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Définition","crossref-exm-title":"Exemple","crossref-exr-title":"Exercice","crossref-ch-prefix":"Chapitre","crossref-apx-prefix":"Annexe","crossref-sec-prefix":"Section","crossref-eq-prefix":"Équation","crossref-lof-title":"Liste des Figures","crossref-lot-title":"Liste des Tables","crossref-lol-title":"Liste des Listings","environment-proof-title":"Preuve","environment-remark-title":"Remarque","environment-solution-title":"Solution","listing-page-order-by":"Trier par","listing-page-order-by-default":"Ordre par défaut","listing-page-order-by-date-asc":"Le plus ancien","listing-page-order-by-date-desc":"Le plus récent","listing-page-order-by-number-desc":"Descendant","listing-page-order-by-number-asc":"Ascendant","listing-page-field-date":"Date","listing-page-field-title":"Titre","listing-page-field-description":"Description","listing-page-field-author":"Auteur·rice","listing-page-field-filename":"Nom de fichier","listing-page-field-filemodified":"Modifié","listing-page-field-subtitle":"Sous-titre","listing-page-field-readingtime":"Temps de lecture","listing-page-field-categories":"Catégories","listing-page-minutes-compact":"{0} min.","listing-page-category-all":"Tous","listing-page-no-matches":"Aucun article correspondant"},"metadata":{"lang":"fr","fig-responsive":true,"quarto-version":"1.3.353","license":"CC BY-SA","crossref":{"fig-prefix":"figure","tbl-prefix":"tableau","sec-prefix":"section","eq-prefix":"équation","fig-title":"Figure","tbl-title":"Tableau","eq-title":"Équation"},"bibliography":["references.bib"],"csl":"StyleINRS.csl","colorlinks":true,"theme":{"light":["cosmo","css/r4ds.scss"]},"fontsize":"11pt","mainfont":"Helvetica Neue,Helvetica,Arial,sans-serif","monofont":"SFMono-Regular,Menlo,Monaco,Consolas,\"Liberation Mono\",\"Courier New\",monospace"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}