{"title":"Modèles généralisés additifs","markdown":{"headingText":"Modèles généralisés additifs ","headingAttr":{"id":"sec-chap11","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\nDans les précédents chapitres, nous avons eu l'occasion d'explorer toute une panoplie de modèles : régressions linéaires, modèles généralisés, modèles généralisés à effets mixtes et modèles multiniveaux. Dans ce chapitre, nous abordons une nouvelle extension dans le monde des régressions : les modèles généralisés additifs (*Generalized additive model* en anglais — GAM). Cette extension a pour but de permettre de modéliser des relations non linéaires entre les variables indépendantes et la variable dépendante.\n\n::: bloc_package\n::: bloc_package-header\n::: bloc_package-icon\n:::\n**Liste des *packages* utilisés dans ce chapitre**\n:::\n::: bloc_package-body\n\n* Pour créer des graphiques :\n  - `ggplot2` le seul, l'unique!\n  - `ggpubr` pour combiner des graphiques et réaliser des diagrammes.\n  - `metR` pour placer des étiquettes sur des isolignes.\n  \n* Pour jouer avec des *splines* :\n  - `splines2` pour construire les fonctions de base de nombreuses *splines*.\n  - `segmented` pour ajuster des modèles avec des coefficients variant par segment.\n  \n* Pour ajuster des modèles GAM :\n  - `mgcv`, le *package* de référence pour ajuster des GAM dans R!\n  - `gamlss`, un second *package* très flexible pour ajuster des GAM.\n  - `gamlss.add`, une extension de `gamlss` ajoutant des distributions supplémentaires.\n\n* Pour analyser des modèles GAM :\n  - `itsadug` pour notamment extraire certains résultats d'un GAM.\n  - `mixedup` pour notamment extraire les effets aléatoires d'un GAM.\n  - `DHARMa` pour le diagnostic des résidus simulés.\n:::\n:::\n\n\n## Introduction {#sec-111}\n\nPuisque les modèles GAM sont une extension des modèles GLM, ils peuvent s'appliquer à des modèles pour des variables indépendantes qualitatives, de comptage ou continues. Nous l'appliquons ici, à titre d'illustration, à une variable indépendante continue. Pour rappel, la formule décrivant un modèle linéaire généralisé (GLM) utilisant une distribution normale et une fonction de lien identitaire est la suivante : \n\n$$\n\\begin{aligned}\n&Y \\sim Normal(\\mu,\\sigma)\\\\\n&g(\\mu) = \\beta_0 + \\beta X\\\\\n&g(x) = x\n\\end{aligned}\n$$ {#eq-glm1B}\n\nLes coefficients $\\beta$ permettent de quantifier l'effet des variables indépendantes (*X*) sur la moyenne (l'espérance) ($\\mu$) de la variable dépendante (*Y*). Un coefficient $\\beta_k$ négatif indique que, si la variable $X_k$ augmente, alors la variable *Y* tend à diminuer et inversement, si le coefficient est positif. L'inconvénient de cette formulation est que le modèle est capable de capter uniquement des relations linéaires entre ces variables. Or, il existe de nombreuses situations dans lesquelles une variable indépendante a un lien non linéaire avec une variable dépendante; voici quelques exemples : \n\n* Si nous mesurons le niveau de bruit émis par une source sonore (variable dépendante) à plusieurs endroits et que nous tentons de prédire l'intensité sonore en fonction de la distance à la source (variable indépendante), nous pouvons nous attendre à observer une relation non linéaire entre les deux. En effet, le son étant une énergie se dispersant selon une sphère dans l'espace, son intensité est inversement proportionnelle au carré de la distance avec la source sonore.\n\n* La concentration de la pollution atmosphérique en ville suit généralement des patrons temporels et spatiaux influencés directement par la météorologie et les activités humaines. Autrement dit, il serait absurde d'introduire l'espace de façon linéaire (avec un gradient nord-sud ou est-ouest), ou le moment de la journée de façon linéaire (comme si la pollution augmentait du matin au soir ou inversement). En guise d'exemple, la @fig-gam1, tirée de @2020_3, illustre bien ces variations temporelles pour deux polluants (le dioxyde d'azote et l'ozone).\n\n\n![Patron journalier du dioxyde d'azote et de l'ozone à Paris](images/Chap11/no2_03_patterns.png){#fig-gam1 width=\"75%\" fig-align=\"center\"}\n\n### Non-linéarité fonctionnelle {#sec-1111}\n\nIl existe de nombreuses façons d'introduire des relations non linéaires dans un modèle. La première et la plus simple à mettre en œuvre est de transformer la variable indépendante à l'aide d'une fonction inverse, exponentielle, logarithmique ou autre.\n\nPrenons un premier exemple avec une variable *Y* que nous tentons de prédire avec une variable *X*, présenté à la @fig-gam2. Si nous ajustons une droite de régression à ces données (en bleu), nous constatons que l'augmentation de *X* est associée à une augmentation de *Y*. Cependant, la droite de régression est très éloignée des données et ne capte qu'une petite partie de la relation. Une lecture attentive permet de constater que l'effet de *X* sur *Y* augmente de plus en plus rapidement à mesure que *X* augmente. Cette forme est caractéristique d'une relation exponentielle. Nous pouvons donc transformer la variable *X* avec la fonction exponentielle afin d'obtenir un meilleur ajustement (en rouge).\n\n```{r}\n#| label: fig-gam2\n#| fig-cap: Relation non linéaire exponentielle\n#| echo: false\n#| fig-align: center\n#| message: false\n#| warning: false\n#| out-width: \"50%\"\nlibrary(ggplot2)\nlibrary(ggpubr)\nlibrary(boot)\n\ntofr <- function(float){\n  return(gsub(\".\" , \",\", as.character(float), fixed = TRUE,  useBytes = TRUE))\n}\n\ndf <- data.frame(\n  x1 = rnorm(1000,0,1),\n  x2 = rnorm(1000,10,5),\n  x3 = rnorm(1000,0,3),\n  x4 = abs(rnorm(1000,0,5))\n)\n\ndf$y1 <- exp(df$x1) + rnorm(1000,0,2)\ndf$y2 <- -log(df$x2 + rnorm(1000,0,1))\ndf$y3 <- inv.logit(df$x3) + rnorm(1000,0,0.3)\ndf$y4 <- sqrt(df$x4) + rnorm(1000,0,0.2)\n\n\nggplot(df)+\n  geom_point(aes(x = x1, y = y1), size = 0.5) + \n  labs(x = \"x\", y = \"y\")  + \n  geom_smooth(aes(x = x1, y = y1), method = \"lm\",\n              se = FALSE, color = \"blue\", formula = y ~ x)+ \n  geom_smooth(aes(x = x1, y = y1), method = \"lm\",\n              se = FALSE, color = \"red\", formula = y ~ exp(x))\n\n```\n\n\nLa @fig-gam3 illustre trois autres situations avec les fonctions logarithmique, logistique inverse et racine carrée. Cette approche peut donner des résultats intéressants si vous disposez d'une bonne justification théorique sur la forme attendue de la relation entre *X* et *Y*. \n\n```{r}\n#| label: fig-gam3\n#| fig-cap: Autres relations non linéaires\n#| echo: false\n#| fig-align: center\n#| message: false\n#| warning: false\n#| out-width: \"75%\"\n\n\nP1 <- ggplot(df)+\n  geom_point(aes(x = x2, y = y2), size = 0.5) + \n  labs(x = \"x\", y = \"y\", subtitle = \"fonction logarithmique\")  + \n  geom_smooth(aes(x = x2, y = y2), method = \"lm\",\n              se = FALSE, color = \"blue\", formula = y ~ x)+ \n  geom_smooth(aes(x = x2, y = y2), method = \"lm\",\n              se = FALSE, color = \"red\", formula = y ~ log(x)) + \n  ylim(-3,2.5) + xlim(0,20)\n\nP2 <- ggplot(df)+\n  geom_point(aes(x = x3, y = y3), size = 0.5) + \n  labs(x = \"x\", y = \"y\", subtitle = \"fonction logistique inverse\")  + \n  geom_smooth(aes(x = x3, y = y3), method = \"lm\",\n              se = FALSE, color = \"blue\", formula = y ~ x)+ \n  geom_smooth(aes(x = x3, y = y3), method = \"lm\",\n              se = FALSE, color = \"red\", formula = y ~ inv.logit(x))\n\nP3 <- ggplot(df)+\n  geom_point(aes(x = x4, y = y4), size = 0.5) + \n  labs(x = \"x\", y = \"y\", subtitle = \"fonction racine carrée\")  + \n  geom_smooth(aes(x = x4, y = y4), method = \"lm\",\n              se = FALSE, color = \"blue\", formula = y ~ x)+ \n  geom_smooth(aes(x = x4, y = y4), method = \"lm\",\n              se = FALSE, color = \"red\", formula = y ~ sqrt(x))\n\nggarrange(P1, P2, P3, ncol = 2, nrow = 2)\n\n```\n\nIl existe également des cas de figure dans lesquels aucune fonction ne donne de résultats pertinents, comme illustré à la @fig-gam4. Nous constatons facilement qu'aucune des fonctions proposées n'est capable de bien capter la relation entre les deux variables. Puisque cette relation est complexe, il convient alors d'utiliser une autre stratégie pour la modéliser. \n\n```{r}\n#| label: fig-gam4\n#| echo: false\n#| fig-align: center\n#| fig-cap: Relation non linéaire plus complexe\n#| message: false\n#| warning: false\n#| out-width: \"75%\"\n\nlibrary(mgcv)\ndataset <- gamSim(eg = 1, n = 400, dist = \"normal\", scale = 1, verbose = FALSE)\n\nggplot(dataset) + \n  geom_point(aes(y = y, x = x2), size = 1) + \n  geom_smooth(aes(x = x2, y = y, color = \"lineaire\"), method = \"lm\",\n              se = FALSE, formula = y ~ x, size = 1.3) + \n  geom_smooth(aes(x = x2, y = y, color = \"logarithme\"), method = \"lm\",\n              se = FALSE, formula = y ~ log(x), size = 1.3) +\n  geom_smooth(aes(x = x2, y = y, color = \"racine carrée\"), method = \"lm\",\n              se = FALSE, formula = y ~ sqrt(x), size = 1.3) + \n  scale_color_manual(values = c(\"lineaire\" = \"#0077b6\",\n                                \"logarithme\" = \"#e63946\",\n                                \"racine carrée\" = \"#2a9d8f\"))+\n  labs(colour = 'forme fonctionelle')\n\n```\n\n\n### Non-linéarité avec des polynomiales {#sec-1112}\n\nNous avons vu, dans le chapitre sur la régression simple ([section @sec-07511]), qu'il est possible d'utiliser des polynomiales pour ajuster des relations non linéaires. Pour rappel, il s'agit simplement d'ajouter à un modèle la variable *X* à différents exposants ($X+X^2+\\dots+X^k$). Chaque exposant supplémentaire (chaque ordre supplémentaire) permet au modèle d'ajuster une relation plus complexe. Rien de tel qu'un graphique pour illustrer le tout (@fig-gam5).\n\n```{r}\n#| label: fig-gam5\n#| echo: false\n#| fig-align: center\n#| fig-cap: Visualisation de plusieurs polynomiales\n#| message: false\n#| warning: false\n#| out-width: \"70%\"\n\np1 <- ggplot(dataset) + \n  geom_point(aes(y = y, x = x2), size = 1) + \n  geom_smooth(aes(x = x2, y = y), color = \"blue\" , method = \"lm\",\n              se = FALSE, formula = y ~ x + I(x**2), size = 1.3) + \n  labs(subtitle = \"polynomiale de degré 2\", x = \"x\", y = \"y\")\n  \np2 <- ggplot(dataset) + \n  geom_point(aes(y = y, x = x2), size = 1) + \n  geom_smooth(aes(x = x2, y = y), color = \"blue\" , method = \"lm\",\n              se = FALSE, formula = y ~ x + I(x**2) + I(x**3), size = 1.3) + \n  labs(subtitle = \"polynomiale de degré 3\", x = \"x\", y = \"y\")\n\np3 <- ggplot(dataset) + \n  geom_point(aes(y = y, x = x2), size = 1) + \n  geom_smooth(aes(x = x2, y = y), color = \"blue\" , method = \"lm\",\n              se = FALSE, formula = y ~ x + I(x**2) + I(x**3) + I(x**4), size = 1.3) + \n  labs(subtitle = \"polynomiale de degré 4\", x = \"x\", y = \"y\")\n\np4 <- ggplot(dataset) + \n  geom_point(aes(y = y, x = x2), size = 1) + \n  geom_smooth(aes(x = x2, y = y), color = \"blue\" , method = \"lm\",\n              se = FALSE, formula = y ~ x + I(x**2) + I(x**3) + I(x**4)+ I(x**5), size = 1.3) + \n  labs(subtitle = \"polynomiale de degré 5\", x = \"x\", y = \"y\")\n\nggarrange(p1, p2, p3, p4, ncol = 2, nrow = 2)\n```\n\nL'enjeu est de sélectionner le bon nombre de degrés de la polynomiale pour le modèle. Chaque degré supplémentaire constitue une nouvelle variable dans le modèle, et donc un paramètre supplémentaire. Un trop faible nombre de degrés produit des courbes trop simplistes, alors qu'un nombre trop élevé conduit à un surajustement (*overfitting* en anglais) du modèle. La @fig-gam6 illustre ces deux situations.\n\n```{r}\n#| label: fig-gam6\n#| echo: false\n#| fig-align: center\n#| fig-cap: Sur et sous-ajustement d'une polynomiale\n#| message: false\n#| warning: false\n#| out-width: \"70%\"\n\nggplot(dataset) + \n  geom_point(aes(y = y, x = x2), size = 1) + \n  geom_smooth(aes(x = x2, y = y), color = \"blue\" , method = \"lm\",\n              se = FALSE, formula = y ~ x + I(x**2), size = 1.3) +\n  geom_smooth(aes(x = x2, y = y), color = \"red\" , method = \"lm\",\n              se = FALSE, formula = y ~ x + poly(x, degree = 12), size = 1.3) + \n  labs(subtitle = \"polynomiales de degrés 2 (bleu) et 12 (rouge)\", x = \"x\", y = \"y\")\n```\n\nUn des problèmes inhérents à l'approche des polynomiales est la difficulté d'interprétation. En effet, les coefficients ne sont pas directement interprétables et seule une figure représentant les prédictions du modèle permet d'avoir une idée de l'effet de la variable *X* sur la variable *Y*.\n\n### Non-linéarité par segments {#sec-1113}\n\nUn compromis intéressant offrant une interprétation simple et une relation potentiellement complexe consiste à découper la variable *X* en segments, puis d'ajuster un coefficient pour chacun de ces segments. Nous obtenons ainsi une ligne brisée et des coefficients faciles à interpréter (@fig-gam7). Nous ne présentons pas d'exemple d'application dans R, mais sachez que le *package* `segmented` permet d'ajuster ce type de modèle. \n\n```{r}\n#| label: fig-gam7\n#| echo: false\n#| fig-align: center\n#| fig-cap: Régression par segment\n#| message: false\n#| warning: false\n#| out-width: \"70%\"\n\nlibrary(segmented)\n\nmodel <- lm(y ~ x2, data = dataset)\no <- segmented(model, seg.Z = ~x2, psi = list(x2 = c(0.25,0.5)),\n  control = seg.control(display = FALSE)\n)\ndataset$fit <- broken.line(o)$fit\n\nggplot(dataset) + \n  geom_point(aes(y = y, x = x2), size = 1) + \n  geom_line(aes(x = x2, y = fit), color = \"blue\", linewidth = 1)\n```\n\nL'enjeu est alors de déterminer le nombre de points et la localisation de points de rupture. L'inconvénient majeur de cette approche est qu'en réalité, peu de phénomènes sont marqués par des ruptures très nettes.\n\nÀ la @fig-gam7, nous avons divisé la variable *X* en trois segments ($k_1$, $k_2$ et $k_3$), définis respectivement avec les intervalles suivants : [0,00-0,22], [0,22-0,41] et [0,41-1,00]. Concrètement, cela revient à diviser la variable *X* en trois nouvelles variables $X_{k1}$, $X_{k2}$, et $X_{k3}$. La valeur de $X_{ik}$ est égale à $x_i$ si $x_i$ se trouve dans l'intervalle propre à *k*, et à 0 autrement. Ici, nous obtenons trois coefficients : \n\n* le premier est positif, une augmentation de *X* sur le premier segment est associée à une augmentation de *Y*;\n\n* le second est négatif, une augmentation de *X* sur le second segment est associée à une diminution de *Y*;\n\n* le troisième est aussi négatif, une augmentation de *X* sur le troisième segment est associée à une diminution de *Y*, mais moins forte que pour le second segment.\n\n\n### Non-linéarité avec des *splines* {#sec-1114}\n\nLa dernière approche, et certainement la plus flexible, est d'utiliser ce que l'on appelle une *spline* pour capter des relations non linéaires. Une *spline* est une fonction créant des variables supplémentaires à partir d'une variable *X* et d'une fonction de base. Ces variables supplémentaires, appelées bases (*basis* en anglais), sont ajoutées au modèle; la sommation de leurs valeurs multipliées par leurs coefficients permet de capter les relations non linéaires entre une variable dépendante et une variable indépendante. Le nombre de bases et leur localisation (plus souvent appelé nœuds) permettent de contrôler la complexité de la fonction non linéaire.\n\nPrenons un premier exemple simple avec une fonction de base triangulaire (*tent basis* en anglais). Nous créons ici une *spline* avec sept nœuds répartis équitablement sur l'intervalle de valeurs de la variable *X*. Les sept bases qui en résultent sont présentées à la @fig-gam8. Dans cette figure, chaque sommet d'un triangle correspond à un nœud et chaque triangle correspond à une base.\n\n\n```{r}\n#| label: fig-gam8\n#| echo: false\n#| fig-align: center\n#| fig-cap: Bases de la spline triangulaire\n#| message: false\n#| warning: false\n#| out-width: \"70%\"\nlibrary(splines)\n\nbasis <- bs(dataset$x2, df = 7, degre = 1)\ndf <- data.frame(basis * 3)\ndf$X <- dataset$x2\ndf <- reshape2::melt(df, id.vars = \"X\")\n\nggplot() + \n  geom_point(aes(y = y, x = x2), size = 1, data = dataset) + \n  geom_line(aes(x = X, y = value, color = variable), linewidth = 1, data = df) + theme(legend.position = \"none\") \n```\n\n\nEn ajoutant ces bases dans notre modèle de régression, nous pouvons ajuster un coefficient pour chacune et le représenter en multipliant ces bases par les coefficients obtenus avec une simple régression linéaire (@fig-gam9).\n\n```{r}\n#| label: fig-gam9\n#| echo: false\n#| fig-align: center\n#| fig-cap: Spline triangulaire multipliée par ces coefficients\n#| message: false\n#| warning: false\n#| out-width: \"70%\"\n\nbasis <- bs(dataset$x2, df = 7, degre = 1)\nmodel <- lm(y ~ basis, data = dataset)\ncoefs <- coefficients(model)[2:length(coefficients(model))]\n\nprodbase <- sweep(basis, MARGIN = 2, coefs, `*`)\n\ndf <- data.frame(prodbase)\ndf$X <- dataset$x2\ndf <- reshape2::melt(df, id.vars = \"X\")\n\nggplot() + \n  geom_point(aes(y = y, x = x2), size = 1, data = dataset) + \n  geom_line(aes(x = X, y = value, color = variable), linewidth = 1, data = df) + theme(legend.position = \"none\") \n```\n\nNous remarquons ainsi que les bases correspondant à des valeurs plus fortes de *Y* ont reçu des coefficients plus élevés. Pour reconstituer la fonction non linéaire, il suffit d'additionner ces bases multipliées par leurs coefficients, soit la ligne bleue à la @fig-gam10.\n\n```{r}\n#| label: fig-gam10\n#| echo: false\n#| fig-align: center\n#| fig-cap: Spline triangulaire\n#| message: false\n#| warning: false\n#| out-width: \"70%\"\n\n\nbasis <- bs(dataset$x2, df = 7, degre = 1)\nmodel <- lm(y ~ basis, data = dataset)\ncoefs <- coefficients(model)[2:length(coefficients(model))]\n\nprodbase <- sweep(basis, MARGIN = 2, coefs, `*`)\ntotal <- rowSums(prodbase) + coefficients(model)[1]\n\ndf <- data.frame(prodbase)\ndf$X <- dataset$x2\ndf <- reshape2::melt(df, id.vars = \"X\")\ndf$total <- total\n\nggplot() + \n  geom_point(aes(y = y, x = x2), size = 1, data = dataset) + \n  geom_line(aes(x = X, y = value, group = variable), color = \"grey\", linetype = \"dashed\", linewidth = 1, data = df) +\n  geom_line(aes(x = X, y = total), color = \"blue\", linewidth = 1, data = df)+\n  theme(legend.position = \"none\") \n```\n\nLa fonction de base triangulaire est intéressante pour présenter la logique qui sous-tend les *splines*, mais elle est rarement utilisée en pratique. On lui préfère généralement d'autres formes donnant des résultats plus lisses comme les *B-spline* quadratiques, *B-spline* cubiques, *M-spline*, *Duchon spline*, etc.\n\n```{r}\n#| label: fig-gam11\n#| echo: false\n#| fig-align: center\n#| fig-cap: Comparaison de différentes bases\n#| message: false\n#| warning: false\n#| out-width: \"75%\"\n\nlibrary(mgcv)\nlibrary(splines2)\n\n# Squared spline\nbasis <- bSpline(dataset$x2, df = 7, degre = 2)\nmodel <- lm(y ~ basis, data = dataset)\ncoefs <- coefficients(model)[2:length(coefficients(model))]\n\nprodbase <- sweep(basis, MARGIN = 2, coefs, `*`)\ntotal <- rowSums(prodbase) + coefficients(model)[1]\n\ndf <- data.frame(prodbase)\ndf$X <- dataset$x2\ndf <- reshape2::melt(df, id.vars = \"X\")\ndf$total <- total\n\nP1 <- ggplot() + \n  geom_point(aes(y = y, x = x2), size = 1, data = dataset) + \n  geom_line(aes(x = X, y = value, group = variable), color = \"grey\", linetype = \"dashed\", linewidth = 1, data = df) +\n  geom_line(aes(x = X, y = total), color = \"blue\", linewidth = 1, data = df)+\n  theme(legend.position = \"none\") + \n  labs(subtitle = \"B-spline quadratique\")+ \n  ylim(0,20)\n\n\n# Spline cubique\nbasis <- bSpline(dataset$x2, df = 7, degre = 3)\nmodel <- lm(y ~ basis, data = dataset)\ncoefs <- coefficients(model)[2:length(coefficients(model))]\n\nprodbase <- sweep(basis, MARGIN = 2, coefs, `*`)\ntotal <- rowSums(prodbase) + coefficients(model)[1]\n\ndf <- data.frame(prodbase)\ndf$X <- dataset$x2\ndf <- reshape2::melt(df, id.vars = \"X\")\ndf$total <- total\n\nP2 <- ggplot() + \n  geom_point(aes(y = y, x = x2), linewidth = 1, data = dataset) + \n  geom_line(aes(x = X, y = value, group = variable), color = \"grey\", linetype = \"dashed\", linewidth = 1, data = df) +\n  geom_line(aes(x = X, y = total), color = \"blue\", linewidth = 1, data = df)+\n  theme(legend.position = \"none\") + \n  labs(subtitle = \"B-spline cubique\")+ \n  ylim(0,20)\n\n# M-spline\nbasis <- mSpline(dataset$x2, df = 7, degre = 2)\nmodel <- lm(y ~ basis, data = dataset)\ncoefs <- coefficients(model)[2:length(coefficients(model))]\n\nprodbase <- sweep(basis, MARGIN = 2, coefs, `*`)\ntotal <- rowSums(prodbase) + coefficients(model)[1]\n\ndf <- data.frame(prodbase)\ndf$X <- dataset$x2\ndf <- reshape2::melt(df, id.vars = \"X\")\ndf$total <- total\n\nP3 <- ggplot() + \n  geom_point(aes(y = y, x = x2), size = 1, data = dataset) + \n  geom_line(aes(x = X, y = value, group = variable), color = \"grey\", linetype = \"dashed\", linewidth = 1, data = df) +\n  geom_line(aes(x = X, y = total), color = \"blue\", linewidth = 1, data = df)+\n  theme(legend.position = \"none\") + \n  labs(subtitle = \"M-spline\")+ \n  ylim(0,20)\n\n\n# Duchon spline\nsmoother <- smoothCon(s(x2, bs=\"ds\", k = 7), data = dataset, absorb.cons = T)\nbasis <- smoother[[1]]$X\nmodel <- lm(y ~ basis, data = dataset)\ncoefs <- coefficients(model)[2:length(coefficients(model))]\n\nprodbase <- sweep(basis, MARGIN = 2, coefs, `*`)\ntotal <- rowSums(prodbase) + coefficients(model)[1]\n\ndf <- data.frame(prodbase)\ndf$X <- dataset$x2\ndf <- reshape2::melt(df, id.vars = \"X\")\ndf$total <- total\n\nP4 <- ggplot() + \n  geom_point(aes(y = y, x = x2), size = 1, data = dataset) + \n  geom_line(aes(x = X, y = value, group = variable), color = \"grey\", linetype = \"dashed\", linewidth = 1, data = df) +\n  geom_line(aes(x = X, y = total), color = \"blue\", linewidth = 1, data = df)+\n  theme(legend.position = \"none\") + \n  labs(subtitle = \"Duchon-spline\") + \n  ylim(0,20)\n\nggarrange(P1, P2, P3, P4, ncol = 2, nrow = 2)\n```\n\nLes approches que nous venons de décrire sont regroupées sous l'appellation de modèles additifs. Dans les prochaines sous-sections, nous nous concentrons davantage sur les *splines* du fait de leur plus grande flexibilité.\n\n## *Spline* de régression et *spline* de lissage {#sec-112}\n\nDans les exemples précédents, nous avons vu que la construction d'une *spline* nécessite d'effectuer deux choix importants : le nombre de nœuds et leur localisation. Un trop grand nombre de nœuds conduit à un surajustement du modèle alors qu'un trop faible nombre de nœuds conduit à un sous-ajustement. Lorsque ces choix sont effectués par l'utilisateur et que les bases sont ajoutées manuellement dans le modèle tel que décrit précédemment, nous parlons alors de **_splines_ de régression** (*Regression Spline* en anglais).\n\nUne approche a été proposée pour faciliter le choix du nombre de nœuds, il s'agit de **_splines_ de lissage**  (*smoothing spline* en anglais). L'idée derrière cette approche est d'introduire dans le modèle une pénalisation associée avec le nombre de nœuds (ou degré de liberté) de la *spline*, dans un souci de parcimonie : chaque nœud supplémentaire doit suffisamment contribuer au modèle pour être conservé. Il n'est pas nécessaire ici de rentrer dans le détail mathématique de cette pénalisation qui est un peu complexe. Retenez simplement qu'elle dépend d'un paramètre appelé $\\lambda$ :\n\n* plus $\\lambda$ tend vers 0, plus la pénalisation est faible et plus la *spline* de lissage devient une simple *spline* de régression; \n\n* à l'inverse, plus elle est forte, plus la pénalité est importante, au point que la *spline* peut se résumer à une simple ligne droite. \n\nCela est illustré à la @fig-gam12 comprenant trois *splines* avec 20 nœuds et des valeurs $\\lambda$ différentes contrôlant la force de la pénalité. \n\nBien évidemment, nous constatons qu'avec la *spline* de régression (non pénalisée), 20 nœuds conduisent à un fort surajustement du modèle. En revanche, les *splines* de lissage (pénalisées) permettent de corriger ce problème de surajustement. Toutefois, une valeur trop importante de $\\lambda$ conduit à un sous-ajustement du modèle (ici $\\lambda = 3$ et $\\lambda = 100$, lignes verte et bleue).\n\n\n```{r}\n#| label: fig-gam12\n#| echo: false\n#| fig-align: center\n#| fig-cap: Pénalisation des splines\n#| message: false\n#| warning: false\n#| out-width: \"70%\"\n\n# Modèle 1 : régression spline sans pénalite\nmod1 <- gam(y~ s(x2, k = 20, fx = T), data = dataset)\n\n# Modèle 2 : régression spline avec pénalite = 3\nmod2 <- gam(y~ s(x2, k = 20, sp = 0.5), data = dataset)\n\n# Modèle 3 : régression spline avec pénalite = 10\nmod3 <- gam(y~ s(x2, k = 20, sp = 3), data = dataset)\n\n# Modèle 4 : régression spline avec pénalite = 100\nmod4 <- gam(y~ s(x2, k = 20, sp = 100), data = dataset)\n\ndf <- data.frame(\n  y = dataset$y,\n  x = dataset$x2,\n  pred1 = predict(mod1),\n  pred2 = predict(mod2),\n  pred3 = predict(mod3),\n  pred4 = predict(mod4)\n)\n\nggplot(df) + \n  geom_point(aes(x = x, y = y), size = 1) +\n  geom_line(aes(x = x, y = pred1, color = \"spline de régression\"), linewidth = 1.1) +\n  geom_line(aes(x = x, y = pred2, color = \"lambda = 0.5\"), linewidth = 1.1) +\n  geom_line(aes(x = x, y = pred3, color = \"lambda = 3\"), linewidth = 1.1)+\n  geom_line(aes(x = x, y = pred4, color = \"lambda = 100\"), linewidth = 1.1) + \n  labs(colour = 'pénalisation')\n\n```\n\n\nAvec les *splines* de lissage, l'enjeu est de sélectionner une valeur optimale de $\\lambda$. Le plus souvent, les *packages* R **estiment eux-mêmes** ce paramètre à partir des données utilisées dans le modèle. Toutefois, gardez en mémoire que vous pouvez modifier ce paramètre. Mentionnons également que les *splines* de lissage peuvent être reparamétrées dans un modèle pour être intégrées comme des effets aléatoires. Dans ce cas-ci, $\\lambda$ est remplacé par un simple paramètre de variance directement estimé dans le modèle [@wood2004stable].\n\n\n## Interprétation d'une *spline* {#sec-113}\n\nL'interprétation d'une *spline* se fait à l'aide de graphiques. En effet, puisqu'elle est composée d'un ensemble de coefficients appliqués à des bases, il est difficile d'interpréter directement ces derniers. Nous préférons alors représenter la fonction obtenue à l'aide d'un graphique, illustrant son **effet marginal**. Ce graphique est construit en trois étapes : \n\n1. Créer un jeu de données fictif dans lequel l'ensemble des variables indépendantes sont fixées à leurs moyennes respectives, sauf la variable pour laquelle nous souhaitons représenter la *spline*. Pour cette dernière, un ensemble de valeurs allant de son minimum à son maximum est utilisé;\n\n2. Utiliser le modèle pour prédire les valeurs attendues de la variable dépendante pour chacune des observations fictives ainsi créées;\n\n3. Afficher les prédictions obtenues dans un graphique.\n\nNotez ici qu'un graphique des effets marginaux se base sur les prédictions du modèle. Si un modèle est mal ajusté, les prédictions ne seront pas fiables et il sera inutile d'interpréter la *spline* obtenue.\n\nIl est aussi possible, dans le cas des *splines* de lissage, d'interpréter les *estimated degrees of freedom* (EDF) qui constituent une approximation du nombre de nœuds de la *spline*. S'ils ne nous renseignent pas sur la forme de la *spline*, ils nous indiquent son niveau de complexité. Une *spline* avec un EDF de 1 est en réalité un simple terme linéaire. Plus l'EDF augmente, plus la *spline* est complexe. \n\n\n## Multicolinéarité non linéaire {#sec-114}\n\nLorsque des *splines* sont ajoutées dans un modèle, il est nécessaire de vérifier si ces dernières ne posent pas un problème de multicolinéarité. Cependant, le VIF ne peut plus être utilisé du fait de la non-linéarité des relations modélisées. Il est alors nécessaire d'utiliser une autre mesure : la concurvité (*concurvity*) permettant de mesurer sur une échelle allant de 0 à 1 à quel point deux *splines* ont en réalité capturé le même effet et se substituent l'une à l'autre. Une valeur de 0 indique une absence totale de concurvité alors qu'une valeur de 1 indique que deux *splines* sont rigoureusement identiques (modèle non identifiable). \n\n## *Splines* avancées {#sec-115}\n\nJusqu'ici, nous avons seulement présenté le cas le plus simple pour lequel une *spline* est construite à partir d'une seule variable dépendante continue, mais les **splines** peuvent être utilisées dans de nombreux autres contextes et ont une incroyable flexibilité. Nous détaillons ici trois exemples fréquents : les *splines* cycliques, les *splines* variant par groupe et les *splines* multivariées. Pour une description complète des effets non linéaires possibles avec `mgcv`, n'hésitez pas à consulter sa [documentation](https://stat.ethz.ch/R-manual/R-patched/library/mgcv/html/smooth.terms.html).\n\n```{r}\n#| label: tbl-exemplesplines\n#| tbl-cap: Exemples de splines avancées\n#| echo: false\n#| message: false\n#| warning: false\n\ndf <- data.frame(\n        Type = c(\"spline cyclique\", \"spline variant par groupe\", \"spline bivariée\", \n                 \"spline d'interaction complète\", \"spline d'interaction partielle\"),\n        Code = c(\"`s(x, bs = 'cc')`\" , \"`s(x, by = x2)`\" , \"`s(x1,x2)`\" , \"`te(x1,x2)`\",\n                 \"`s(x1) + s(x2) + ti(x1,x2)`\"),\n        Description = c(\"Une spline cyclique doit être utilisée si le 0 de la variable X correspond également à sa valeur maximum. Un bon exemple est le temps dans une journée, car 24 h est équivalent à 0 h\", \"Une spline variant par groupe permet d'ajuster une spline à une variable X1 différente pour chaque groupe identifié par une variable qualitative X2\", \"Une spline bivariée est utilisée pour modéliser l'interaction non linéaire de deux variables X1 et X2 s'exprimant dans la même unité (typiquement des coordonnées géographiques cartésiennes)\", \"Une spline d'interaction permet de modéliser l'interaction non linéaire de deux variables continues pouvant s'exprimer dans des unités différentes, elle combine les effets spécifiques de chacune des deux variables et leur interaction\", \"Une spline d'interaction partielle permet de distinguer les effets non linéaires individuels de deux variables de leur interaction non linéaire\"))\n\noptions(knitr.kable.NA = \"\")\nknitr::kable(df, \n           format.args = list(decimal.mark = ',', big.mark = \" \"),\n           col.names = c(\"Type\" , \"Code\" , \"Description\"),\n           col.to.resize = 3,\n           col.width = c(\"10cm\")\n           )\n\n```\n\n\n### *Splines* cycliques {#sec-1151}\n\nUne *spline* cyclique est une extension d'une *spline* classique dont les bases aux extrémités sont spécifiées de telle sorte que la valeur au départ de la *spline* soit la même que celle à la fin de la *spline*. Cela permet à la *spline* de former une boucle, ce qui est particulièrement intéressant pour des variables dont le 0 et la valeur maximale correspondent en réalité à la même valeur. L'exemple le plus parlant est certainement le cas d'une variable représentant la mesure d'un angle en degrés. Les valeurs de 0 et 360 sont identiques et les valeurs 350 et 10 sont toutes les deux à une distance de 10 degrés de 0. Un autre exemple possible serait de considérer l'heure comme une variable continue; dans ce cas, 24 h et 0 h signifient la même chose.\n\nPrenons un exemple concret. Nous souhaitons modéliser la concentration de dioxyde d'azote (NO~2~) à Paris, mesurée par un ensemble de stations fixes. Nous pourrions nous attendre à ce que le NO~2~ suive chaque jour un certain patron. Concrètement, à proximité d'axes routiers majeurs, nous nous attendons à observer des pics suivant les flux pendulaires. À la @fig-gam13, nous retrouvons bien les deux pics attendus correspondant aux heures de pointe du matin et du soir. Aussi, comme indiqué par la ligne rouge, la valeur prédite par la *spline* est la même à 24 h et à 0 h.\n\n\n```{r}\n#| label: fig-gam13\n#| echo: false\n#| fig-align: center\n#| fig-cap: Spline cyclique pour modéliser la concentration de dioxyde d'azote\n#| message: false\n#| warning: false\n#| out-width: \"70%\"\n\ndataset <- read.csv('data/gam/NO2_airparif.csv', sep=';')\ndataset <- dataset[2:nrow(dataset),]\ndf <- reshape2::melt(dataset, id.vars = c(\"heure\" , \"date\"))\ndf$no2 <- ifelse(df$value == \"n/d\", NA, as.numeric(df$value))\n\nmodel <- gam(no2 ~ s(heure, bs = \"cp\"), data = df, family = tw)\npreds <- data.frame(\n  heure = 1:24\n)\nmodout <- predict(model, newdata = preds, type = \"link\", se.fit = TRUE)\npreds$yhat <- exp(modout$fit)\npreds$lower <- exp(modout$fit - 1.96*modout$se.fit)\npreds$upper <- exp(modout$fit + 1.96*modout$se.fit)\n\nsubpts <- df[sample(1:nrow(df), size = 1000, replace = FALSE),]\nsubpts$heure2 <- subpts$heure + runif(nrow(subpts), min = -0.5, max = +0.5)\n\ncent_line <- preds$yhat[[1]]\n\nggplot() + \n  geom_point(mapping = aes(x = heure2, y = no2), size = 0.5, data = subpts, alpha = 0.5) +\n  geom_ribbon(mapping = aes(x = heure, ymax = upper, ymin = lower), fill = \"grey\", alpha = 0.4, data = preds) +\n  geom_line(mapping = aes(x = heure, y = yhat), color = \"blue\", linewidth = 1.1, data = preds) + \n  geom_hline(yintercept = cent_line, color = \"red\", linetype = \"dashed\") +\n  labs(x = \"moment de la journée\", y = \"concentration de NO2\") + \n  scale_x_continuous(breaks = seq(4,20,4), labels = paste(seq(4,20,4),'h', sep='')) + \n  xlim(1,24)\n\n```\n\n\n\n### Splines par groupe {#sec-1152}\n\nTel qu'abordé dans les chapitres précédents, il arrive régulièrement que les observations appartiennent à  différents groupes. Dans ce cas de figure, nous pouvons être amenés à vérifier si la relation décrite par une *spline* est identique pour chacun des groupes d'observations. Il s'agit alors d'ajuster une *spline* différente par groupe. Dans l'exemple précédent, chaque valeur de NO~2~ a été mesurée par une station fixe de mesure spécifique. Compte tenu du fait que l'environnement autour de chaque station est particulier, nous pourrions s'attendre à ce que les valeurs de NO~2~ ne présentent pas exactement les mêmes patrons journaliers pour chaque station.\n\nÀ la @fig-gam14, il est possible de constater que le NO~2~ suit globalement le même patron temporel pour l'ensemble des stations à l'exception de trois d'entres-elles. Il s'agit en réalité de stations situées dans des secteurs ruraux de la région parisienne, et donc moins impactées par le trafic routier.\n\n\n```{r}\n#| label: fig-gam14\n#| echo: false\n#| fig-align: center\n#| fig-cap: Spline cyclique variant par groupe\n#| message: false\n#| warning: false\n#| out-width: \"70%\"\n\nmodel <- gam(no2 ~ s(heure, bs = \"cp\", by = variable), data = df, family = gaussian)\npreds <- expand.grid(\n  heure = 1:24,\n  variable = unique(df$variable)\n)\n\nmodout <- predict(model, newdata = preds, type = \"link\", se.fit = TRUE)\npreds$yhat <- modout$fit\npreds$lower <- modout$fit - 1.96*modout$se.fit\npreds$upper <-modout$fit + 1.96*modout$se.fit\n\nsubpts <- df[sample(1:nrow(df), size = 1000, replace = FALSE),]\nsubpts$heure2 <- subpts$heure + runif(nrow(subpts), min = -0.5, max = +0.5)\n\ncent_line <- preds$yhat[[1]]\n\nggplot() + \n  geom_point(mapping = aes(x = heure2, y = no2), size = 0.5, data = subpts, alpha = 0.5) +\n  geom_ribbon(mapping = aes(x = heure, ymax = upper, ymin = lower, group = variable), fill = \"grey\", alpha = 0.4, data = preds) +\n  geom_line(mapping = aes(x = heure, y = yhat, color = variable), size =0.7, data = preds) + \n  labs(x = \"moment de la journée\", y = \"concentration de NO2\", color = \"station de mesure\") + \n  scale_x_continuous(breaks = seq(4,20,4), labels = paste(seq(4,20,4),'h', sep='')) + \n  xlim(1,24) + \n  theme(legend.position = 'NONE')\n\n```\n\n\n### *Splines* multivariées et *splines* d'interaction {#sec-1153}\n\nJusqu'ici, nous n'avons considéré que des *splines* ne s'appliquant qu'à une seule variable indépendante; cependant, il est possible de construire des *splines* multivariées s'ajustant simultanément sur plusieurs variables indépendantes. L'objectif est alors de modéliser les potentielles interactions non linéaires entre les variables indépendantes combinées dans une même *spline*. Prenons un exemple concret, dans la section sur les modèles GLM, nous avons modélisé la couverture des aires de diffusion (AD) à Montréal par des îlots de chaleur. Parmi les variables indépendantes, nous avons notamment utilisé la distance au centre-ville ainsi que la part de la surface végétalisée des AD. Nous pourrions formuler l'hypothèse que ces deux variables influencent conjointement et de façon non linéaire la proportion de la surface d'îlot de chaleur dans chaque AD. Pour représenter une *spline* sur plusieurs dimensions, nous utilisons alors une carte de chaleur dont la couleur représente la valeur de la variable dépendante prédite en fonction des deux variables indépendantes.\n\nIl est important de distinguer la *spline* d'**interaction** et la *spline* **multivariée**. La première est utilisée lorsque les variables indépendantes introduites dans la *spline* ne sont pas exprimées sur la même échelle et n'évoluent pas conjointement. L'exemple donné ci-dessus avec les variables de végétation et de distance au centre-ville est un exemple de *spline* d'interaction, la première variable étant exprimée en pourcentage et l'autre en mètres. De plus, ces deux variables ne sont pas conjointes, mais bien distinctes l'une de l'autre. Un cas typique où une *spline* multivariée serait à privilégier est le cas de l'ajout des coordonnées spatiales dans le modèle. L'emplacement des AD est mesuré par deux variables (coordonnées spatiales *x* et *y*) toutes les deux exprimées en mètres évoluant conjointement, au sens où les coordonnées *x* n'interagissent pas avec les coordonnées *y*, mais forment à elles deux un espace propre. Au-delà de la problématique de l'échelle des données, il est important de retenir que les *splines* d'interaction tendent à être davantage pénalisées que les splines *multivariées*.\n\nLa *spline* d'interaction représentée à la @fig-gam15 indique que les AD avec la plus grande proportion de leur surface couverte par des îlots de chaleur sont situées à moins de 25 kilomètres du centre-ville, au-delà de cette distance, cette proportion chute en bas de 0,1, soit 10 % de la surface de l'AD. En revanche, à proximité du centre-ville (moins d'un kilomètre), même les AD disposant d'un fort pourcentage de surface végétalisée sont tout de même marquées par un fort pourcentage de surface couverte par des îlots de chaleur.\n\nLes *splines* bivariées sont fréquemment utilisées pour capturer un potentiel patron spatial dans les données. En effet, si nous disposons des coordonnées spatiales de chaque observation (*x, y*), il est possible d'ajuster une *spline* bivariée sur ces coordonnées, contrôlant ainsi l'effet de l'espace. \n\n```{r}\n#| label: fig-gam15\n#| echo: false\n#| fig-align: center\n#| fig-cap: Spline d'interaction bivariée\n#| message: false\n#| warning: false\n#| out-width: \"70%\"\n\ndataset <- read.csv(\"data/glm/data_chaleur.csv\")\ndataset$prt_hot01 <- dataset$prt_hot/100\nmodel <- gam(prt_hot01 ~ te(prt_veg, dist_cntr), data = dataset, family = betar)\nvis.gam(model, plot.type = 'contour', type = 'response', main = '', xlab = 'Pourcentage de la surface végétalisée', ylab = 'Distance au centre-ville', too.far = 0.1, n.grid = 150)\n```\n\nIl n'y a pas de limite théorique au nombre de variables qui peuvent être ajoutées dans une *spline* d'interaction ou multivariée. Notez cependant que plus le nombre de dimensions augmente, plus la fonction à estimer est complexe et plus le volume de données nécessaire est grand et doit couvrir densément l'ensemble de l'espace d'échantillonnage multidimensionnel.\n\n## Mise en œuvre dans R {#sec-116}\n\nIl est possible d'ajuster des *splines* de régression dans n'importe quel *package* permettant d'ajuster des coefficients pour un modèle de régression. Il suffit de construire les bases des *splines* en amont à l'aide du *package* `splines2` et de les ajouter directement dans l'équation de régression. \nEn revanche, il est nécessaire d'utiliser des *packages* spécialisés pour ajuster des *splines* de lissage. Parmi ceux-ci, `mgcv` est probablement le plus populaire du fait de sa (très) grande flexibilité, suivi des *packages* `gamlss`, `gam` et `VGAM.` Nous comparons ici les deux approches, puis nous tentons d'améliorer le modèle que nous avons ajusté pour prédire le pourcentage de surface couverte par des îlots de chaleur dans les aires de diffusion de Montréal, dans une perspective d'équité environnementale. Pour rappel, la variable dépendante est exprimée en pourcentage et nous utilisons une distribution bêta pour la modéliser.\n\n```{r}\n#| message: false\n#| warning: false\nlibrary(mgcv)\n# Chargement des données\ndataset <- read.csv(\"data/gam/data_chaleur.csv\", fileEncoding = \"utf8\")\n# Ajustement du modèle de base\nrefmodel <- gam(hot ~\n          A65Pct + A014Pct + PopFRPct + PopMVPct +\n          poly(prt_veg, degree = 2)  + Arrond,\n        data = dataset, family = betar(link = \"logit\"))\n```\n\nDans notre première analyse de ces données, nous avons ajusté une polynomiale d'ordre 2 pour représenter un potentiel effet non linéaire de la végétation sur les îlots de chaleur. Nous remplaçons à présent ce terme par une *spline* de régression en sélectionnant quatre nœuds.\n\n```{r}\n#| message: false\n#| warning: false\nlibrary(splines2)\n# Création des bases de la spline\nbasis <- bSpline(x = dataset$prt_veg, df =4, intercept = FALSE)\n# Ajouter les bases au DataFrame\nbasisdf <- as.data.frame(basis)\nnames(basisdf) <- paste('spline',1:ncol(basisdf), sep='')\ndataset <- cbind(dataset, basisdf)\n# Ajuster le modèle\nmodel0 <- gam(hot ~\n          A65Pct + A014Pct + PopFRPct + PopMVPct +\n          spline1 + spline2 + spline3 + spline4 + Arrond,\n        data = dataset, family = betar(link = \"logit\"))\n\n```\n\nNous pouvons à présent ajuster une *spline* de lissage et laisser `mgcv` déterminer son niveau de complexité.\n\n```{r}\n#| message: false\n#| warning: false\n# Ajustement du modèle avec une spline simple\nmodel1 <- gam(hot ~\n          A65Pct + A014Pct + PopFRPct + PopMVPct +\n          s(prt_veg)  + Arrond,\n        data = dataset, family = betar(link = \"logit\"))\n```\n\nNotez ici que la syntaxe à employer est très simple, il suffit de spécifier `s(prt_veg)` pour indiquer à la fonction `gam` que vous souhaitez ajuster une *spline* pour la variable `prt_veg`. Nous pouvons à présent comparer l'ajustement des deux modèles en utilisant la mesure de l'AIC.\n\n```{r}\n#| message: false\n#| warning: false\n# Comparaison des AIC\nAIC(refmodel, model0, model1)\n```\n\nNous constatons que la valeur de l'AIC du second modèle est plus réduite, indiquant un meilleur ajustement du modèle avec une *spline* de régression. Notons cependant que la différence avec la *spline* de lissage est anecdotique (deux points de l'AIC) et que nous connaissions a priori le bon nombre de nœuds à utiliser. Pour des relations plus complexes, les *splines* de lissage ont tendance à nettement mieux performer. Voyons à présent comment représenter ces trois termes non linéaires.\n\n```{r}\n#| message: false\n#| warning: false\n#| label: fig-gam16\n#| fig-align: center\n#| fig-cap: Comparaison d'une spline et d'une polynomiale\n#| out-width: \"75%\"\n\n# Création d'un DataFrame de prédiction dans lequel seule\n# la variable prt_veg varie.\ndfpred <- data.frame(\n  prt_veg = seq(min(dataset$prt_veg), max(dataset$prt_veg), 0.5),\n  A65Pct = mean(dataset$A65Pct),\n  A014Pct = mean(dataset$A014Pct),\n  PopFRPct = mean(dataset$PopFRPct),\n  PopMVPct = mean(dataset$PopMVPct),\n  Arrond = \"Verdun\"\n)\n\n# Recréation des bases de la spline de régression\n# pour les nouvelles observations\nnvl_bases <- data.frame(predict(basis, newx = dfpred$prt_veg))\nnames(nvl_bases) <- paste('spline',1:ncol(basisdf), sep='')\ndfpred <- cbind(dfpred, nvl_bases)\n\n# Définition de la fonction inv.logit, soit l'inverse de la fonction \n# de lien du modèle pour retrouver les prédictions dans l'échelle \n# originales des données\ninv.logit <- function(x){exp(x)/(1+exp(x))}\n\n# Utilisation des deux modèles pour effectuer les prédictions\npredref <- predict(refmodel, newdata = dfpred, type = 'link', se.fit = TRUE)\npredmod0 <- predict(model0, newdata = dfpred, type = 'link', se.fit = TRUE)\npredmod1 <- predict(model1, newdata = dfpred, type = 'link', se.fit = TRUE)\n\n# Calcul de la valeur prédite et construction des intervalles de confiance\ndfpred$polypred <- inv.logit(predref$fit)\ndfpred$poly025 <- inv.logit(predref$fit - 1.96 * predref$se.fit)\ndfpred$poly975 <- inv.logit(predref$fit + 1.96 * predref$se.fit)\n\ndfpred$regsplinepred <- inv.logit(predmod0$fit)\ndfpred$regspline025 <- inv.logit(predmod0$fit - 1.96 * predmod0$se.fit)\ndfpred$regspline975 <- inv.logit(predmod0$fit + 1.96 * predmod0$se.fit)\n\ndfpred$splinepred <- inv.logit(predmod1$fit)\ndfpred$spline025 <- inv.logit(predmod1$fit - 1.96 * predmod1$se.fit)\ndfpred$spline975 <- inv.logit(predmod1$fit + 1.96 * predmod1$se.fit)\n\n# Créer un graphique pour afficher les résultats\nggplot(dfpred) + \n  geom_ribbon(aes(x = prt_veg, ymin = poly025, ymax = poly975),\n              alpha = 0.4, color = \"grey\") +\n  geom_ribbon(aes(x = prt_veg, ymin = spline025, ymax = spline975),\n              alpha = 0.4, color = \"grey\") +\n  geom_ribbon(aes(x = prt_veg, ymin = regspline025, ymax = regspline975),\n              alpha = 0.4, color = \"grey\") +\n  geom_line(aes(y = polypred, x = prt_veg, color = \"polynomiale\"),\n            linewidth = 1) + \n  geom_line(aes(y = regsplinepred, x = prt_veg, color = \"spline de régression\"),\n            linewidth = 1)+\n  geom_line(aes(y = splinepred, x = prt_veg, color = \"spline de lissage\"),\n            linewidth = 1)\n```\n\nNous constatons que les trois termes renvoient des prédictions très similaires et qu'une légère différence n'est observable que pour les secteurs avec les plus hauts niveaux de végétation (supérieurs à 75 %).\n\nJusqu'ici, nous utilisons l'arrondissement dans lequel est comprise chaque aire de diffusion comme une variable nominale afin de capturer la dimension spatiale du jeu de données. Puisque nous avons abordé la notion de *splines* bivariées, il serait certainement plus efficace d'en construire une à partir des coordonnées géographiques (*x*,*y*) des centroïdes des aires de diffusion. En effet, il est plus probable que la distribution des îlots de chaleur suive un patron spatial continu sur le territoire plutôt que les délimitations arbitraires des arrondissements.\n\n```{r}\n#| message: false\n#| warning: false\n# Ajustement du modèle avec une spline bivariée pour l'espace\nmodel2 <- gam(hot ~\n          A65Pct + A014Pct + PopFRPct + PopMVPct +\n          s(prt_veg)  + s(X,Y),\n        data = dataset, family = betar(link = \"logit\"))\n```\n\nNotez ici que l'expression `s(X,Y)` permet de créer une *spline* bivariée à partir des coordonnées (*x, y*), soit deux colonnes présentes dans le jeu de données. Ces coordonnées sont exprimées toutes deux en mètres et n'interagissent pas ensemble au sens strict, nous devons donc ajuster une *spline* bivariée. Si vous avez besoin d'ajuster une *spline* d'interaction (notamment quand les variables sont dans des unités différentes), il est nécessaire d'utiliser une autre syntaxe `te(X,Y)` ou `t2(X,Y)` faisant appel à une structure mathématique légèrement différente, soit des *tensor product smooths*.\n\nPuisque notre modèle intègre deux *splines*, nous devons nous assurer que nous n'avons pas de problème de concurvité, ce que nous pouvons faire avec la fonction `concurvity` du *package* `mgcv`. \n\n```{r}\n#| message: false\n#| warning: false\nvalues <- concurvity(model2, full = FALSE)\n\n# Worst, estimation pessimiste de la concurvité\nround(values$worst,3)\n\n# Observed, estimation optimiste de la concurvité\nround(values$observed,3)\n\n# Estimate, estimation entre deux de la concurvité\nround(values$estimate,3)\n```\n\nNous pouvons ainsi constater des niveaux de concurvité tout à fait acceptables dans notre modèle. Des valeurs supérieures à 0,8 devraient être considérées comme alarmantes, surtout si elles sont reportées pour `observed` et `estimate`.\n\nVoyons désormais, le résumé d'un modèle GAM tel que présenté dans R.\n\n```{r}\n#| message: false\n#| warning: false\nsummary(model2)\n```\n\nLa première partie du résumé comprend les résultats pour les effets fixes et linéaires du modèle. Ils s'interprètent comme pour ceux d'un GLM classique. La seconde partie présente les résultats pour les termes non linéaires. La valeur de *p* permet de déterminer si la *spline* a ou non un effet différent de 0. Une valeur non significative indique que la *spline* ne contribue pas au modèle. Les colonnes *edf* et *Ref.df* indiquent la complexité de la *spline* et peuvent être considérées comme une approximation du nombre de nœuds. Dans notre cas, la *spline* spatiale (`s(X,Y)`) est environ 5 fois plus complexe que la *spline* ajustée pour la végétation (`s(prt_veg)`). Cela n'est pas surprenant puisque la dimension spatiale (*spline* bivariée) du phénomène est certainement plus complexe que l’effet de la végétation. Notez ici que des valeurs *edf* et *Ref.df* proches de 1 signaleraient que l'effet d’un prédicteur est essentiellement linéaire et qu'il n'est pas nécessaire de recourir à une *spline* pour cette variable.\n\nLa dernière partie du résumé comprend deux indicateurs de qualité d'ajustement, soit le R^2^ ajusté et la part de la déviance expliquée.\n\n```{r}\n#| message: false\n#| warning: false\nAIC(refmodel, model1, model2)\n```\n\nNous pouvons constater que le fait d'introduire la *spline* spatiale dans le modèle contribue à réduire encore la valeur de l'AIC, et donc à améliorer le modèle. À ce stade, nous pourrions tenter de forcer la *spline* à être plus complexe en augmentant le nombre de nœuds.\n\n```{r}\n#| message: false\n#| warning: false\n# Augmentation de la complexité de la spline spatiale\nmodel3 <- gam(hot ~\n          A65Pct + A014Pct + PopFRPct + PopMVPct +\n          s(prt_veg)  + s(X,Y,k = 40),\n        data = dataset, family = betar(link = \"logit\"))\n\nAIC(refmodel, model1, model2, model3)\n```\n\nCela a pour effet d'améliorer de nouveau le modèle. Pour vérifier si l'augmentation du nombre nœuds est judicieuse, il est possible de représenter le résultat des deux *splines* précédentes. Pour ce faire, nous proposons de calculer les valeurs prédites de la *spline* pour chaque localisation dans notre terrain d'étude, en le découpant préalablement en pixels de 100 de côté. Pour cette prédiction, nous maintenons toutes les autres variables à leur moyenne respective afin d'évaluer uniquement l'effet de la *spline* spatiale.\n\n```{r}\n#| label: fig-gam17\n#| message: false\n#| warning: false\n#| fig-align: center\n#| fig-cap: Comparaison de deux splines spatiales\n#| out-width: \"100%\"\nlibrary(viridis)\nlibrary(metR) # pour placer des étiquettes sur les isolignes\n\n# Création d'un DataFrame fictif pour les prédictions\ndfpred <- expand.grid(\n  prt_veg =mean(dataset$prt_veg),\n  A65Pct = mean(dataset$A65Pct),\n  A014Pct = mean(dataset$A014Pct),\n  PopFRPct = mean(dataset$PopFRPct),\n  PopMVPct = mean(dataset$PopMVPct),\n  X = seq(min(dataset$X), max(dataset$X),100),\n  Y = seq(min(dataset$Y), max(dataset$Y),100)\n)\n\ndfpred$predicted1 <- predict(model2, newdata = dfpred, type = 'response')\ndfpred$predicted2 <- predict(model3, newdata = dfpred, type = 'response')\n\n# Centrage des prédictions\ndfpred$predicted1 <- dfpred$predicted1 - mean(dfpred$predicted1)\ndfpred$predicted2 <- dfpred$predicted2 - mean(dfpred$predicted2)\n\n# Représentation des splines\nplot1 <- ggplot(dfpred) + \n  geom_raster(aes(x = X, y = Y, fill = predicted1)) + \n  geom_point(aes(x = X, y = Y),\n             size = 0.2, alpha = 0.4,\n             color = \"black\", data = dataset)+\n  geom_contour(aes(x = X, y = Y, z = predicted1), binwidth = 0.1, \n               color = \"white\", linetype = 'dashed') + \n  geom_text_contour(aes(x = X, y = Y, z = predicted1), \n                    color = \"white\", binwidth = 0.1)+\n  scale_fill_viridis() +\n  coord_cartesian() + \n  theme(axis.title= element_blank(),\n        axis.text = element_blank(),\n        axis.ticks =  element_blank()\n        ) + \n  labs(subtitle = \"spline de base\", fill = \"prédictions\")\n\nplot2 <- ggplot(dfpred) + \n  geom_raster(aes(x = X, y = Y, fill = predicted2)) + \n  geom_point(aes(x = X, y = Y),\n             size = 0.2, alpha = 0.4,\n             color = \"black\", data = dataset)+\n  geom_contour(aes(x = X, y = Y, z = predicted2),\n               binwidth = 0.1, color = \"white\", linetype = 'dashed') + \n  geom_text_contour(aes(x = X, y = Y, z = predicted2), color = \"white\", binwidth = 0.1)+\n  scale_fill_viridis() +\n  coord_cartesian()+ \n  theme(axis.title= element_blank(),\n        axis.text = element_blank(),\n        axis.ticks =  element_blank()\n        ) + \n  labs(subtitle = \"spline plus complexe\", fill = \"prédictions\")\n\nggarrange(plot1, plot2, nrow = 1, ncol = 2, common.legend = TRUE, legend = 'bottom')\n```\n\nOr, il s'avère que les deux *splines* spatiales sont très similaires (@fig-gam17). Par conséquent, il est vraisemblablement plus pertinent de conserver la plus simple des deux. Notez que le Mont-Royal, compris dans le cercle central avec une isoligne à 0, est caractérisé par des valeurs plus faibles d'îlots de chaleur, alors que les quartiers centraux situés un peu plus au nord sont au contraire marqués par des pourcentages d'îlots de chaleur supérieurs de 20 points de pourcentage en moyenne.\n\n## GAMM {#sec-117}\n\nBien entendu, il est possible de combiner les modèles généralisés additifs (GAM) avec les modèles à effet mixtes (GLMM) abordés dans les sections précédentes. Ces modèles généralisés additifs à effets mixtes (GAMM) peuvent facilement être mis en œuvre avec `mgcv`.\n\n#### GAMM et interceptes aléatoires {#sec-1171}\n\nPour définir des constantes aléatoires, il suffit d'utiliser la notation `s(var, bs = 're')` avec `var` une variable nominale. Reprenons l'exemple précédent, mais avec cette fois-ci les arrondissements comme un intercepte aléatoire.\n\n```{r}\n#| message: false\n#| warning: false\ndataset$Arrond <- as.factor(dataset$Arrond)\nmodel4 <- gam(hot ~\n          A65Pct + A014Pct + PopFRPct + PopMVPct +\n          s(prt_veg)  + s(Arrond, bs = \"re\"),\n        data = dataset, family = betar(link = \"logit\"))\n```\n\nL'enjeu est ensuite d'extraire la variance propre à cet effet aléatoire ainsi que les valeurs des interceptes pour chaque arrondissement.\n\n```{r}\n#| message: false\n#| warning: false\ngam.vcomp(model4)\n```\n\nNous constatons donc que l'écart-type de l'effet aléatoire des arrondissements est de 0,39, ce qui signifie que les effets de chaque arrondissement seront compris à 95 % entre -1,17 et 1,17 (`1.17 = 3*0.39`) sur l'échelle du prédicteur linéaire. En effet, rappelons que les effets aléatoires sont modélisés comme des distributions normales et que 95 % de la densité d'une distribution normale se situe entre -3 et +3 écarts-types. Pour extraire les interceptes spécifiques de chaque arrondissement, nous pouvons utiliser la fonction `get_random` du *package* `itsadug.`\n\n```{r}\n#| label: fig-randomconstGAM\n#| fig-cap: Constantes aléatoires pour les arrondissements\n#| message: false\n#| warning: false\nlibrary(itsadug)\nvalues <- get_random(model4)[[1]]\ndf <- data.frame(\n  ri = as.numeric(values),\n  arrond = names(values)\n)\n\nggplot(df) + \n  geom_point(aes(x = ri, y = reorder(arrond, ri))) + \n  geom_vline(xintercept = 0, color = \"red\") + \n  labs(y = \"Arrondissement\", x = \"intercepte aléatoire\")\n```\n\nNous constatons ainsi, à la @fig-randomconstGAM, que pour une partie des arrondissements, la densité d'îlot de chaleur est systématiquement supérieure à la moyenne régionale représentée ici par la ligne rouge (0 = effet moyen pour tous les arrondissements). Il convient alors d’améliorer ce graphique en ajoutant le niveau d'incertitude associé à chaque intercepte. Pour ce faire, nous utilisons la fonction `extract_random_effects` du *package* `mixedup.` Notez que ce *package* n'est actuellement pas disponible sur CRAN et doit être téléchargé sur **github** avec la commande suivante :\n\n```{r}\n#| message: false\n#| warning: false\n#| eval: false\nremotes::install_github('m-clark/mixedup')\n```\n\nAvec la version 4.0.1 de R, nous avons rencontré des difficultés pour installer `mixedup`. Nous avons donc  simplement récupéré le code source de la fonction et l'avons enregistré dans un fichier de code séparé que nous appelons ici.\n\n```{r}\n#| message: false\n#| warning: false\nsource(\"code_complementaire/gam_functions.R\")\n```\n\nNous pouvons ensuite procéder à l'extraction des effets aléatoires et les représenter à nouveau (@fig-randomconstGAM2).\n\n```{r}\n#| label: fig-randomconstGAM2\n#| message: false\n#| warning: false\n#| fig-cap: Constantes aléatoires pour les arrondissements avec intervalle de confiance\ndf_re <- extract_random_effects.gam(model4, re = \"Arrond\")\n\nggplot(df_re) + \n  geom_errorbarh(aes(xmin = lower_2.5, xmax = upper_97.5, y = reorder(group, value))) +\n  geom_point(aes(x = value, y = reorder(group, value))) + \n  geom_vline(xintercept = 0, color = \"red\") + \n  labs(y = \"Arrondissement\", x = \"Intercepte aléatoire\")\n```\n\nCela permet de distinguer quels écarts sont significativement différents de 0 au seuil de 95 %. À titre de rappel, pour être significatif à ce seuil, un intervalle représenté par une ligne noire horizontale ne doit pas intersecter la ligne rouge verticale. Puisque nous utilisons ici la distribution bêta et une fonction de lien logistique, nous devons utiliser des prédictions pour simplifier l'interprétation des coefficients. Nous fixons ici toutes les variables à leur moyenne respective, sauf l'arrondissement, et calculons les prédictions dans l'échelle originale (0 à 1).\n\n```{r}\n#| label: fig-randomconstGAM3\n#| message: false\n#| warning: false\n#| fig-cap: Prédictions pour les différents arrondissements pour une AD fictive moyenne\ndfpred <- data.frame(\n  A65Pct = mean(dataset$A65Pct),\n  A014Pct = mean(dataset$A014Pct),\n  PopFRPct = mean(dataset$PopFRPct),\n  PopMVPct = mean(dataset$PopMVPct),\n  prt_veg = mean(dataset$prt_veg),\n  Arrond = as.character(unique(dataset$Arrond))\n)\n\n# Calculer les prédictions pour le prédicteur linéaire\ndfpred$preds <- predict(model4, newdata = dfpred, type = \"link\")\n\n# Calculer l'intervalle de confiance en utilisant les valeurs\n# extraites avec extract_random_effects\ndfpred <- dfpred[order(dfpred$Arrond),]\ndf_re <- df_re[order(df_re$group),]\n\ndfpred$lower <- dfpred$preds - 1.96*df_re$se\ndfpred$upper <- dfpred$preds + 1.96*df_re$se\n\n# Il nous reste juste à reconvertir le tout dans l'unité d'origine\n# en utilisant l'inverse de la fonction logistique\ninv.logit <- function(x){exp(x)/(1+exp(x))}\n\ndfpred$lower <- inv.logit(dfpred$lower)\ndfpred$upper <- inv.logit(dfpred$upper)\ndfpred$preds <- inv.logit(dfpred$preds)\n\nggplot(dfpred) + \n  geom_errorbarh(aes(xmin = lower, xmax = upper, y = reorder(Arrond, preds))) +\n  geom_point(aes(x = preds, y = reorder(Arrond, preds))) + \n  geom_vline(xintercept = mean(dfpred$preds), color = \"red\") + \n  labs(y = \"Arrondissement\", x = \"intercepte aléatoire\")\n\n```\n\nNous constatons ainsi, à la @fig-randomconstGAM3, que pour une hypothétique aire de diffusion moyenne, la différence de densité d'îlot de chaleur peut être de 0,32 (32 % de la surface de l'AD) entre les arrondissements Verdun et Dollard-des-Ormeaux.\n\n#### GAMM et coefficients aléatoires {#sec-1172}\n\nEn plus des interceptes aléatoires, il est aussi possible de définir des coefficients aléatoires. Reprenons notre exemple et tentons de faire varier l'effet de la variable `PopFRPct` en fonction de l'arrondissement.\n\n```{r}\n#| message: false\n#| warning: false\nmodel5 <- gam(hot ~\n          A65Pct + A014Pct + PopFRPct + PopMVPct +\n          s(prt_veg)  + s(Arrond, bs = \"re\") + \n          s(PopFRPct, Arrond, bs = \"re\"),\n        data = dataset, family = betar(link = \"logit\"))\n```\n\nNotez ici une distinction importante! Le modèle n'assume aucune corrélation entre les coefficients aléatoires pour la variable `PopFRPct` et pour les constantes aléatoires. Il est présumé que ces deux effets proviennent de deux distributions normales distinctes. En d'autres termes, le modèle ne dispose pas des paramètres nécessaires pour vérifier si les arrondissements avec les constantes les plus fortes (avec des densités supérieures d'îlot de chaleur) sont aussi des arrondissements dans lesquels l'effet de la variable `PopFRPct` est plus prononcé (et vice-versa). Pour plus d'informations sur cette distinction, référez-vous à la [section @sec-0924].\n\n```{r}\n#| message: false\n#| warning: false\nAIC(model4, model5)\n```\n\nCe dernier modèle présente une valeur de l'AIC plus faible et serait donc ainsi mieux ajusté que notre modèle avec seulement un intercepte aléatoire. Nous pouvons donc extraire les coefficients aléatoires et les représenter à la @fig-randomconstcoefGAM.\n\n```{r}\n#| label: fig-randomconstcoefGAM\n#| message: false\n#| warning: false\n#| fig-cap: Pentes et constantes aléatoires pour les arrondissements\ndf_re <- extract_random_effects.gam(model5)\ndf_re <- subset(df_re, df_re$effect == 'PopFRPct')\n\nggplot(df_re) + \n  geom_errorbarh(aes(xmin = lower_2.5, xmax = upper_97.5, y = reorder(group, value))) +\n  geom_point(aes(x = value, y = reorder(group, value))) + \n  geom_vline(xintercept = 0, color = \"red\") + \n  labs(y = \"Arrondissement\", x = \"coefficient aléatoire\")\n```\n\nNous constatons notamment que seuls trois arrondissements ont des coefficients aléatoires significativement différents de 0. Ainsi, pour les arrondissements Anjou et Plateau-Mont-Royal, les coefficients aléatoires sont respectivement de `r tofr(df_re[df_re$group == \"Anjou\",]$value[[1]])` et `r tofr(df_re[df_re$group == \"Le Plateau-Mont-Royal\",]$value[[1]])`, et viennent donc se retrancher à la valeur moyenne régionale de `r tofr(round(model5$coefficients[[4]],4))` qui atteint alors presque 0. Du point de vue de l'interprétation, nous pouvons en conclure que le groupe des personnes à faible revenu ne subit pas de surexposition aux îlots de chaleur à l'échelle des AD dans ces arrondissements.\n\nEn revanche, dans l'arrondissement Mercier-Hochelaga-Maisonneuve, la situation est à l'inverse plus systématiquement en défaveur des populations à faible revenu, avec une taille d'effet près de deux fois supérieure à la moyenne régionale. En effet, l'effet moyen régional (coefficient fixe) est de `r tofr(round(model5$coefficients[[4]],4))`, auquel vient s'ajouter l'effet spécifique (coefficient aléatoire) de Mercier-Hochelaga-Maisonneuve, soit `r tofr(df_re[df_re$group == \"Mercier-Hochelaga-Maisonneuve\",]$value[[1]])`, pour un effet total de `r tofr(df_re[df_re$group == \"Mercier-Hochelaga-Maisonneuve\",]$value[[1]] + round(model5$coefficients[[4]],4))`\n\n::: bloc_aller_loin\n::: bloc_aller_loin-header\n::: bloc_aller_loin-icon\n:::\n**Des effets aléatoires plus complexes dans les GAMM**\n:::\n::: bloc_aller_loin-body\nIl est possible de spécifier des GAMM avec des effets aléatoires plus complexes autorisant, par exemple, des corrélations entre les différents effets / niveaux. Il faut pour cela utiliser la fonction `gamm` de `mgcv` ou la fonction `gamm4` du *package* `gamm4.` La première offre plus de flexibilité, mais la seconde est plus facile à utiliser et doit être privilégiée quand un modèle comporte un très grand nombre de groupes dans un effet aléatoire, ou lorsque la distribution du modèle n'est pas gaussienne. La fonction `gamm` permet d'ajuster des modèles non gaussiens, mais elle utilise une approche appelée PQL (*Penalized Quasi-Likelihood* en anglais) connue pour être moins stable et moins précise.\n\nCependant, dans l'exemple de cette section, nous utilisons un modèle GAMM avec une distribution bêta, ce qui n'est actuellement pas supporté par les fonctions `gamm` et `gamm4`. Pour un modèle GAMM plus complexe utilisant une distribution bêta, il est nécessaire d'utiliser le *package* `gamlss`, mais ce dernier utilise aussi une approche de type PQL. Nous montrons tout de même ici comment ajouter un modèle qui inclut une corrélation entre les deux effets aléatoires de l'exemple précédent. Notez ici que le terme `re` apparaissant dans la formule permet de spécifier un effet aléatoire en utilisant la syntaxe du *package* `nlme.` Plus spécifiquement, `gamlss` fait un pont avec `nlme` et utilise son algorithme d'ajustement au sein de ces propres routines. De même, le terme `pb` permet de spécifier une *spline* de lissage dans le même esprit que `mgcv.` Il est également possible d'utiliser le terme `ga` faisant le lien avec `mgcv` et de profiter de sa flexibilité dans `gamlss`.\n\n```{r}\n#| message: false\n#| warning: false\n#| results: hide\nlibrary(gamlss)\nlibrary(gamlss.add)\n\nmodel6 <- gamlss(hot ~\n          pb(prt_veg) + \n          re(fixed = ~ A65Pct + A014Pct + PopFRPct + PopMVPct, \n             random = ~(1 + PopFRPct)|Arrond),\n        data = dataset, family = BE(mu.link = \"logit\"))\n```\n\nNous pouvons ensuite accéder à la partie du modèle qui nous intéresse, soit celle concernant les effets aléatoires.\n\n```{r}\n#| message: false\n#| warning: false\nrandomPart <- model6$mu.coefSmo[[2]]\nprint(randomPart)\n```\n\n\nÀ lecture de la partie du résumé consacrée aux résultats pour les effets aléatoires, nous constatons que la corrélation entre les interceptes aléatoires et les coefficients aléatoires est de -0,65. Cela signifie que pour les arrondissements avec des interceptes élevés (plus grande proportion d'îlots de chaleur), l'effet de la variable `PopFRPct` tend à être plus faible. Autrement dit, dans les arrondissements avec beaucoup d'îlots de chaleur, les personnes à faible revenu ont tendance à être moins exposées, tel qu'illustré à la @fig-corrrandom).\n\n```{r}\n#| label: fig-corrrandom\n#| fig-cap: Relation entre les effets aléatoires des arrondissements et la variable population à faible revenu\n#| fig-align: center\n#| message: false\n#| warning: false\n#| out-width: \"75%\"\n\ndf <- ranef(randomPart)\ndf$arrond <- rownames(df)\nnames(df) <- c('Intercept', 'PopFRPct', 'Arrondissement')\n\nggplot(df) + \n  geom_hline(yintercept = 0, color = \"red\") +\n  geom_vline(xintercept = 0, color = \"red\") +\n  geom_point(aes(x = Intercept, y = PopFRPct))\n```\n:::\n:::\n\n## Quiz de révision du chapitre {#sec-118}\n\n```{r}\n#| label: quizGAM\n#| echo: false\n#| warning: false\n#| results: asis\nsource(\"code_complementaire/QuizzFunctions.R\")\nquizz_gam <- quizz(\"quiz/Chapitre11-GAM.yml\", \"quizz_gam\")\nrender_quizz(quizz_gam)\n```\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":true,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["css/quizlib.min.css"],"output-file":"11-GAM.html"},"language":{"toc-title-document":"Table des matières","toc-title-website":"Sur cette page","related-formats-title":"Autres formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"La source","section-title-abstract":"Résumé","section-title-appendices":"Annexes","section-title-footnotes":"Notes de bas de page","section-title-references":"Les références","section-title-reuse":"Réutilisation","section-title-copyright":"Droits d'auteur","section-title-citation":"Citation","appendix-attribution-cite-as":"Veuillez citer ce travail comme suit :","appendix-attribution-bibtex":"BibTeX","title-block-author-single":"Auteur·rice","title-block-author-plural":"Auteurs","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Date de publication","title-block-modified":"Modifié","callout-tip-title":"Astuce","callout-note-title":"Note","callout-warning-title":"Avertissement","callout-important-title":"Important","callout-caution-title":"Mise en garde","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Montrer tout le code","code-tools-hide-all-code":"Cacher tout le code","code-tools-view-source":"Voir les sources","code-tools-source-code":"Code source","code-line":"Ligne","code-lines":"Lignes","copy-button-tooltip":"Copier vers le presse-papier","copy-button-tooltip-success":"Copié","repo-action-links-edit":"Modifier cette page","repo-action-links-source":"Voir la source","repo-action-links-issue":"Signaler un problème ou<br>formuler une suggestion","back-to-top":"Retour au sommet","search-no-results-text":"Pas de résultats","search-matching-documents-text":"documents trouvés","search-copy-link-title":"Copier le lien vers la recherche","search-hide-matches-text":"Cacher les correspondances additionnelles","search-more-match-text":"correspondance de plus dans ce document","search-more-matches-text":"correspondances de plus dans ce document","search-clear-button-title":"Effacer","search-detached-cancel-button-title":"Annuler","search-submit-button-title":"Envoyer","search":"Recherche","toggle-section":"Basculer la section","toggle-sidebar":"Basculer la barre latérale","toggle-dark-mode":"Basculer le mode sombre","toggle-reader-mode":"Basculer en mode lecteur","toggle-navigation":"Basculer la navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Théorème","crossref-lem-title":"Lemme","crossref-cor-title":"Corollaire","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Définition","crossref-exm-title":"Exemple","crossref-exr-title":"Exercice","crossref-ch-prefix":"Chapitre","crossref-apx-prefix":"Annexe","crossref-sec-prefix":"Section","crossref-eq-prefix":"Équation","crossref-lof-title":"Liste des Figures","crossref-lot-title":"Liste des Tables","crossref-lol-title":"Liste des Listings","environment-proof-title":"Preuve","environment-remark-title":"Remarque","environment-solution-title":"Solution","listing-page-order-by":"Trier par","listing-page-order-by-default":"Ordre par défaut","listing-page-order-by-date-asc":"Le plus ancien","listing-page-order-by-date-desc":"Le plus récent","listing-page-order-by-number-desc":"Descendant","listing-page-order-by-number-asc":"Ascendant","listing-page-field-date":"Date","listing-page-field-title":"Titre","listing-page-field-description":"Description","listing-page-field-author":"Auteur·rice","listing-page-field-filename":"Nom de fichier","listing-page-field-filemodified":"Modifié","listing-page-field-subtitle":"Sous-titre","listing-page-field-readingtime":"Temps de lecture","listing-page-field-categories":"Catégories","listing-page-minutes-compact":"{0} min.","listing-page-category-all":"Tous","listing-page-no-matches":"Aucun article correspondant"},"metadata":{"lang":"fr","fig-responsive":true,"quarto-version":"1.3.353","license":"CC BY-SA","crossref":{"fig-prefix":"figure","tbl-prefix":"tableau","sec-prefix":"section","eq-prefix":"équation","fig-title":"Figure","tbl-title":"Tableau","eq-title":"Équation"},"bibliography":["references.bib"],"csl":"StyleINRS.csl","colorlinks":true,"theme":{"light":["cosmo","css/r4ds.scss"]},"fontsize":"11pt","mainfont":"Helvetica Neue,Helvetica,Arial,sans-serif","monofont":"SFMono-Regular,Menlo,Monaco,Consolas,\"Liberation Mono\",\"Courier New\",monospace"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}